
main.elf:     file format elf32-bigarm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000009e4  00010000  00010000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .stack        00002000  00000000  00000000  00000074  2**0
                  ALLOC
  2 .comment      0000001b  00000000  00000000  000089e4  2**0
                  CONTENTS, READONLY
  3 .debug_aranges 00000040  00000000  00000000  00008a00  2**3
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000234  00000000  00000000  00008a40  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000777  00000000  00000000  00008c74  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000224  00000000  00000000  000093eb  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000002c3  00000000  00000000  0000960f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  0000022c  00000000  00000000  000098d4  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000002c1  00000000  00000000  00009b00  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000006ac  00000000  00000000  00009dc1  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00010000 <_boot>:

// Runtime Interrupt Vectors
// -------------------------
Vectors:
        b     _start                    // reset - _start
   10000:	ea000012 	b	10050 <_mainCRTStartup>
        b     und_handler               // undefined - _undf
   10004:	ea000063 	b	10198 <und_handler>
        b     swi_handler               // SWI - _swi
   10008:	ea000056 	b	10168 <swi_handler>
        b     iab_handler               // program abort - _pabt
   1000c:	ea000049 	b	10138 <iab_handler>
        b     iab_handler               // data abort - _dabt
   10010:	ea000048 	b	10138 <iab_handler>
        nop                             // reserved
   10014:	e1a00000 	nop			(mov r0,r0)
        ldr   pc,[pc,#-0xFF0]           // IRQ - read the VIC
   10018:	e51ffff0 	ldr	pc, [pc, #-4080]	; f030 <STACK_SIZE+0xd030>
        ldr   pc,[pc,#-0xFF0]           // FIQ - read the VIC
   1001c:	e51ffff0 	ldr	pc, [pc, #-4080]	; f034 <STACK_SIZE+0xd034>

00010020 <_undf>:
   10020:	00010038 	andeq	r0, r1, r8, lsr r0

00010024 <_swi>:
   10024:	0001003c 	andeq	r0, r1, ip, lsr r0

00010028 <_pabt>:
   10028:	00010040 	andeq	r0, r1, r0, asr #32

0001002c <_dabt>:
   1002c:	00010044 	andeq	r0, r1, r4, asr #32

00010030 <_irq>:
   10030:	00010048 	andeq	r0, r1, r8, asr #32

00010034 <_fiq>:
   10034:	0001004c 	andeq	r0, r1, ip, asr #32

00010038 <__undf>:

#if 0
// Use this group for production
_undf:  .word _reset                    // undefined - _reset
_swi:   .word _reset                    // SWI - _reset
_pabt:  .word _reset                    // program abort - _reset
_dabt:  .word _reset                    // data abort - _reset
_irq:   .word _reset                    // IRQ - _reset
_fiq:   .word _reset                    // FIQ - _reset

#else
// Use this group for development
_undf:  .word __undf                    // undefined
_swi:   .word __swi                     // SWI
_pabt:  .word __pabt                    // program abort
_dabt:  .word __dabt                    // data abort
_irq:   .word __irq                     // IRQ
_fiq:   .word __fiq                     // FIQ

__undf: b     .                         // undefined
   10038:	eafffffe 	b	10038 <__undf>

0001003c <__swi>:
__swi:  b     .                         // SWI
   1003c:	eafffffe 	b	1003c <__swi>

00010040 <__pabt>:
__pabt: b     .                         // program abort
   10040:	eafffffe 	b	10040 <__pabt>

00010044 <__dabt>:
__dabt: b     .                         // data abort
   10044:	eafffffe 	b	10044 <__dabt>

00010048 <__irq>:
__irq:  b     .                         // IRQ
   10048:	eafffffe 	b	10048 <__irq>

0001004c <__fiq>:
__fiq:  b     .                         // FIQ
   1004c:	eafffffe 	b	1004c <__fiq>

00010050 <_mainCRTStartup>:
#endif
        .size _boot, . - _boot
        .endfunc


// Setup the operating mode & stack.
// ---------------------------------
        .global _start, start, _mainCRTStartup
        .func   _start

_start:
start:
_mainCRTStartup:

// Initialize Interrupt System
// - Set stack location for each mode
// - Leave in System Mode with Interrupts Disabled
// -----------------------------------------------
        ldr	  r10, =0xAAAAAAAA
   10050:	e59fa22c 	ldr	sl, [pc, #556]	; 10284 <.text+0x284>
		ldr   r0,=_stack                    // Calc stack base
   10054:	e59f022c 	ldr	r0, [pc, #556]	; 10288 <.text+0x288>
		mrs   r1,CPSR
   10058:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
   1005c:	e3c1107f 	bic	r1, r1, #127	; 0x7f
		orr   r1,r1,#MODE_UND|IRQ_BIT|FIQ_BIT  // Change to Undefined Instruction mode
   10060:	e38110db 	orr	r1, r1, #219	; 0xdb
        msr   CPSR,r1
   10064:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
   10068:	e1a0d000 	mov	sp, r0

        sub   r0,r0,#UND_STACK_SIZE         // Calc stack base
   1006c:	e2400004 	sub	r0, r0, #4	; 0x4
		mrs   r1,CPSR
   10070:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
   10074:	e3c1107f 	bic	r1, r1, #127	; 0x7f
        orr   r1,r1,#MODE_ABT|IRQ_BIT|FIQ_BIT  // Change to Abort Mode
   10078:	e38110d7 	orr	r1, r1, #215	; 0xd7
        msr   CPSR,r1
   1007c:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
   10080:	e1a0d000 	mov	sp, r0

        sub   r0,r0,#ABT_STACK_SIZE         // Calc stack base
   10084:	e2400004 	sub	r0, r0, #4	; 0x4
		mrs   r1,CPSR
   10088:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
   1008c:	e3c1107f 	bic	r1, r1, #127	; 0x7f
        orr   r1,r1,#MODE_FIQ|IRQ_BIT|FIQ_BIT  // Change to FIQ Mode
   10090:	e38110d1 	orr	r1, r1, #209	; 0xd1
        msr   CPSR,r1
   10094:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
   10098:	e1a0d000 	mov	sp, r0

        sub   r0,r0,#FIQ_STACK_SIZE         // Calc stack base
   1009c:	e2400004 	sub	r0, r0, #4	; 0x4
		mrs   r1,CPSR
   100a0:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
   100a4:	e3c1107f 	bic	r1, r1, #127	; 0x7f
        orr   r1,r1,#MODE_IRQ|IRQ_BIT|FIQ_BIT  // Change to IRQ Mode
   100a8:	e38110d2 	orr	r1, r1, #210	; 0xd2
        msr   CPSR,r1
   100ac:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
   100b0:	e1a0d000 	mov	sp, r0

        sub   r0,r0,#IRQ_STACK_SIZE         // Calc stack base
   100b4:	e2400080 	sub	r0, r0, #128	; 0x80
		mrs   r1,CPSR
   100b8:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
   100bc:	e3c1107f 	bic	r1, r1, #127	; 0x7f
        orr   r1,r1,#MODE_SVC|IRQ_BIT|FIQ_BIT  // Change to Supervisor Mode
   100c0:	e38110d3 	orr	r1, r1, #211	; 0xd3
        msr   CPSR,r1
   100c4:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
   100c8:	e1a0d000 	mov	sp, r0

        sub   r0,r0,#SVC_STACK_SIZE         // Calc stack base
   100cc:	e2400004 	sub	r0, r0, #4	; 0x4
		mrs   r1,CPSR
   100d0:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
   100d4:	e3c1107f 	bic	r1, r1, #127	; 0x7f
        orr   r1,r1,#MODE_SYS|IRQ_BIT|FIQ_BIT  // Change to System Mode
   100d8:	e38110df 	orr	r1, r1, #223	; 0xdf
        msr   CPSR,r1
   100dc:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
   100e0:	e1a0d000 	mov	sp, r0

// Copy initialized data to its execution address in RAM
// -> not necessary, bootloader can be directly ecxecuted from ROM
// -----------------------------------------------------
//#ifdef ROM_RUN
//        ldr   r1,=_etext                // -> ROM data start
//        ldr   r2,=_data                 // -> data start
//        ldr   r3,=_edata                // -> end of data
//1:      cmp   r2,r3                     // check if data to move
//        ldrlo r0,[r1],#4                // copy it
//        strlo r0,[r2],#4
//        blo   1b                        // loop until done
//#endif

// Clear .bss
// Hell no!
// ----------
//        mov   r0,#0                     // get a zero
//        ldr   r1,=__bss_start           // -> bss start
//        ldr   r2,=__bss_end__           // -> bss end
//2:      cmp   r1,r2                     // check if data to clear
//        strlo r0,[r1],#4                // clear 4 bytes
//        blo   2b                        // loop until done

// Call main program: main(0)
// --------------------------
        mov   r0,#0                     // no arguments (argc = 0)
   100e4:	e3a00000 	mov	r0, #0	; 0x0
        mov   r1,r0
   100e8:	e1a01000 	mov	r1, r0
        mov   r2,r0
   100ec:	e1a02000 	mov	r2, r0
        mov   fp,r0                     // null frame pointer
   100f0:	e1a0b000 	mov	fp, r0
        mov   r7,r0                     // null frame pointer for thumb
   100f4:	e1a07000 	mov	r7, r0
        ldr   r10,=main
   100f8:	e59fa18c 	ldr	sl, [pc, #396]	; 1028c <.text+0x28c>
        mov   lr,pc
   100fc:	e1a0e00f 	mov	lr, pc
        bx    r10                       // enter main()
   10100:	e12fff1a 	bx	sl

00010104 <_reset>:

        .size   _start, . - _start
        .endfunc

        .global _reset, reset, exit, abort
        .func   _reset
_reset:
reset:
exit:
abort:

        b     .                         // loop until reset
   10104:	eafffffe 	b	10104 <_reset>

00010108 <dab_handler>:

// Data Fetch Abort Interrupt Handler
// -------------------------------------------------------------------
dab_handler:
		mov   r13, lr
   10108:	e1a0d00e 	mov	sp, lr
		mov   r4, #16
   1010c:	e3a04010 	mov	r4, #16	; 0x10
		mcr   p15, 0, r4, c13, c13, 0
   10110:	ee0d4f1d 	mcr	15, 0, r4, cr13, cr13, {0}
		mov   r4, #'<'
   10114:	e3a0403c 	mov	r4, #60	; 0x3c
		bl    uart0_send_byte
   10118:	eb000051 	bl	10264 <uart0_send_byte>
		mov   r4, #'D'
   1011c:	e3a04044 	mov	r4, #68	; 0x44
		bl    uart0_send_byte
   10120:	eb00004f 	bl	10264 <uart0_send_byte>
		mov   r4, #'A'
   10124:	e3a04041 	mov	r4, #65	; 0x41
		bl    uart0_send_byte
   10128:	eb00004d 	bl	10264 <uart0_send_byte>
		mov   r4, #'B'
   1012c:	e3a04042 	mov	r4, #66	; 0x42
		bl    uart0_send_byte
   10130:	eb00004b 	bl	10264 <uart0_send_byte>
		b     isr_handler
   10134:	ea000022 	b	101c4 <isr_handler>

00010138 <iab_handler>:

// Instruction Fetch Abort Interrupt Handler
// -------------------------------------------------------------------
iab_handler:
		mov   r13, lr
   10138:	e1a0d00e 	mov	sp, lr
		mov   r4, #32
   1013c:	e3a04020 	mov	r4, #32	; 0x20
		mcr   p15, 0, r4, c13, c13, 0
   10140:	ee0d4f1d 	mcr	15, 0, r4, cr13, cr13, {0}
		mov   r4, #'<'
   10144:	e3a0403c 	mov	r4, #60	; 0x3c
		bl    uart0_send_byte
   10148:	eb000045 	bl	10264 <uart0_send_byte>
		mov   r4, #'I'
   1014c:	e3a04049 	mov	r4, #73	; 0x49
		bl    uart0_send_byte
   10150:	eb000043 	bl	10264 <uart0_send_byte>
		mov   r4, #'A'
   10154:	e3a04041 	mov	r4, #65	; 0x41
		bl    uart0_send_byte
   10158:	eb000041 	bl	10264 <uart0_send_byte>
		mov   r4, #'B'
   1015c:	e3a04042 	mov	r4, #66	; 0x42
		bl    uart0_send_byte
   10160:	eb00003f 	bl	10264 <uart0_send_byte>
		b     isr_handler
   10164:	ea000016 	b	101c4 <isr_handler>

00010168 <swi_handler>:

// Software Interrupt Handler
// -------------------------------------------------------------------
swi_handler:
		mov   r13, lr
   10168:	e1a0d00e 	mov	sp, lr
		mov   r4, #64
   1016c:	e3a04040 	mov	r4, #64	; 0x40
		mcr   p15, 0, r4, c13, c13, 0
   10170:	ee0d4f1d 	mcr	15, 0, r4, cr13, cr13, {0}
		mov   r4, #'<'
   10174:	e3a0403c 	mov	r4, #60	; 0x3c
		bl    uart0_send_byte
   10178:	eb000039 	bl	10264 <uart0_send_byte>
		mov   r4, #'S'
   1017c:	e3a04053 	mov	r4, #83	; 0x53
		bl    uart0_send_byte
   10180:	eb000037 	bl	10264 <uart0_send_byte>
		mov   r4, #'W'
   10184:	e3a04057 	mov	r4, #87	; 0x57
		bl    uart0_send_byte
   10188:	eb000035 	bl	10264 <uart0_send_byte>
		mov   r4, #'I'
   1018c:	e3a04049 	mov	r4, #73	; 0x49
		bl    uart0_send_byte
   10190:	eb000033 	bl	10264 <uart0_send_byte>
		b     isr_handler
   10194:	ea00000a 	b	101c4 <isr_handler>

00010198 <und_handler>:

// Undefined Instruction Interrupt Handler
// -------------------------------------------------------------------
und_handler:
		mov   r13, lr
   10198:	e1a0d00e 	mov	sp, lr
		mov   r4, #128
   1019c:	e3a04080 	mov	r4, #128	; 0x80
		mcr   p15, 0, r4, c13, c13, 0
   101a0:	ee0d4f1d 	mcr	15, 0, r4, cr13, cr13, {0}
		mov   r4, #'<'
   101a4:	e3a0403c 	mov	r4, #60	; 0x3c
		bl    uart0_send_byte
   101a8:	eb00002d 	bl	10264 <uart0_send_byte>
		mov   r4, #'U'
   101ac:	e3a04055 	mov	r4, #85	; 0x55
		bl    uart0_send_byte
   101b0:	eb00002b 	bl	10264 <uart0_send_byte>
		mov   r4, #'N'
   101b4:	e3a0404e 	mov	r4, #78	; 0x4e
		bl    uart0_send_byte
   101b8:	eb000029 	bl	10264 <uart0_send_byte>
		mov   r4, #'D'
   101bc:	e3a04044 	mov	r4, #68	; 0x44
		bl    uart0_send_byte
   101c0:	eb000027 	bl	10264 <uart0_send_byte>

000101c4 <isr_handler>:

// Interrupt Handler
// -------------------------------------------------------------------
isr_handler:
		mov   r4, #'-'
   101c4:	e3a0402d 	mov	r4, #45	; 0x2d
		bl    uart0_send_byte
   101c8:	eb000025 	bl	10264 <uart0_send_byte>
		mov   r4, #'I'
   101cc:	e3a04049 	mov	r4, #73	; 0x49
		bl    uart0_send_byte
   101d0:	eb000023 	bl	10264 <uart0_send_byte>
		mov   r4, #'N'
   101d4:	e3a0404e 	mov	r4, #78	; 0x4e
		bl    uart0_send_byte
   101d8:	eb000021 	bl	10264 <uart0_send_byte>
		mov   r4, #'T'
   101dc:	e3a04054 	mov	r4, #84	; 0x54
		bl    uart0_send_byte
   101e0:	eb00001f 	bl	10264 <uart0_send_byte>
		mov   r4, #' '
   101e4:	e3a04020 	mov	r4, #32	; 0x20
		bl    uart0_send_byte
   101e8:	eb00001d 	bl	10264 <uart0_send_byte>
		mov   r4, #'@'
   101ec:	e3a04040 	mov	r4, #64	; 0x40
		bl    uart0_send_byte
   101f0:	eb00001b 	bl	10264 <uart0_send_byte>

		sub   r7, r13, #4
   101f4:	e24d7004 	sub	r7, sp, #4	; 0x4
		bl    uart0_print_hex
   101f8:	eb00000a 	bl	10228 <uart0_print_hex>

		mov   r4, #' '
   101fc:	e3a04020 	mov	r4, #32	; 0x20
		bl    uart0_send_byte
   10200:	eb000017 	bl	10264 <uart0_send_byte>
		mov   r4, #'['		
   10204:	e3a0405b 	mov	r4, #91	; 0x5b
		bl    uart0_send_byte
   10208:	eb000015 	bl	10264 <uart0_send_byte>

		mrc   p15,0,r7, c9, c9
   1020c:	ee197f19 	mrc	15, 0, r7, cr9, cr9, {0}
		bl    uart0_print_hex
   10210:	eb000004 	bl	10228 <uart0_print_hex>

		mov   r4, #']'
   10214:	e3a0405d 	mov	r4, #93	; 0x5d
		bl    uart0_send_byte
   10218:	eb000011 	bl	10264 <uart0_send_byte>
		mov   r4, #'>'
   1021c:	e3a0403e 	mov	r4, #62	; 0x3e
		bl    uart0_send_byte
   10220:	eb00000f 	bl	10264 <uart0_send_byte>
		b .
   10224:	eafffffe 	b	10224 <isr_handler+0x60>

00010228 <uart0_print_hex>:


// Send 32-bit HEX value via UART0
// -------------------------------------------------------------------
uart0_print_hex:
		mov   r9, lr // save link register
   10228:	e1a0900e 	mov	r9, lr
		mov   r8, #32
   1022c:	e3a08020 	mov	r8, #32	; 0x20

00010230 <uart0_print_hex_loop>:

uart0_print_hex_loop:
		cmp   r8, #0
   10230:	e3580000 	cmp	r8, #0	; 0x0
		moveq pc, r9
   10234:	01a0f009 	moveq	pc, r9

		sub   r8, r8, #4
   10238:	e2488004 	sub	r8, r8, #4	; 0x4
		mov   r6, r7, lsr r8 // isolate 4-bit value
   1023c:	e1a06837 	mov	r6, r7, lsr r8
		and   r6, r6, #0x0F
   10240:	e206600f 	and	r6, r6, #15	; 0xf

		cmp   r6, #9
   10244:	e3560009 	cmp	r6, #9	; 0x9
		bgt   adapt_char
   10248:	ca000001 	bgt	10254 <adapt_char>
		add   r4, r6, #'0'
   1024c:	e2864030 	add	r4, r6, #48	; 0x30

		b     uart0_print_hex_char
   10250:	ea000001 	b	1025c <uart0_print_hex_char>

00010254 <adapt_char>:
adapt_char:
		sub   r6, r6, #10
   10254:	e246600a 	sub	r6, r6, #10	; 0xa
		add   r4, r6, #'A'
   10258:	e2864041 	add	r4, r6, #65	; 0x41

0001025c <uart0_print_hex_char>:

uart0_print_hex_char:
		bl    uart0_send_byte
   1025c:	eb000000 	bl	10264 <uart0_send_byte>
		b     uart0_print_hex_loop
   10260:	eafffff2 	b	10230 <uart0_print_hex_loop>

00010264 <uart0_send_byte>:


// Send one char via UART0
// -------------------------------------------------------------------
uart0_send_byte:
		ldr   r0, =(0xFFFF001C)
   10264:	e59f0024 	ldr	r0, [pc, #36]	; 10290 <.text+0x290>
		ldr   r0, [r0]
   10268:	e5900000 	ldr	r0, [r0]
		and   r0, r0, #0x01
   1026c:	e2000001 	and	r0, r0, #1	; 0x1
		cmp   r0, #0
   10270:	e3500000 	cmp	r0, #0	; 0x0
		beq   uart0_send_byte
   10274:	0afffffa 	beq	10264 <uart0_send_byte>
		ldr   r0, =(0xFFFF0018)
   10278:	e59f0014 	ldr	r0, [pc, #20]	; 10294 <.text+0x294>
		str   r4, [r0]
   1027c:	e5804000 	str	r4, [r0]
		mov   pc, lr
   10280:	e1a0f00e 	mov	pc, lr
   10284:	aaaaaaaa 	bge	feabad34 <__bss_end__+0xfeaaa350>
   10288:	00002000 	andeq	r2, r0, r0
   1028c:	0001092c 	andeq	r0, r1, ip, lsr #18
   10290:	ffff001c 	undefined instruction 0xffff001c
   10294:	ffff0018 	undefined instruction 0xffff0018

00010298 <io_read_gpio0_pin>:
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		unsigned long temp = GPIO0_IN & (1<<pin);
   10298:	e3e03a0f 	mvn	r3, #61440	; 0xf000
   1029c:	e5131ffb 	ldr	r1, [r3, #-4091]
   102a0:	e20020ff 	and	r2, r0, #255	; 0xff
	
//	set_cmsr(_cmsr);
	return temp;
}
   102a4:	e3a00001 	mov	r0, #1	; 0x1
   102a8:	e0010210 	and	r0, r1, r0, lsl r2
   102ac:	e12fff1e 	bx	lr

000102b0 <io_read_gpio0_port>:

// ******************************************************************************
// Read general purpose IO port
   unsigned long io_read_gpio0_port(void)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		unsigned long temp = GPIO0_IN;
   102b0:	e3e03a0f 	mvn	r3, #61440	; 0xf000
   102b4:	e5130ffb 	ldr	r0, [r3, #-4091]

//	set_cmsr(_cmsr);
	return temp;
}
   102b8:	e12fff1e 	bx	lr

000102bc <io_set_gpio0_pin>:

// ******************************************************************************
// Set general purpose IO port
   void io_set_gpio0_pin(unsigned char pin)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		GPIO0_OUT = GPIO0_OUT | (1<<pin);
   102bc:	e3e01a0f 	mvn	r1, #61440	; 0xf000
   102c0:	e5113fff 	ldr	r3, [r1, #-4095]
   102c4:	e20000ff 	and	r0, r0, #255	; 0xff
   102c8:	e3a02001 	mov	r2, #1	; 0x1
   102cc:	e1833012 	orr	r3, r3, r2, lsl r0
   102d0:	e5013fff 	str	r3, [r1, #-4095]

//	set_cmsr(_cmsr);
}
   102d4:	e12fff1e 	bx	lr

000102d8 <io_clr_gpio0_pin>:

// ******************************************************************************
// Clear general purpose IO port
   void io_clr_gpio0_pin(unsigned char pin)
// ******************************************************************************
{
   102d8:	e20000ff 	and	r0, r0, #255	; 0xff
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		GPIO0_OUT = GPIO0_OUT & ~(1<<pin);
   102dc:	e3a02001 	mov	r2, #1	; 0x1
   102e0:	e1a02012 	mov	r2, r2, lsl r0
   102e4:	e3e01a0f 	mvn	r1, #61440	; 0xf000
   102e8:	e5113fff 	ldr	r3, [r1, #-4095]
   102ec:	e1e02002 	mvn	r2, r2
   102f0:	e0033002 	and	r3, r3, r2
   102f4:	e5013fff 	str	r3, [r1, #-4095]

//	set_cmsr(_cmsr);
}
   102f8:	e12fff1e 	bx	lr

000102fc <io_toggle_gpio0_pin>:
// ******************************************************************************
// Set general purpose IO port
   void io_toggle_gpio0_pin(unsigned char pin)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		GPIO0_OUT = GPIO0_OUT ^ (1<<pin);
   102fc:	e3e01a0f 	mvn	r1, #61440	; 0xf000
   10300:	e5113fff 	ldr	r3, [r1, #-4095]
   10304:	e20000ff 	and	r0, r0, #255	; 0xff
   10308:	e3a02001 	mov	r2, #1	; 0x1
   1030c:	e0233012 	eor	r3, r3, r2, lsl r0
   10310:	e5013fff 	str	r3, [r1, #-4095]

//	set_cmsr(_cmsr);
}
   10314:	e12fff1e 	bx	lr

00010318 <io_set_gpio0_port>:

// ******************************************************************************
// Clear general purpose IO port
   void io_set_gpio0_port(unsigned long value)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		GPIO0_OUT = value;
   10318:	e3e03a0f 	mvn	r3, #61440	; 0xf000
   1031c:	e5030fff 	str	r0, [r3, #-4095]

//	set_cmsr(_cmsr);
}
   10320:	e12fff1e 	bx	lr

00010324 <io_set_pwm>:



// ###########################################################################################################################
// Pulse-Width-Modulation Controller
// ###########################################################################################################################

// ******************************************************************************
// Set pwm value
   void io_set_pwm(unsigned char port, unsigned char data)
// ******************************************************************************
{
   10324:	e20000ff 	and	r0, r0, #255	; 0xff
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	unsigned long temp = 0;

	// value adjustment
	if(port > 7)
   10328:	e3500007 	cmp	r0, #7	; 0x7
   1032c:	e92d4010 	stmdb	sp!, {r4, lr}
   10330:	e3a0c000 	mov	ip, #0	; 0x0
   10334:	e3e0e0ff 	mvn	lr, #255	; 0xff
   10338:	e20110ff 	and	r1, r1, #255	; 0xff
   1033c:	8a000011 	bhi	10388 <io_set_pwm+0x64>
		port = 0;

	if(port < 4){
		temp = PWM0_CONF0; // get working copy
		temp = temp & ~(0xFF << (port*8)); // clear old value
		temp = temp | (unsigned long)(data << (port*8)); // insert new value
		PWM0_CONF0 = temp;
	}
	else{
		port = port-4;
		temp = PWM0_CONF1; // get working copy
		temp = temp & ~(0xFF << (port*8)); // clear old value
   10340:	e2403004 	sub	r3, r0, #4	; 0x4
   10344:	e20330ff 	and	r3, r3, #255	; 0xff
   10348:	e3500003 	cmp	r0, #3	; 0x3
   1034c:	e1a0e183 	mov	lr, r3, lsl #3
   10350:	e3e04a0f 	mvn	r4, #61440	; 0xf000
   10354:	e1a0c180 	mov	ip, r0, lsl #3
   10358:	9a000007 	bls	1037c <io_set_pwm+0x58>
   1035c:	e3a030ff 	mov	r3, #255	; 0xff
   10360:	e1a03e13 	mov	r3, r3, lsl lr
   10364:	e5142f8b 	ldr	r2, [r4, #-3979]
   10368:	e1e03003 	mvn	r3, r3
   1036c:	e0022003 	and	r2, r2, r3
		temp = temp | (unsigned long)(data << (port*8)); // insert new value
   10370:	e1822e11 	orr	r2, r2, r1, lsl lr
		PWM0_CONF1 = temp;
   10374:	e5042f8b 	str	r2, [r4, #-3979]
   10378:	e8bd8010 	ldmia	sp!, {r4, pc}
   1037c:	e3a030ff 	mov	r3, #255	; 0xff
   10380:	e1a03c13 	mov	r3, r3, lsl ip
   10384:	e1e0e003 	mvn	lr, r3
   10388:	e3e02a0f 	mvn	r2, #61440	; 0xf000
   1038c:	e5123f8f 	ldr	r3, [r2, #-3983]
   10390:	e003300e 	and	r3, r3, lr
   10394:	e1833c11 	orr	r3, r3, r1, lsl ip
   10398:	e5023f8f 	str	r3, [r2, #-3983]
   1039c:	e8bd8010 	ldmia	sp!, {r4, pc}

000103a0 <io_get_pwm>:
	}
//	set_cmsr(_cmsr);
}

// ******************************************************************************
// Set pwm value
   unsigned char io_get_pwm(unsigned char port)
// ******************************************************************************
{
   103a0:	e20000ff 	and	r0, r0, #255	; 0xff
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	unsigned long temp = 0;

	// value adjustment
	if(port > 7)
   103a4:	e3500007 	cmp	r0, #7	; 0x7
   103a8:	e3a02000 	mov	r2, #0	; 0x0
   103ac:	8a00000a 	bhi	103dc <io_get_pwm+0x3c>
		port = 0;

	if(port < 4)
		temp = PWM0_CONF0; // get config register
	else{
		port = port-4;
		temp = PWM0_CONF1; // get config register
   103b0:	e2403004 	sub	r3, r0, #4	; 0x4
   103b4:	e3500003 	cmp	r0, #3	; 0x3
   103b8:	e20320ff 	and	r2, r3, #255	; 0xff
   103bc:	9a000005 	bls	103d8 <io_get_pwm+0x38>
   103c0:	e3e03a0f 	mvn	r3, #61440	; 0xf000
   103c4:	e5130f8b 	ldr	r0, [r3, #-3979]
   103c8:	e1a02182 	mov	r2, r2, lsl #3
   103cc:	e1a00230 	mov	r0, r0, lsr r2
   103d0:	e20000ff 	and	r0, r0, #255	; 0xff
	}

	temp = temp >> (port*8); // only keep designated byte

//	set_cmsr(_cmsr);
	return (unsigned char)temp;
}
   103d4:	e12fff1e 	bx	lr
   103d8:	e1a02180 	mov	r2, r0, lsl #3
   103dc:	e3e03a0f 	mvn	r3, #61440	; 0xf000
   103e0:	e5130f8f 	ldr	r0, [r3, #-3983]
   103e4:	e1a00230 	mov	r0, r0, lsr r2
   103e8:	e20000ff 	and	r0, r0, #255	; 0xff
   103ec:	e12fff1e 	bx	lr

000103f0 <io_uart0_read_byte>:



// ###########################################################################################################################
// General Purpose UART "miniUART" (UART_0)
// ###########################################################################################################################

// ******************************************************************************
// Read one byte via UART 0
   int io_uart0_read_byte(void)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	int temp;
	if ((UART0_SREG & (1<<CUART_RXD)) != 0) // byte available?
   103f0:	e3e02a0f 	mvn	r2, #61440	; 0xf000
   103f4:	e5123efb 	ldr	r3, [r2, #-3835]
   103f8:	e3130002 	tst	r3, #2	; 0x2
   103fc:	e3e00000 	mvn	r0, #0	; 0x0
		temp = UART0_DATA;
   10400:	15120eff 	ldrne	r0, [r2, #-3839]
	else
		temp = -1;

//	set_cmsr(_cmsr);
	return temp;
}
   10404:	e12fff1e 	bx	lr

00010408 <io_uart0_send_byte>:

// ******************************************************************************
// Write one byte via UART 0
   int io_uart0_send_byte(int ch)
// ******************************************************************************
{
   10408:	e3e02a0f 	mvn	r2, #61440	; 0xf000
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
   1040c:	e5123efb 	ldr	r3, [r2, #-3835]
   10410:	e3130001 	tst	r3, #1	; 0x1
   10414:	0afffffc 	beq	1040c <io_uart0_send_byte+0x4>
	UART0_DATA = (ch & 0x000000FF);
   10418:	e20030ff 	and	r3, r0, #255	; 0xff
   1041c:	e5023eff 	str	r3, [r2, #-3839]

//	set_cmsr(_cmsr);
	return ch;
}
   10420:	e12fff1e 	bx	lr

00010424 <io_spi0_config>:



// ###########################################################################################################################
// Serial Peripherial Interface (SPI_CONTROLLER_0)
// ###########################################################################################################################

// ******************************************************************************
// Configure SPI 0
   void io_spi0_config(unsigned char auto_cs, unsigned long data_size)
// ******************************************************************************
{
   10424:	e20000ff 	and	r0, r0, #255	; 0xff
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
	// devices update their serial input on a rising edge of sclk,
	// so we need to update the mosi output of the core before
	// -> at the falling edge of sclk = set SPI_TX_NEG
	if(auto_cs == 1)
   10428:	e3500001 	cmp	r0, #1	; 0x1
		SPI0_CONF = (1<<SPI_ACS) | (1<<SPI_TX_NEG) | data_size; // auto assert cs
	else
		SPI0_CONF = (0<<SPI_ACS) | (1<<SPI_TX_NEG) | data_size; // manual assert cs
   1042c:	e3812b01 	orr	r2, r1, #1024	; 0x400
   10430:	03e03a0f 	mvneq	r3, #61440	; 0xf000
   10434:	e3811b09 	orr	r1, r1, #9216	; 0x2400
   10438:	13e03a0f 	mvnne	r3, #61440	; 0xf000
   1043c:	05031cff 	streq	r1, [r3, #-3327]
   10440:	15032cff 	strne	r2, [r3, #-3327]
   10444:	e12fff1e 	bx	lr

00010448 <io_spi0_speed>:
//	set_cmsr(_cmsr);
}

// ******************************************************************************
// Configure SPI 0 CLK frequency -> (sys_clk/(spi_clk*2))-1
   void io_spi0_speed(unsigned long clk_divider)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		SPI0_PRSC = clk_divider; // (sys_clk/(spi_clk*2))-1;
   10448:	e3e03a0f 	mvn	r3, #61440	; 0xf000
   1044c:	e5030cfb 	str	r0, [r3, #-3323]

//	set_cmsr(_cmsr);
}
   10450:	e12fff1e 	bx	lr

00010454 <io_spi0_trans>:

// ******************************************************************************
// Sends/receives max 32 bits via SPI, CS and config must be done outside
   unsigned long io_spi0_trans(unsigned long data)
// ******************************************************************************
{
   10454:	e3e02a0f 	mvn	r2, #61440	; 0xf000
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	// spi transmission
	while((SPI0_CONF & (1<<SPI_BUSY)) != 0); // wait for prev tx to finish
   10458:	e5123cff 	ldr	r3, [r2, #-3327]
   1045c:	e3130c01 	tst	r3, #256	; 0x100
   10460:	1afffffc 	bne	10458 <io_spi0_trans+0x4>
	SPI0_DAT0 = data;
   10464:	e5020cef 	str	r0, [r2, #-3311]
	SPI0_CONF = SPI0_CONF | (1<<SPI_BUSY); // start transmitter
   10468:	e5123cff 	ldr	r3, [r2, #-3327]
   1046c:	e3833c01 	orr	r3, r3, #256	; 0x100
   10470:	e5023cff 	str	r3, [r2, #-3327]
   10474:	e3e02a0f 	mvn	r2, #61440	; 0xf000
	while((SPI0_CONF & (1<<SPI_BUSY)) != 0); // wait for rx to finish
   10478:	e5123cff 	ldr	r3, [r2, #-3327]
   1047c:	e3130c01 	tst	r3, #256	; 0x100
   10480:	1afffffc 	bne	10478 <io_spi0_trans+0x24>
	unsigned long temp = SPI0_DAT0;
   10484:	e5120cef 	ldr	r0, [r2, #-3311]

//	set_cmsr(_cmsr);
	return temp;
}
   10488:	e12fff1e 	bx	lr

0001048c <io_spi0_enable>:

// ******************************************************************************
// Controls the CS of SPI0, enables a connected CS (turns it LOW)
   void io_spi0_enable(unsigned char device)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		SPI0_SCSR = SPI0_SCSR | (1<<device);
   1048c:	e3e01a0f 	mvn	r1, #61440	; 0xf000
   10490:	e5113cf7 	ldr	r3, [r1, #-3319]
   10494:	e20000ff 	and	r0, r0, #255	; 0xff
   10498:	e3a02001 	mov	r2, #1	; 0x1
   1049c:	e1833012 	orr	r3, r3, r2, lsl r0
   104a0:	e5013cf7 	str	r3, [r1, #-3319]

//	set_cmsr(_cmsr);
}
   104a4:	e12fff1e 	bx	lr

000104a8 <io_spi0_disable>:

// ******************************************************************************
// Controls the CS of SPI0, disables a connected CS (turns it HIGH)
   void io_spi0_disable(unsigned char device)
// ******************************************************************************
{
   104a8:	e20000ff 	and	r0, r0, #255	; 0xff
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		SPI0_SCSR = SPI0_SCSR & ~(1<<device);
   104ac:	e3a02001 	mov	r2, #1	; 0x1
   104b0:	e1a02012 	mov	r2, r2, lsl r0
   104b4:	e3e01a0f 	mvn	r1, #61440	; 0xf000
   104b8:	e5113cf7 	ldr	r3, [r1, #-3319]
   104bc:	e1e02002 	mvn	r2, r2
   104c0:	e0033002 	and	r3, r3, r2
   104c4:	e5013cf7 	str	r3, [r1, #-3319]

//	set_cmsr(_cmsr);
}
   104c8:	e12fff1e 	bx	lr

000104cc <io_i2c0_speed>:




// ###########################################################################################################################
// Inter Intergrated Circuit Interface (I²C_CONTROLLER_0)
// ###########################################################################################################################

// ******************************************************************************
// Configure SPI 0 CLK frequency -> (sys_clk/(5*i2c_clock)-1
   void io_i2c0_speed(unsigned long clk_divider)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
		I2C0_CTRL = I2C0_CTRL & ~(1<<I2C_EN); // disable i2c core
   104cc:	e3e02a0f 	mvn	r2, #61440	; 0xf000
   104d0:	e5123be7 	ldr	r3, [r2, #-3047]
		I2C0_PRLO = clk_divider;
		I2C0_PRHI = clk_divider >> 8;
   104d4:	e1a01420 	mov	r1, r0, lsr #8
   104d8:	e3c33080 	bic	r3, r3, #128	; 0x80
   104dc:	e5023be7 	str	r3, [r2, #-3047]
   104e0:	e5020bef 	str	r0, [r2, #-3055]
   104e4:	e5021beb 	str	r1, [r2, #-3051]
		I2C0_CTRL = I2C0_CTRL | (1<<I2C_EN); // enable i2c core
   104e8:	e5123be7 	ldr	r3, [r2, #-3047]
   104ec:	e3833080 	orr	r3, r3, #128	; 0x80
   104f0:	e5023be7 	str	r3, [r2, #-3047]
//	set_cmsr(_cmsr);
}
   104f4:	e12fff1e 	bx	lr

000104f8 <io_i2c0_byte_transfer>:

// ******************************************************************************
// Read/write byte from/to I²C slave, max 2 address bytes
   int io_i2c0_byte_transfer(unsigned char rw,        // 'r' read / 'w' write cycle
                             unsigned char id,        // device ID
							 unsigned long data_adr,  // data address
							 unsigned char adr_bytes, // number of adr bytes
							 unsigned char data)      // data byte
// ******************************************************************************
{
   104f8:	e92d4030 	stmdb	sp!, {r4, r5, lr}
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	// transfer slave identification address
	I2C0_DATA = id & 0xFE;                  // device id and write
	I2C0_CMD = (1<<I2C_STA) | (1<<I2C_WR);  // start condition and write cycle
   104fc:	e3a0c090 	mov	ip, #144	; 0x90
   10500:	e20140fe 	and	r4, r1, #254	; 0xfe
   10504:	e3e0ea0f 	mvn	lr, #61440	; 0xf000
   10508:	e5dd500f 	ldrb	r5, [sp, #15]
   1050c:	e20000ff 	and	r0, r0, #255	; 0xff
   10510:	e50e4be3 	str	r4, [lr, #-3043]
   10514:	e20110ff 	and	r1, r1, #255	; 0xff
   10518:	e50ecbff 	str	ip, [lr, #-3071]
   1051c:	e1a04002 	mov	r4, r2
   10520:	e203c0ff 	and	ip, r3, #255	; 0xff
	while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
   10524:	e51e3bff 	ldr	r3, [lr, #-3071]
   10528:	e3130002 	tst	r3, #2	; 0x2
   1052c:	1afffffc 	bne	10524 <io_i2c0_byte_transfer+0x2c>
	if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
   10530:	e51e3bff 	ldr	r3, [lr, #-3071]
   10534:	e3130080 	tst	r3, #128	; 0x80
   10538:	13e00000 	mvnne	r0, #0	; 0x0
   1053c:	18bd8030 	ldmneia	sp!, {r4, r5, pc}
//		set_cmsr(_cmsr);
		return -1;
	}

	// transfer data address
	while(adr_bytes != 0){
   10540:	e35c0000 	cmp	ip, #0	; 0x0
   10544:	0a000012 	beq	10594 <io_i2c0_byte_transfer+0x9c>
		adr_bytes--;
   10548:	e24c3001 	sub	r3, ip, #1	; 0x1
   1054c:	e203c0ff 	and	ip, r3, #255	; 0xff
		if(adr_bytes == 1)
   10550:	e35c0001 	cmp	ip, #1	; 0x1
			I2C0_DATA = data_adr >> 8;          // high byte
   10554:	01a02424 	moveq	r2, r4, lsr #8
   10558:	03e03a0f 	mvneq	r3, #61440	; 0xf000
		else
			I2C0_DATA = data_adr;               // low byte
   1055c:	13e03a0f 	mvnne	r3, #61440	; 0xf000
   10560:	05032be3 	streq	r2, [r3, #-3043]
   10564:	15034be3 	strne	r4, [r3, #-3043]
		I2C0_CMD = (1<<I2C_WR);                 // write cycle
   10568:	e3e02a0f 	mvn	r2, #61440	; 0xf000
   1056c:	e3a03010 	mov	r3, #16	; 0x10
   10570:	e5023bff 	str	r3, [r2, #-3071]
		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
   10574:	e5123bff 	ldr	r3, [r2, #-3071]
   10578:	e3130002 	tst	r3, #2	; 0x2
   1057c:	1afffffc 	bne	10574 <io_i2c0_byte_transfer+0x7c>
		if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
   10580:	e5123bff 	ldr	r3, [r2, #-3071]
   10584:	e3130080 	tst	r3, #128	; 0x80
   10588:	0affffec 	beq	10540 <io_i2c0_byte_transfer+0x48>
   1058c:	e3e00001 	mvn	r0, #1	; 0x1
   10590:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
//			set_cmsr(_cmsr);
			return -2;
		}
	}

	if(rw == 'w'){
   10594:	e3500077 	cmp	r0, #119	; 0x77
   10598:	1a00000c 	bne	105d0 <io_i2c0_byte_transfer+0xd8>
		// write adressed byte
		I2C0_DATA = data;                       // send data
   1059c:	e3e03a0f 	mvn	r3, #61440	; 0xf000
		I2C0_CMD = (1<<I2C_STO) | (1<<I2C_WR);  // stop condition and write cycle
   105a0:	e3a02050 	mov	r2, #80	; 0x50
   105a4:	e5035be3 	str	r5, [r3, #-3043]
   105a8:	e5032bff 	str	r2, [r3, #-3071]
   105ac:	e1a02003 	mov	r2, r3
		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
   105b0:	e5123bff 	ldr	r3, [r2, #-3071]
   105b4:	e3130002 	tst	r3, #2	; 0x2
   105b8:	1afffffc 	bne	105b0 <io_i2c0_byte_transfer+0xb8>
		if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
   105bc:	e5123bff 	ldr	r3, [r2, #-3071]
   105c0:	e2130080 	ands	r0, r3, #128	; 0x80
   105c4:	08bd8030 	ldmeqia	sp!, {r4, r5, pc}
//			set_cmsr(_cmsr);
			return -3;
		}
		else{
//			set_cmsr(_cmsr);
			return 0;
		}
	}

	if(rw == 'r'){
		// re-send control byte - this time with read-bit
		I2C0_DATA = id | 0x01;                  // device id and READ
		I2C0_CMD = (1<<I2C_STA) | (1<<I2C_WR);  // start condition and write cycle
		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
		if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
//			set_cmsr(_cmsr);
			return -3;
		}
		// read adressed byte
		I2C0_CMD = (1<<I2C_STO) | (1<<I2C_RD) | (1<<I2C_ACK);
		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
		return I2C0_DATA;
   105c8:	e3e00002 	mvn	r0, #2	; 0x2
	}

//	set_cmsr(_cmsr);
	return -4;
}
   105cc:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
   105d0:	e3500072 	cmp	r0, #114	; 0x72
   105d4:	13e00003 	mvnne	r0, #3	; 0x3
   105d8:	18bd8030 	ldmneia	sp!, {r4, r5, pc}
   105dc:	e3813001 	orr	r3, r1, #1	; 0x1
   105e0:	e3e02a0f 	mvn	r2, #61440	; 0xf000
   105e4:	e3a01090 	mov	r1, #144	; 0x90
   105e8:	e5023be3 	str	r3, [r2, #-3043]
   105ec:	e5021bff 	str	r1, [r2, #-3071]
   105f0:	e5123bff 	ldr	r3, [r2, #-3071]
   105f4:	e3130002 	tst	r3, #2	; 0x2
   105f8:	1afffffc 	bne	105f0 <io_i2c0_byte_transfer+0xf8>
   105fc:	e5123bff 	ldr	r3, [r2, #-3071]
   10600:	e3130080 	tst	r3, #128	; 0x80
   10604:	1affffef 	bne	105c8 <io_i2c0_byte_transfer+0xd0>
   10608:	e3a03068 	mov	r3, #104	; 0x68
   1060c:	e5023bff 	str	r3, [r2, #-3071]
   10610:	e3e00a0f 	mvn	r0, #61440	; 0xf000
   10614:	e5103bff 	ldr	r3, [r0, #-3071]
   10618:	e3130002 	tst	r3, #2	; 0x2
   1061c:	1afffffc 	bne	10614 <io_i2c0_byte_transfer+0x11c>
   10620:	e5100be3 	ldr	r0, [r0, #-3043]
   10624:	e8bd8030 	ldmia	sp!, {r4, r5, pc}

00010628 <get_syscpreg>:




// ###########################################################################################################################
// System
// ###########################################################################################################################

// ******************************************************************************
// read system coprocessor register x
   unsigned long get_syscpreg(unsigned char index)
// ******************************************************************************
{
   10628:	e20000ff 	and	r0, r0, #255	; 0xff
	unsigned long _cp_val;
	switch(index){
   1062c:	e350000f 	cmp	r0, #15	; 0xf
   10630:	979ff100 	ldrls	pc, [pc, r0, lsl #2]
   10634:	ea00000f 	b	10678 <.text+0x678>
   10638:	000106f8 	streqd	r0, [r1], -r8
   1063c:	000106f0 	streqd	r0, [r1], -r0
   10640:	000106e8 	andeq	r0, r1, r8, ror #13
   10644:	000106e0 	andeq	r0, r1, r0, ror #13
   10648:	000106d8 	ldreqd	r0, [r1], -r8
   1064c:	000106d0 	ldreqd	r0, [r1], -r0
   10650:	000106c8 	andeq	r0, r1, r8, asr #13
   10654:	000106c0 	andeq	r0, r1, r0, asr #13
   10658:	000106b8 	streqh	r0, [r1], -r8
   1065c:	000106b0 	streqh	r0, [r1], -r0
   10660:	000106a8 	andeq	r0, r1, r8, lsr #13
   10664:	000106a0 	andeq	r0, r1, r0, lsr #13
   10668:	00010698 	muleq	r1, r8, r6
   1066c:	00010690 	muleq	r1, r0, r6
   10670:	00010688 	andeq	r0, r1, r8, lsl #13
   10674:	00010680 	andeq	r0, r1, r0, lsl #13
   10678:	e3a00000 	mov	r0, #0	; 0x0
   1067c:	e12fff1e 	bx	lr
		case ID_REG_0:   asm volatile ("mrc p15,0,%0, c0, c0" : "=r" (_cp_val) : /* no inputs */  ); break;
		case ID_REG_1:   asm volatile ("mrc p15,0,%0, c1, c1" : "=r" (_cp_val) : /* no inputs */  ); break;
		case ID_REG_2:   asm volatile ("mrc p15,0,%0, c2, c2" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 3:          asm volatile ("mrc p15,0,%0, c3, c3" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 4:          asm volatile ("mrc p15,0,%0, c4, c4" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 5:          asm volatile ("mrc p15,0,%0, c5, c5" : "=r" (_cp_val) : /* no inputs */  ); break;
		case SYS_CTRL_0: asm volatile ("mrc p15,0,%0, c6, c6" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 7:          asm volatile ("mrc p15,0,%0, c7, c7" : "=r" (_cp_val) : /* no inputs */  ); break;
		case CSTAT:      asm volatile ("mrc p15,0,%0, c8, c8" : "=r" (_cp_val) : /* no inputs */  ); break;
		case ADR_FB:     asm volatile ("mrc p15,0,%0, c9, c9" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 10:         asm volatile ("mrc p15,0,%0,c10,c10" : "=r" (_cp_val) : /* no inputs */  ); break;
		case LFSR_POLY:  asm volatile ("mrc p15,0,%0,c11,c11" : "=r" (_cp_val) : /* no inputs */  ); break;
		case LFSR_DATA:  asm volatile ("mrc p15,0,%0,c12,c12" : "=r" (_cp_val) : /* no inputs */  ); break;
		case SYS_IO:     asm volatile ("mrc p15,0,%0,c13,c13" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 14:         asm volatile ("mrc p15,0,%0,c14,c14" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 15:         asm volatile ("mrc p15,0,%0,c15,c15" : "=r" (_cp_val) : /* no inputs */  ); break;
   10680:	ee1f0f1f 	mrc	15, 0, r0, cr15, cr15, {0}
		default:         _cp_val = 0; break;
	}
	return _cp_val;
}
   10684:	e12fff1e 	bx	lr
   10688:	ee1e0f1e 	mrc	15, 0, r0, cr14, cr14, {0}
   1068c:	e12fff1e 	bx	lr
   10690:	ee1d0f1d 	mrc	15, 0, r0, cr13, cr13, {0}
   10694:	e12fff1e 	bx	lr
   10698:	ee1c0f1c 	mrc	15, 0, r0, cr12, cr12, {0}
   1069c:	e12fff1e 	bx	lr
   106a0:	ee1b0f1b 	mrc	15, 0, r0, cr11, cr11, {0}
   106a4:	e12fff1e 	bx	lr
   106a8:	ee1a0f1a 	mrc	15, 0, r0, cr10, cr10, {0}
   106ac:	e12fff1e 	bx	lr
   106b0:	ee190f19 	mrc	15, 0, r0, cr9, cr9, {0}
   106b4:	e12fff1e 	bx	lr
   106b8:	ee180f18 	mrc	15, 0, r0, cr8, cr8, {0}
   106bc:	e12fff1e 	bx	lr
   106c0:	ee170f17 	mrc	15, 0, r0, cr7, cr7, {0}
   106c4:	e12fff1e 	bx	lr
   106c8:	ee160f16 	mrc	15, 0, r0, cr6, cr6, {0}
   106cc:	e12fff1e 	bx	lr
   106d0:	ee150f15 	mrc	15, 0, r0, cr5, cr5, {0}
   106d4:	e12fff1e 	bx	lr
   106d8:	ee140f14 	mrc	15, 0, r0, cr4, cr4, {0}
   106dc:	e12fff1e 	bx	lr
   106e0:	ee130f13 	mrc	15, 0, r0, cr3, cr3, {0}
   106e4:	e12fff1e 	bx	lr
   106e8:	ee120f12 	mrc	15, 0, r0, cr2, cr2, {0}
   106ec:	e12fff1e 	bx	lr
   106f0:	ee110f11 	mrc	15, 0, r0, cr1, cr1, {0}
   106f4:	e12fff1e 	bx	lr
   106f8:	ee100f10 	mrc	15, 0, r0, cr0, cr0, {0}
   106fc:	e12fff1e 	bx	lr

00010700 <set_syscpreg>:

// ******************************************************************************
// write system coprocessor register x
   void set_syscpreg(unsigned long _cp_val, unsigned char index)
// ******************************************************************************
{
   10700:	e20110ff 	and	r1, r1, #255	; 0xff
	switch(index){
   10704:	e2411006 	sub	r1, r1, #6	; 0x6
   10708:	e3510007 	cmp	r1, #7	; 0x7
   1070c:	979ff101 	ldrls	pc, [pc, r1, lsl #2]
   10710:	ea000008 	b	10738 <.text+0x738>
   10714:	0001073c 	andeq	r0, r1, ip, lsr r7
   10718:	00010738 	andeq	r0, r1, r8, lsr r7
   1071c:	00010738 	andeq	r0, r1, r8, lsr r7
   10720:	00010738 	andeq	r0, r1, r8, lsr r7
   10724:	00010738 	andeq	r0, r1, r8, lsr r7
   10728:	00010744 	andeq	r0, r1, r4, asr #14
   1072c:	0001074c 	andeq	r0, r1, ip, asr #14
   10730:	00010734 	andeq	r0, r1, r4, lsr r7
//		case ID_REG_0:   asm volatile ("mcr p15,0,%0, c0, c0,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case ID_REG_1:   asm volatile ("mcr p15,0,%0, c1, c1,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case ID_REG_2:   asm volatile ("mcr p15,0,%0, c2, c2,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 3:          asm volatile ("mcr p15,0,%0, c3, c3,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 4:          asm volatile ("mcr p15,0,%0, c4, c4,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 5:          asm volatile ("mcr p15,0,%0, c5, c5,0" : /* no outputs */ : "r" (_cp_val)); break;
		case SYS_CTRL_0: asm volatile ("mcr p15,0,%0, c6, c6,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 7:          asm volatile ("mcr p15,0,%0, c7, c7,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case CSTAT:      asm volatile ("mcr p15,0,%0, c8, c8,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case ADR_FB:     asm volatile ("mcr p15,0,%0, c9, c9,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 10:         asm volatile ("mcr p15,0,%0,c10,c10,0" : /* no outputs */ : "r" (_cp_val)); break;
		case LFSR_POLY:  asm volatile ("mcr p15,0,%0,c11,c11,0" : /* no outputs */ : "r" (_cp_val)); break;
		case LFSR_DATA:  asm volatile ("mcr p15,0,%0,c12,c12,0" : /* no outputs */ : "r" (_cp_val)); break;
		case SYS_IO:     asm volatile ("mcr p15,0,%0,c13,c13,0" : /* no outputs */ : "r" (_cp_val)); break;
   10734:	ee0d0f1d 	mcr	15, 0, r0, cr13, cr13, {0}
   10738:	e12fff1e 	bx	lr
   1073c:	ee060f16 	mcr	15, 0, r0, cr6, cr6, {0}
   10740:	e12fff1e 	bx	lr
   10744:	ee0b0f1b 	mcr	15, 0, r0, cr11, cr11, {0}
   10748:	e12fff1e 	bx	lr
   1074c:	ee0c0f1c 	mcr	15, 0, r0, cr12, cr12, {0}
   10750:	e12fff1e 	bx	lr

00010754 <long_to_hex_string>:
   void long_to_hex_string(unsigned long data,    // max 32 bit data word
                           unsigned char *buffer, // buffer to store the string
						   unsigned char numbers) // number of places, max 8
// ############################################################################################
{
   10754:	e92d4010 	stmdb	sp!, {r4, lr}
   10758:	e20240ff 	and	r4, r2, #255	; 0xff
	unsigned char temp_char = 0;
	unsigned long temp_data = 0;

	// fit into range
	if(numbers > 8)
   1075c:	e3540008 	cmp	r4, #8	; 0x8
   10760:	83a04008 	movhi	r4, #8	; 0x8
   10764:	8a000001 	bhi	10770 <long_to_hex_string+0x1c>
		numbers = 8;
	if(numbers < 1)
   10768:	e3540000 	cmp	r4, #0	; 0x0
		numbers = 1;

	while(numbers > 0){
		// isolate one 4-bit value
		if(numbers > 1)
			temp_data = data >> ((numbers-1)*4);
		else
			temp_data = data;
		temp_data = temp_data & 0x0000000F;
		numbers--;

		// convert 4-bit value temp_data to char temp_char
		if(temp_data < 10)
			temp_char = '0' + temp_data;
		else
			temp_char = 'A' + temp_data - 10;

		// save character
		*buffer++ = temp_char;
	}

	*buffer++ = 0; // terminate string
}
   1076c:	03a04001 	moveq	r4, #1	; 0x1
   10770:	e1a02001 	mov	r2, r1
   10774:	e1a0e004 	mov	lr, r4
   10778:	e1a0310e 	mov	r3, lr, lsl #2
   1077c:	e35e0001 	cmp	lr, #1	; 0x1
   10780:	e2433004 	sub	r3, r3, #4	; 0x4
   10784:	e1a0c000 	mov	ip, r0
   10788:	81a0c330 	movhi	ip, r0, lsr r3
   1078c:	e24e3001 	sub	r3, lr, #1	; 0x1
   10790:	e20cc00f 	and	ip, ip, #15	; 0xf
   10794:	e203e0ff 	and	lr, r3, #255	; 0xff
   10798:	e35c0009 	cmp	ip, #9	; 0x9
   1079c:	e28c3030 	add	r3, ip, #48	; 0x30
   107a0:	828c3037 	addhi	r3, ip, #55	; 0x37
   107a4:	e35e0000 	cmp	lr, #0	; 0x0
   107a8:	e4c23001 	strb	r3, [r2], #1
   107ac:	1afffff1 	bne	10778 <long_to_hex_string+0x24>
   107b0:	e2443001 	sub	r3, r4, #1	; 0x1
   107b4:	e20330ff 	and	r3, r3, #255	; 0xff
   107b8:	e0813003 	add	r3, r1, r3
   107bc:	e5c3e001 	strb	lr, [r3, #1]
   107c0:	e8bd8010 	ldmia	sp!, {r4, pc}

000107c4 <get_adc>:

// ############################################################################################
// read external ADC value
   unsigned int get_adc(int adc_index) // adc 0..7
// ############################################################################################
{
   107c4:	e92d4010 	stmdb	sp!, {r4, lr}
   107c8:	e1a04000 	mov	r4, r0
	unsigned long temp;

	if ((adc_index < 0) || (adc_index > 7))
   107cc:	e3540007 	cmp	r4, #7	; 0x7
		return 0;

	// config spi
	io_spi0_config(1,16); // auto assert cs, 16 bit transfer
   107d0:	e3a01010 	mov	r1, #16	; 0x10
   107d4:	e3a00001 	mov	r0, #1	; 0x1
   107d8:	9a000001 	bls	107e4 <get_adc+0x20>
	io_spi0_enable(adc_cs);

	temp = adc_index * 2048;
	io_spi0_trans(0); // dummy read
	return (unsigned int)io_spi0_trans(temp);
}
   107dc:	e3a00000 	mov	r0, #0	; 0x0
   107e0:	e8bd8010 	ldmia	sp!, {r4, pc}
   107e4:	ebffff0e 	bl	10424 <io_spi0_config>
   107e8:	e3a00006 	mov	r0, #6	; 0x6
   107ec:	ebffff26 	bl	1048c <io_spi0_enable>
   107f0:	e3a00000 	mov	r0, #0	; 0x0
   107f4:	ebffff16 	bl	10454 <io_spi0_trans>
   107f8:	e1a00584 	mov	r0, r4, lsl #11
   107fc:	e8bd4010 	ldmia	sp!, {r4, lr}
   10800:	eaffff13 	b	10454 <io_spi0_trans>

00010804 <delay>:

// ############################################################################################
// simple delay routine
   void delay(int time) // waits time*10000 clock ticks
// ############################################################################################
{
	time = time*2500*4;
   10804:	e0603280 	rsb	r3, r0, r0, lsl #5
   10808:	e0800103 	add	r0, r0, r3, lsl #2
   1080c:	e0800100 	add	r0, r0, r0, lsl #2
   10810:	e1a00200 	mov	r0, r0, lsl #4
	while(time > 0){
   10814:	e3500000 	cmp	r0, #0	; 0x0
   10818:	d12fff1e 	bxle	lr
		asm volatile ("NOP");
   1081c:	e1a00000 	nop			(mov r0,r0)
   10820:	e2500001 	subs	r0, r0, #1	; 0x1
   10824:	1afffffc 	bne	1081c <delay+0x18>
   10828:	e12fff1e 	bx	lr

0001082c <string_cmpc>:
		time--;
	}
}

// ############################################################################################
// String compare, buffered string with immediate const char string
   unsigned char string_cmpc(unsigned char *string1, const char *string2, unsigned char length)
// ############################################################################################
{
	while(length != 0){
   1082c:	e212c0ff 	ands	ip, r2, #255	; 0xff
   10830:	0a00000b 	beq	10864 <string_cmpc+0x38>
		if(*string1++ != (unsigned char)*string2++)
   10834:	e5d02000 	ldrb	r2, [r0]
   10838:	e5d13000 	ldrb	r3, [r1]
   1083c:	e1520003 	cmp	r2, r3
   10840:	0a000004 	beq	10858 <string_cmpc+0x2c>
   10844:	ea000008 	b	1086c <string_cmpc+0x40>
   10848:	e5f02001 	ldrb	r2, [r0, #1]!
   1084c:	e5f13001 	ldrb	r3, [r1, #1]!
   10850:	e1520003 	cmp	r2, r3
   10854:	1a000004 	bne	1086c <string_cmpc+0x40>
			return(0); // missmatch
		length--;
   10858:	e24c3001 	sub	r3, ip, #1	; 0x1
   1085c:	e213c0ff 	ands	ip, r3, #255	; 0xff
   10860:	1afffff8 	bne	10848 <string_cmpc+0x1c>
   10864:	e3a00001 	mov	r0, #1	; 0x1
	}
	return(1); // match
}
   10868:	e12fff1e 	bx	lr
   1086c:	e3a00000 	mov	r0, #0	; 0x0
   10870:	e12fff1e 	bx	lr

00010874 <uart0_printf>:
// ############################################################################################
// Print text string via UART 0
   const char *uart0_printf(const char *string)
// ############################################################################################
{
   10874:	e92d4010 	stmdb	sp!, {r4, lr}
   10878:	e1a04000 	mov	r4, r0
	char ch;

	while ((ch = *string)){
   1087c:	e5d00000 	ldrb	r0, [r0]
   10880:	e3500000 	cmp	r0, #0	; 0x0
   10884:	1a000003 	bne	10898 <uart0_printf+0x24>
   10888:	ea000005 	b	108a4 <uart0_printf+0x30>
   1088c:	e5f40001 	ldrb	r0, [r4, #1]!
   10890:	e3500000 	cmp	r0, #0	; 0x0
   10894:	0a000002 	beq	108a4 <uart0_printf+0x30>
		if (io_uart0_send_byte(ch)<=0)
   10898:	ebfffeda 	bl	10408 <io_uart0_send_byte>
   1089c:	e3500000 	cmp	r0, #0	; 0x0
   108a0:	cafffff9 	bgt	1088c <uart0_printf+0x18>
			break;
		string++;
	}
	return string;
}
   108a4:	e1a00004 	mov	r0, r4
   108a8:	e8bd8010 	ldmia	sp!, {r4, pc}

000108ac <uart0_scanf>:

// ############################################################################################
// Read text string via UART 0
   void uart0_scanf(unsigned char *buffer, int length, unsigned char en_echo)
// ############################################################################################
{
   108ac:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
	int temp = 0;

	while(length > 0){
   108b0:	e2514000 	subs	r4, r1, #0	; 0x0
   108b4:	e1a05000 	mov	r5, r0
   108b8:	e20260ff 	and	r6, r2, #255	; 0xff
   108bc:	da00000b 	ble	108f0 <uart0_scanf+0x44>
		temp = io_uart0_read_byte();
   108c0:	ebfffeca 	bl	103f0 <io_uart0_read_byte>
		if(temp != -1){
   108c4:	e3700001 	cmn	r0, #1	; 0x1
			temp = (unsigned char)(temp & 0x000000FF);
   108c8:	e20030ff 	and	r3, r0, #255	; 0xff
   108cc:	0a000005 	beq	108e8 <uart0_scanf+0x3c>
			*buffer++ = temp;
			if(en_echo == 1)
   108d0:	e3560001 	cmp	r6, #1	; 0x1
   108d4:	e5c53000 	strb	r3, [r5]
				io_uart0_send_byte(temp); // echo
   108d8:	e1a00003 	mov	r0, r3
   108dc:	e2855001 	add	r5, r5, #1	; 0x1
   108e0:	0a000005 	beq	108fc <uart0_scanf+0x50>
			length--;
   108e4:	e2444001 	sub	r4, r4, #1	; 0x1
   108e8:	e3540000 	cmp	r4, #0	; 0x0
   108ec:	cafffff3 	bgt	108c0 <uart0_scanf+0x14>
		}
	}
	*buffer="\0";
   108f0:	e59f300c 	ldr	r3, [pc, #12]	; 10904 <.text+0x904>
   108f4:	e5c53000 	strb	r3, [r5]
}
   108f8:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
   108fc:	ebfffec1 	bl	10408 <io_uart0_send_byte>
   10900:	eafffff7 	b	108e4 <uart0_scanf+0x38>
   10904:	00010994 	muleq	r1, r4, r9

00010908 <uart0_print_buffer>:

// ############################################################################################
// Print character buffer via UART 0
   void uart0_print_buffer(unsigned char *buffer, int size)
// ############################################################################################
{
   10908:	e92d4030 	stmdb	sp!, {r4, r5, lr}
	unsigned char char_buffer = 0;
	while(size > 0){
   1090c:	e2514000 	subs	r4, r1, #0	; 0x0
   10910:	e1a05000 	mov	r5, r0
   10914:	d8bd8030 	ldmleia	sp!, {r4, r5, pc}
		char_buffer = *buffer++;
		io_uart0_send_byte((int)char_buffer);
   10918:	e4d50001 	ldrb	r0, [r5], #1
   1091c:	ebfffeb9 	bl	10408 <io_uart0_send_byte>
   10920:	e2544001 	subs	r4, r4, #1	; 0x1
   10924:	1afffffb 	bne	10918 <uart0_print_buffer+0x10>
   10928:	e8bd8030 	ldmia	sp!, {r4, r5, pc}

0001092c <main>:


/* ---- Main function ---- */
int main(void)
{
   1092c:	e52de004 	str	lr, [sp, #-4]!
	int temp;

	// timer init
	// STME0_CNT  = 0;
	// STME0_VAL  = 50000000; // threshold value for 1s ticks
	// STME0_CONF = (1<<2) | (1<<1) | (1<<0); // interrupt en, auto reset, timer enable
	// VICVectAddr0 = (unsigned long)timer0_isr;
	// VICVectCntl0 = (1<<5) | 0; // enable and channel select = 0 (timer0)
	// VICIntEnable = (1<<0); // enable channel 0 (timer0)
	// io_enable_xint(); // enable IRQ

	// Intro
	uart0_printf("\r\n\r\nSTORM SoC Basic Configuration\r\n");
   10930:	e59f0030 	ldr	r0, [pc, #48]	; 10968 <.text+0x968>
   10934:	ebffffce 	bl	10874 <uart0_printf>
	uart0_printf("Demo program\r\n\r\n");
   10938:	e59f002c 	ldr	r0, [pc, #44]	; 1096c <.text+0x96c>
   1093c:	ebffffcc 	bl	10874 <uart0_printf>

	uart0_printf("Press any key!\r\n");
   10940:	e59f0028 	ldr	r0, [pc, #40]	; 10970 <.text+0x970>
   10944:	ebffffca 	bl	10874 <uart0_printf>

	// echo received char
	while(1){
		temp = io_uart0_read_byte();
   10948:	ebfffea8 	bl	103f0 <io_uart0_read_byte>
		if (temp != -1)
   1094c:	e3700001 	cmn	r0, #1	; 0x1
   10950:	0afffffc 	beq	10948 <main+0x1c>
			io_uart0_send_byte(temp);
   10954:	ebfffeab 	bl	10408 <io_uart0_send_byte>
   10958:	ebfffea4 	bl	103f0 <io_uart0_read_byte>
   1095c:	e3700001 	cmn	r0, #1	; 0x1
   10960:	1afffffb 	bne	10954 <main+0x28>
   10964:	eafffff7 	b	10948 <main+0x1c>
   10968:	00010998 	muleq	r1, r8, r9
   1096c:	000109bc 	streqh	r0, [r1], -ip
   10970:	000109d0 	ldreqd	r0, [r1], -r0

00010974 <io_enable_xint>:
//		case 14:         asm volatile ("mcr p15,0,%0,c14,c14,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 15:         asm volatile ("mcr p15,0,%0,c15,c15,0" : /* no outputs */ : "r" (_cp_val)); break;
		default:         break;
	}
}
// ******************************************************************************
// read CMSR value
   static inline unsigned long get_cmsr(void)
// ******************************************************************************
{
	unsigned long _cmsr;
	asm volatile (" mrs %0, cpsr" : "=r" (_cmsr) : /* no inputs */  );
   10974:	e10f3000 	mrs	r3, CPSR
	return _cmsr;
}

// ******************************************************************************
// write CMSR value
   static inline void set_cmsr(unsigned long _cmsr)
// ******************************************************************************
{
	asm volatile (" msr cpsr, %0" : /* no outputs */ : "r" (_cmsr)  );
   10978:	e3c330c0 	bic	r3, r3, #192	; 0xc0
   1097c:	e129f003 	msr	CPSR_fc, r3
}

// ******************************************************************************
// Enable all external INTs
   void io_enable_xint(void)
// ******************************************************************************
{
	unsigned long _cmsr = get_cmsr();
	_cmsr = _cmsr & ~(1<<CMSR_FIQ) &~(1<<CMSR_IRQ);
	set_cmsr(_cmsr);
}
   10980:	e12fff1e 	bx	lr

00010984 <io_disable_xint>:
   10984:	e10f3000 	mrs	r3, CPSR
   10988:	e38330c0 	orr	r3, r3, #192	; 0xc0
   1098c:	e129f003 	msr	CPSR_fc, r3

// ******************************************************************************
// Disable all global IBTs
   void io_disable_xint(void)
// ******************************************************************************
{
	unsigned long _cmsr = get_cmsr();
	_cmsr = _cmsr | (1<<CMSR_FIQ) | (1<<CMSR_IRQ);
	set_cmsr(_cmsr);
}
   10990:	e12fff1e 	bx	lr
   10994:	00000000 	andeq	r0, r0, r0
   10998:	0d0a0d0a 	stceq	13, cr0, [sl, #-40]
   1099c:	53544f52 	cmppl	r4, #328	; 0x148
   109a0:	4d20536f 	stcmi	3, cr5, [r0, #-444]!
   109a4:	43204261 	teqmi	r0, #268435462	; 0x10000006
   109a8:	73696320 	cmnvc	r9, #-2147483648	; 0x80000000
   109ac:	436f6e66 	cmnmi	pc, #1632	; 0x660
   109b0:	69677572 	stmvsdb	r7!, {r1, r4, r5, r6, r8, sl, ip, sp, lr}^
   109b4:	6174696f 	cmnvs	r4, pc, ror #18
   109b8:	6e0d0a00 	fmacsvs	s0, s26, s0
   109bc:	44656d6f 	strmibt	r6, [r5], #-3439
   109c0:	2070726f 	rsbcss	r7, r0, pc, ror #4
   109c4:	6772616d 	ldrvsb	r6, [r2, -sp, ror #2]!
   109c8:	0d0a0d0a 	stceq	13, cr0, [sl, #-40]
   109cc:	00000000 	andeq	r0, r0, r0
   109d0:	50726573 	rsbpls	r6, r2, r3, ror r5
   109d4:	7320616e 	teqvc	r0, #-2147483621	; 0x8000001b
   109d8:	79206b65 	stmvcdb	r0!, {r0, r2, r5, r6, r8, r9, fp, sp, lr}
   109dc:	79210d0a 	stmvcdb	r1!, {r1, r3, r8, sl, fp}
   109e0:	00000000 	andeq	r0, r0, r0
