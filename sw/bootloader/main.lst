   1              		.file	"main.c"
   9              	.Ltext0:
  10              		.align	2
  11              		.global	io_read_gpio0_pin
  13              	io_read_gpio0_pin:
  14              	.LFB2:
  15              		.file 1 "../lib/io_driver.c"
   1:../lib/io_driver.c **** #include "io_driver.h"
   2:../lib/io_driver.c **** #include "storm_core.h"
   3:../lib/io_driver.c **** #include "storm_soc_basic.h"
   4:../lib/io_driver.c **** 
   5:../lib/io_driver.c **** // ################################################################################################
   6:../lib/io_driver.c **** // General Purpose IO (GENERAL_PURPOSE_CONTROLLER_0)
   7:../lib/io_driver.c **** // ################################################################################################
   8:../lib/io_driver.c **** 
   9:../lib/io_driver.c **** // ******************************************************************************
  10:../lib/io_driver.c **** // Read general purpose IO pin
  11:../lib/io_driver.c ****    unsigned long io_read_gpio0_pin(unsigned char pin)
  12:../lib/io_driver.c **** // ******************************************************************************
  13:../lib/io_driver.c **** {
  16              	 args = 0, pretend = 0, frame = 0
  17              		@ frame_needed = 0, uses_anonymous_args = 0
  18              		@ link register save eliminated.
  19              	.LVL0:
  20              		.loc 1 17 0
  14:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
  15:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
  16:../lib/io_driver.c **** 
  17:../lib/io_driver.c **** 		unsigned long temp = GPIO0_IN & (1<<pin);
  21              	r3, #61440
  22 0000 E3E03A0F 		ldr	r1, [r3, #-4091]
  23 0004 E5131FFB 		.loc 1 13 0
  24              		and	r2, r0, #255
  25 0008 E20020FF 		.loc 1 21 0
  18:../lib/io_driver.c **** 	
  19:../lib/io_driver.c **** //	set_cmsr(_cmsr);
  20:../lib/io_driver.c **** 	return temp;
  21:../lib/io_driver.c **** }
  26              	r0, #1
  27 000c E3A00001 	.LVL1:
  28              		and	r0, r1, r0, asl r2
  29 0010 E0010210 		.loc 1 13 0
  30              		@ lr needed for prologue
  31              		.loc 1 21 0
  32              		mov	pc, lr
  33 0014 E1A0F00E 	.LFE2:
  35              		.align	2
  36              		.global	io_read_gpio0_port
  38              	io_read_gpio0_port:
  39              	.LFB3:
  40              		.loc 1 27 0
  22:../lib/io_driver.c **** 
  23:../lib/io_driver.c **** // ******************************************************************************
  24:../lib/io_driver.c **** // Read general purpose IO port
  25:../lib/io_driver.c ****    unsigned long io_read_gpio0_port(void)
  26:../lib/io_driver.c **** // ******************************************************************************
  27:../lib/io_driver.c **** {
  41              	etend = 0, frame = 0
  42              		@ frame_needed = 0, uses_anonymous_args = 0
  43              		@ link register save eliminated.
  44              		.loc 1 31 0
  28:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
  29:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
  30:../lib/io_driver.c **** 
  31:../lib/io_driver.c **** 		unsigned long temp = GPIO0_IN;
  45              		r3, #61440
  46 0018 E3E03A0F 		ldr	r0, [r3, #-4091]
  47 001c E5130FFB 	.LVL2:
  48              		.loc 1 27 0
  49              		@ lr needed for prologue
  50              	.LVL3:
  51              		.loc 1 35 0
  32:../lib/io_driver.c **** 
  33:../lib/io_driver.c **** //	set_cmsr(_cmsr);
  34:../lib/io_driver.c **** 	return temp;
  35:../lib/io_driver.c **** }
  52              	, lr
  53 0020 E1A0F00E 	.LFE3:
  55              		.align	2
  56              		.global	io_set_gpio0_pin
  58              	io_set_gpio0_pin:
  59              	.LFB4:
  60              		.loc 1 41 0
  36:../lib/io_driver.c **** 
  37:../lib/io_driver.c **** // ******************************************************************************
  38:../lib/io_driver.c **** // Set general purpose IO port
  39:../lib/io_driver.c ****    void io_set_gpio0_pin(unsigned char pin)
  40:../lib/io_driver.c **** // ******************************************************************************
  41:../lib/io_driver.c **** {
  61              	 0, pretend = 0, frame = 0
  62              		@ frame_needed = 0, uses_anonymous_args = 0
  63              		@ link register save eliminated.
  64              	.LVL4:
  65              		.loc 1 45 0
  42:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
  43:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
  44:../lib/io_driver.c **** 
  45:../lib/io_driver.c **** 		GPIO0_OUT = GPIO0_OUT | (1<<pin);
  66              	r1, #61440
  67 0024 E3E01A0F 		ldr	r3, [r1, #-4095]
  68 0028 E5113FFF 		.loc 1 41 0
  69              		and	r0, r0, #255
  70 002c E20000FF 		.loc 1 45 0
  71              		mov	r2, #1
  72 0030 E3A02001 		orr	r3, r3, r2, asl r0
  73 0034 E1833012 		.loc 1 41 0
  74              		@ lr needed for prologue
  75              		.loc 1 45 0
  76              		str	r3, [r1, #-4095]
  77 0038 E5013FFF 		.loc 1 48 0
  46:../lib/io_driver.c **** 
  47:../lib/io_driver.c **** //	set_cmsr(_cmsr);
  48:../lib/io_driver.c **** }
  78              	.LFE4:
  80              		.align	2
  81              		.global	io_clr_gpio0_pin
  83              	io_clr_gpio0_pin:
  84              	.LFB5:
  85              		.loc 1 54 0
  86              		@ args = 0, pretend = 0, frame = 0
  49:../lib/io_driver.c **** 
  50:../lib/io_driver.c **** // ******************************************************************************
  51:../lib/io_driver.c **** // Clear general purpose IO port
  52:../lib/io_driver.c ****    void io_clr_gpio0_pin(unsigned char pin)
  53:../lib/io_driver.c **** // ******************************************************************************
  54:../lib/io_driver.c **** {
  87              	needed = 0, uses_anonymous_args = 0
  88              		@ link register save eliminated.
  89              	.LVL5:
  90              		and	r0, r0, #255
  91              		.loc 1 58 0
  92 0040 E20000FF 		mov	r2, #1
  55:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
  56:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
  57:../lib/io_driver.c **** 
  58:../lib/io_driver.c **** 		GPIO0_OUT = GPIO0_OUT & ~(1<<pin);
  93              	2, r2, asl r0
  94 0044 E3A02001 		mvn	r1, #61440
  95 0048 E1A02012 		ldr	r3, [r1, #-4095]
  96 004c E3E01A0F 		mvn	r2, r2
  97 0050 E5113FFF 		and	r3, r3, r2
  98 0054 E1E02002 		.loc 1 54 0
  99 0058 E0033002 		@ lr needed for prologue
 100              		.loc 1 58 0
 101              		str	r3, [r1, #-4095]
 102              		.loc 1 61 0
 103 005c E5013FFF 		mov	pc, lr
  59:../lib/io_driver.c **** 
  60:../lib/io_driver.c **** //	set_cmsr(_cmsr);
  61:../lib/io_driver.c **** }
 104              	ze	io_clr_gpio0_pin, .-io_clr_gpio0_pin
 105 0060 E1A0F00E 		.align	2
 106              		.global	io_toggle_gpio0_pin
 108              	io_toggle_gpio0_pin:
 109              	.LFB6:
 110              		.loc 1 66 0
 111              		@ args = 0, pretend = 0, frame = 0
 112              		@ frame_needed = 0, uses_anonymous_args = 0
  62:../lib/io_driver.c **** // ******************************************************************************
  63:../lib/io_driver.c **** // Set general purpose IO port
  64:../lib/io_driver.c ****    void io_toggle_gpio0_pin(unsigned char pin)
  65:../lib/io_driver.c **** // ******************************************************************************
  66:../lib/io_driver.c **** {
 113              	egister save eliminated.
 114              	.LVL6:
 115              		.loc 1 70 0
 116              		mvn	r1, #61440
 117              		ldr	r3, [r1, #-4095]
  67:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
  68:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
  69:../lib/io_driver.c **** 
  70:../lib/io_driver.c **** 		GPIO0_OUT = GPIO0_OUT ^ (1<<pin);
 118              	 1 66 0
 119 0064 E3E01A0F 		and	r0, r0, #255
 120 0068 E5113FFF 		.loc 1 70 0
 121              		mov	r2, #1
 122 006c E20000FF 		eor	r3, r3, r2, asl r0
 123              		.loc 1 66 0
 124 0070 E3A02001 		@ lr needed for prologue
 125 0074 E0233012 		.loc 1 70 0
 126              		str	r3, [r1, #-4095]
 127              		.loc 1 73 0
 128              		mov	pc, lr
 129 0078 E5013FFF 	.LFE6:
  71:../lib/io_driver.c **** 
  72:../lib/io_driver.c **** //	set_cmsr(_cmsr);
  73:../lib/io_driver.c **** }
 130              	ggle_gpio0_pin, .-io_toggle_gpio0_pin
 131 007c E1A0F00E 		.align	2
 132              		.global	io_set_gpio0_port
 134              	io_set_gpio0_port:
 135              	.LFB7:
 136              		.loc 1 79 0
 137              		@ args = 0, pretend = 0, frame = 0
 138              		@ frame_needed = 0, uses_anonymous_args = 0
  74:../lib/io_driver.c **** 
  75:../lib/io_driver.c **** // ******************************************************************************
  76:../lib/io_driver.c **** // Clear general purpose IO port
  77:../lib/io_driver.c ****    void io_set_gpio0_port(unsigned long value)
  78:../lib/io_driver.c **** // ******************************************************************************
  79:../lib/io_driver.c **** {
 139              	egister save eliminated.
 140              	.LVL7:
 141              		.loc 1 83 0
 142              		mvn	r3, #61440
 143              		.loc 1 79 0
  80:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
  81:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
  82:../lib/io_driver.c **** 
  83:../lib/io_driver.c **** 		GPIO0_OUT = value;
 144              	 needed for prologue
 145 0080 E3E03A0F 		.loc 1 83 0
 146              		str	r0, [r3, #-4095]
 147              		.loc 1 86 0
 148              		mov	pc, lr
 149 0084 E5030FFF 	.LFE7:
  84:../lib/io_driver.c **** 
  85:../lib/io_driver.c **** //	set_cmsr(_cmsr);
  86:../lib/io_driver.c **** }
 150              		io_set_gpio0_port, .-io_set_gpio0_port
 151 0088 E1A0F00E 		.align	2
 152              		.global	io_set_pwm
 154              	io_set_pwm:
 155              	.LFB8:
 156              		.loc 1 98 0
 157              		@ args = 0, pretend = 0, frame = 0
 158              		@ frame_needed = 0, uses_anonymous_args = 0
  87:../lib/io_driver.c **** 
  88:../lib/io_driver.c **** 
  89:../lib/io_driver.c **** 
  90:../lib/io_driver.c **** // ################################################################################################
  91:../lib/io_driver.c **** // Pulse-Width-Modulation Controller
  92:../lib/io_driver.c **** // ################################################################################################
  93:../lib/io_driver.c **** 
  94:../lib/io_driver.c **** // ******************************************************************************
  95:../lib/io_driver.c **** // Set pwm value
  96:../lib/io_driver.c ****    void io_set_pwm(unsigned char port, unsigned char data)
  97:../lib/io_driver.c **** // ******************************************************************************
  98:../lib/io_driver.c **** {
 159              	nd	r0, r0, #255
 160              		.loc 1 105 0
 161              		cmp	r0, #7
 162              		.loc 1 98 0
 163 008c E20000FF 		stmfd	sp!, {r4, lr}
  99:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 100:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 101:../lib/io_driver.c **** 
 102:../lib/io_driver.c **** 	unsigned long temp = 0;
 103:../lib/io_driver.c **** 
 104:../lib/io_driver.c **** 	// value adjustment
 105:../lib/io_driver.c **** 	if(port > 7)
 164              	0:
 165 0090 E3500007 		.loc 1 105 0
 166              		mov	ip, #0
 167 0094 E92D4010 		mvn	lr, #255
 168              		.loc 1 98 0
 169              		and	r1, r1, #255
 170 0098 E3A0C000 		.loc 1 105 0
 171 009c E3E0E0FF 		bhi	.L16
 172              		.loc 1 117 0
 173 00a0 E20110FF 		sub	r3, r0, #4
 174              		and	r3, r3, #255
 175 00a4 8A000011 		.loc 1 108 0
 106:../lib/io_driver.c **** 		port = 0;
 107:../lib/io_driver.c **** 
 108:../lib/io_driver.c **** 	if(port < 4){
 109:../lib/io_driver.c **** 		temp = PWM0_CONF0; // get working copy
 110:../lib/io_driver.c **** 		temp = temp & ~(0xFF << (port*8)); // clear old value
 111:../lib/io_driver.c **** 		temp = temp | (unsigned long)(data << (port*8)); // insert new value
 112:../lib/io_driver.c **** 		PWM0_CONF0 = temp;
 113:../lib/io_driver.c **** 	}
 114:../lib/io_driver.c **** 	else{
 115:../lib/io_driver.c **** 		port = port-4;
 116:../lib/io_driver.c **** 		temp = PWM0_CONF1; // get working copy
 117:../lib/io_driver.c **** 		temp = temp & ~(0xFF << (port*8)); // clear old value
 176              		.loc 1 117 0
 177 00a8 E2403004 		mov	lr, r3, asl #3
 178 00ac E20330FF 		.loc 1 116 0
 179              		mvn	r4, #61440
 180 00b0 E3500003 		.loc 1 108 0
 181              		mov	ip, r0, asl #3
 182 00b4 E1A0E183 		bls	.L22
 183              		.loc 1 117 0
 184 00b8 E3E04A0F 		mov	r3, #255
 185              		mov	r3, r3, asl lr
 186 00bc E1A0C180 		.loc 1 116 0
 187 00c0 9A000007 		ldr	r2, [r4, #-3979]
 188              	.LVL9:
 189 00c4 E3A030FF 		.loc 1 117 0
 190 00c8 E1A03E13 		mvn	r3, r3
 191              		and	r2, r2, r3
 192 00cc E5142F8B 	.LVL10:
 193              		.loc 1 118 0
 194              		orr	r2, r2, r1, asl lr
 195 00d0 E1E03003 	.LVL11:
 196 00d4 E0022003 		.loc 1 119 0
 197              		str	r2, [r4, #-3979]
 118:../lib/io_driver.c **** 		temp = temp | (unsigned long)(data << (port*8)); // insert new value
 198              	LVL12:
 199 00d8 E1822E11 	.L22:
 200              		.loc 1 108 0
 119:../lib/io_driver.c **** 		PWM0_CONF1 = temp;
 201              	v	r3, #255
 202 00dc E5042F8B 		mov	r3, r3, asl ip
 203 00e0 E8BD8010 		mvn	lr, r3
 204              	.L16:
 205              		.loc 1 109 0
 206              		mvn	r2, #61440
 207 00e4 E3A030FF 		ldr	r3, [r2, #-3983]
 208 00e8 E1A03C13 	.LVL13:
 209 00ec E1E0E003 		.loc 1 110 0
 210              		and	r3, r3, lr
 211              	.LVL14:
 212 00f0 E3E02A0F 		.loc 1 111 0
 213 00f4 E5123F8F 		orr	r3, r3, r1, asl ip
 214              	.LVL15:
 215              		.loc 1 112 0
 216 00f8 E003300E 		str	r3, [r2, #-3983]
 217              		ldmfd	sp!, {r4, pc}
 218              	.LFE8:
 220              		.align	2
 221              		.global	io_get_pwm
 223 0104 E8BD8010 	io_get_pwm:
 224              	.LFB9:
 225              		.loc 1 128 0
 226              		@ args = 0, pretend = 0, frame = 0
 227              		@ frame_needed = 0, uses_anonymous_args = 0
 228              		@ link register save eliminated.
 229              	.LVL16:
 230              		and	r0, r0, #255
 120:../lib/io_driver.c **** 	}
 121:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 122:../lib/io_driver.c **** }
 123:../lib/io_driver.c **** 
 124:../lib/io_driver.c **** // ******************************************************************************
 125:../lib/io_driver.c **** // Set pwm value
 126:../lib/io_driver.c ****    unsigned char io_get_pwm(unsigned char port)
 127:../lib/io_driver.c **** // ******************************************************************************
 128:../lib/io_driver.c **** {
 231              	c 1 128 0
 232              		@ lr needed for prologue
 233              		.loc 1 135 0
 234              		mov	r2, #0
 235              		bhi	.L26
 236 0108 E20000FF 		.loc 1 142 0
 129:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 130:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 131:../lib/io_driver.c **** 
 132:../lib/io_driver.c **** 	unsigned long temp = 0;
 133:../lib/io_driver.c **** 
 134:../lib/io_driver.c **** 	// value adjustment
 135:../lib/io_driver.c **** 	if(port > 7)
 237              	3, r0, #4
 238 010c E3500007 		.loc 1 138 0
 239              		cmp	r0, #3
 240              		.loc 1 142 0
 241              		and	r2, r3, #255
 242 0110 E3A02000 		.loc 1 138 0
 243 0114 8A00000A 		bls	.L31
 136:../lib/io_driver.c **** 		port = 0;
 137:../lib/io_driver.c **** 
 138:../lib/io_driver.c **** 	if(port < 4)
 139:../lib/io_driver.c **** 		temp = PWM0_CONF0; // get config register
 140:../lib/io_driver.c **** 	else{
 141:../lib/io_driver.c **** 		port = port-4;
 142:../lib/io_driver.c **** 		temp = PWM0_CONF1; // get config register
 244              	 142 0
 245 0118 E2403004 		mvn	r3, #61440
 246              		ldr	r0, [r3, #-3979]
 247 011c E3500003 	.LVL17:
 248              		mov	r2, r2, asl #3
 249 0120 E20320FF 		mov	r0, r0, lsr r2
 250              	.LVL18:
 251 0124 9A000005 		and	r0, r0, #255
 252              		.loc 1 149 0
 253 0128 E3E03A0F 		mov	pc, lr
 254 012c E5130F8B 	.LVL19:
 255              	.L31:
 256 0130 E1A02182 		.loc 1 138 0
 257 0134 E1A00230 		mov	r2, r0, asl #3
 258              	.L26:
 259 0138 E20000FF 		.loc 1 139 0
 143:../lib/io_driver.c **** 	}
 144:../lib/io_driver.c **** 
 145:../lib/io_driver.c **** 	temp = temp >> (port*8); // only keep designated byte
 146:../lib/io_driver.c **** 
 147:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 148:../lib/io_driver.c **** 	return (unsigned char)temp;
 149:../lib/io_driver.c **** }
 260              		ldr	r0, [r3, #-3983]
 261 013c E1A0F00E 	.LVL20:
 262              		.loc 1 142 0
 263              		mov	r0, r0, lsr r2
 264              	.LVL21:
 265 0140 E1A02180 		and	r0, r0, #255
 266              		.loc 1 149 0
 267              		mov	pc, lr
 268 0144 E3E03A0F 	.LFE9:
 270              		.align	2
 271              		.global	io_uart0_read_byte
 273              	io_uart0_read_byte:
 274 0150 E20000FF 	.LFB10:
 275              		.loc 1 161 0
 276 0154 E1A0F00E 		@ args = 0, pretend = 0, frame = 0
 277              		@ frame_needed = 0, uses_anonymous_args = 0
 278              		@ link register save eliminated.
 279              		.loc 1 166 0
 280              		mvn	r2, #61440
 281              		ldr	r3, [r2, #-3835]
 282              		tst	r3, #2
 283              		mvn	r0, #0
 150:../lib/io_driver.c **** 
 151:../lib/io_driver.c **** 
 152:../lib/io_driver.c **** 
 153:../lib/io_driver.c **** // ################################################################################################
 154:../lib/io_driver.c **** // General Purpose UART "miniUART" (UART_0)
 155:../lib/io_driver.c **** // ################################################################################################
 156:../lib/io_driver.c **** 
 157:../lib/io_driver.c **** // ******************************************************************************
 158:../lib/io_driver.c **** // Read one byte via UART 0
 159:../lib/io_driver.c ****    int io_uart0_read_byte(void)
 160:../lib/io_driver.c **** // ******************************************************************************
 161:../lib/io_driver.c **** {
 284              	drne	r0, [r2, #-3839]
 285              		.loc 1 161 0
 286              		@ lr needed for prologue
 287              	.LVL23:
 162:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 163:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 164:../lib/io_driver.c **** 
 165:../lib/io_driver.c **** 	int temp;
 166:../lib/io_driver.c **** 	if ((UART0_SREG & (1<<CUART_RXD)) != 0) // byte available?
 288              	c 1 173 0
 289 0158 E3E02A0F 		mov	pc, lr
 290 015c E5123EFB 	.LFE10:
 292 0164 E3E00000 		.align	2
 293              		.global	io_uart0_send_byte
 167:../lib/io_driver.c **** 		temp = UART0_DATA;
 294              		io_uart0_send_byte, %function
 295 0168 15120EFF 	io_uart0_send_byte:
 296              	.LFB11:
 297              		.loc 1 179 0
 298              		@ args = 0, pretend = 0, frame = 0
 168:../lib/io_driver.c **** 	else
 169:../lib/io_driver.c **** 		temp = -1;
 170:../lib/io_driver.c **** 
 171:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 172:../lib/io_driver.c **** 	return temp;
 173:../lib/io_driver.c **** }
 299              	ame_needed = 0, uses_anonymous_args = 0
 300 016c E1A0F00E 		@ link register save eliminated.
 301              	.LVL24:
 302              		@ lr needed for prologue
 303              		mvn	r2, #61440
 304              	.L39:
 305              		.loc 1 183 0
 306              		ldr	r3, [r2, #-3835]
 307              		tst	r3, #1
 174:../lib/io_driver.c **** 
 175:../lib/io_driver.c **** // ******************************************************************************
 176:../lib/io_driver.c **** // Write one byte via UART 0
 177:../lib/io_driver.c ****    int io_uart0_send_byte(int ch)
 178:../lib/io_driver.c **** // ******************************************************************************
 179:../lib/io_driver.c **** {
 308              	
 309              		.loc 1 184 0
 310              		and	r3, r0, #255
 311              		str	r3, [r2, #-3839]
 312              	.LVL25:
 313              		.loc 1 188 0
 314 0170 E3E02A0F 		mov	pc, lr
 315              	.LFE11:
 180:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 181:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 182:../lib/io_driver.c **** 
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 316              	io_uart0_send_byte, .-io_uart0_send_byte
 317 0174 E5123EFB 		.align	2
 318 0178 E3130001 		.global	io_spi0_config
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 320              	pi0_config:
 321 0180 E20030FF 	.LFB12:
 322 0184 E5023EFF 		.loc 1 200 0
 323              		@ args = 0, pretend = 0, frame = 0
 185:../lib/io_driver.c **** 
 186:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 187:../lib/io_driver.c **** 	return ch;
 188:../lib/io_driver.c **** }
 324              	rame_needed = 0, uses_anonymous_args = 0
 325 0188 E1A0F00E 		@ link register save eliminated.
 326              	.LVL26:
 327              		and	r0, r0, #255
 328              		.loc 1 206 0
 329              		cmp	r0, #1
 330              		.loc 1 209 0
 331              		orr	r2, r1, #1024
 332              		.loc 1 207 0
 189:../lib/io_driver.c **** 
 190:../lib/io_driver.c **** 
 191:../lib/io_driver.c **** 
 192:../lib/io_driver.c **** // ################################################################################################
 193:../lib/io_driver.c **** // Serial Peripherial Interface (SPI_CONTROLLER_0)
 194:../lib/io_driver.c **** // ################################################################################################
 195:../lib/io_driver.c **** 
 196:../lib/io_driver.c **** // ******************************************************************************
 197:../lib/io_driver.c **** // Configure SPI 0
 198:../lib/io_driver.c ****    void io_spi0_config(unsigned char auto_cs, unsigned long data_size)
 199:../lib/io_driver.c **** // ******************************************************************************
 200:../lib/io_driver.c **** {
 333              	, #61440
 334              		orr	r1, r1, #9216
 335              	.LVL27:
 336              		.loc 1 209 0
 337              		mvnne	r3, #61440
 338 018c E20000FF 		.loc 1 200 0
 201:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 202:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 203:../lib/io_driver.c **** 	// devices update their serial input on a rising edge of sclk,
 204:../lib/io_driver.c **** 	// so we need to update the mosi output of the core before
 205:../lib/io_driver.c **** 	// -> at the falling edge of sclk = set SPI_TX_NEG
 206:../lib/io_driver.c **** 	if(auto_cs == 1)
 339              	needed for prologue
 340 0190 E3500001 		.loc 1 207 0
 207:../lib/io_driver.c **** 		SPI0_CONF = (1<<SPI_ACS) | (1<<SPI_TX_NEG) | data_size; // auto assert cs
 208:../lib/io_driver.c **** 	else
 209:../lib/io_driver.c **** 		SPI0_CONF = (0<<SPI_ACS) | (1<<SPI_TX_NEG) | data_size; // manual assert cs
 341              	treq	r1, [r3, #-3327]
 342 0194 E3812B01 		.loc 1 209 0
 343              		strne	r2, [r3, #-3327]
 344 0198 03E03A0F 		mov	pc, lr
 345 019c E3811B09 	.LFE12:
 347              		.align	2
 348 01a0 13E03A0F 		.global	io_spi0_speed
 350              	io_spi0_speed:
 351              	.LFB13:
 352 01a4 05031CFF 		.loc 1 217 0
 353              		@ args = 0, pretend = 0, frame = 0
 354 01a8 15032CFF 		@ frame_needed = 0, uses_anonymous_args = 0
 355 01ac E1A0F00E 		@ link register save eliminated.
 356              	.LVL28:
 357              		.loc 1 221 0
 358              		mvn	r3, #61440
 359              		.loc 1 217 0
 360              		@ lr needed for prologue
 361              		.loc 1 221 0
 362              		str	r0, [r3, #-3323]
 210:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 211:../lib/io_driver.c **** }
 212:../lib/io_driver.c **** 
 213:../lib/io_driver.c **** // ******************************************************************************
 214:../lib/io_driver.c **** // Configure SPI 0 CLK frequency -> (sys_clk/(spi_clk*2))-1
 215:../lib/io_driver.c ****    void io_spi0_speed(unsigned long clk_divider)
 216:../lib/io_driver.c **** // ******************************************************************************
 217:../lib/io_driver.c **** {
 363              	 lr
 364              	.LFE13:
 366              		.align	2
 367              		.global	io_spi0_trans
 218:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 219:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 220:../lib/io_driver.c **** 
 221:../lib/io_driver.c **** 		SPI0_PRSC = clk_divider; // (sys_clk/(spi_clk*2))-1;
 368              	e	io_spi0_trans, %function
 369 01b0 E3E03A0F 	io_spi0_trans:
 370              	.LFB14:
 371              		.loc 1 230 0
 372              		@ args = 0, pretend = 0, frame = 0
 373 01b4 E5030CFB 		@ frame_needed = 0, uses_anonymous_args = 0
 222:../lib/io_driver.c **** 
 223:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 224:../lib/io_driver.c **** }
 374              	k register save eliminated.
 375 01b8 E1A0F00E 	.LVL29:
 376              		@ lr needed for prologue
 377              		mvn	r2, #61440
 378              	.L53:
 379              		.loc 1 235 0
 380              		ldr	r3, [r2, #-3327]
 381              		tst	r3, #256
 382              		bne	.L53
 225:../lib/io_driver.c **** 
 226:../lib/io_driver.c **** // ******************************************************************************
 227:../lib/io_driver.c **** // Sends/receives max 32 bits via SPI, CS and config must be done outside
 228:../lib/io_driver.c ****    unsigned long io_spi0_trans(unsigned long data)
 229:../lib/io_driver.c **** // ******************************************************************************
 230:../lib/io_driver.c **** {
 383              	36 0
 384              		str	r0, [r2, #-3311]
 385              		.loc 1 237 0
 386              		ldr	r3, [r2, #-3327]
 387              		orr	r3, r3, #256
 388              		str	r3, [r2, #-3327]
 389 01bc E3E02A0F 		mvn	r2, #61440
 390              	.L55:
 231:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 232:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 233:../lib/io_driver.c **** 
 234:../lib/io_driver.c **** 	// spi transmission
 235:../lib/io_driver.c **** 	while((SPI0_CONF & (1<<SPI_BUSY)) != 0); // wait for prev tx to finish
 391              	238 0
 392 01c0 E5123CFF 		ldr	r3, [r2, #-3327]
 393 01c4 E3130C01 		tst	r3, #256
 394 01c8 1AFFFFFC 		bne	.L55
 236:../lib/io_driver.c **** 	SPI0_DAT0 = data;
 395              	c 1 239 0
 396 01cc E5020CEF 		ldr	r0, [r2, #-3311]
 237:../lib/io_driver.c **** 	SPI0_CONF = SPI0_CONF | (1<<SPI_BUSY); // start transmitter
 397              	VL30:
 398 01d0 E5123CFF 	.LVL31:
 399 01d4 E3833C01 		.loc 1 243 0
 400 01d8 E5023CFF 		mov	pc, lr
 401 01dc E3E02A0F 	.LFE14:
 238:../lib/io_driver.c **** 	while((SPI0_CONF & (1<<SPI_BUSY)) != 0); // wait for rx to finish
 403              	n	2
 404 01e0 E5123CFF 		.global	io_spi0_enable
 406 01e8 1AFFFFFC 	io_spi0_enable:
 239:../lib/io_driver.c **** 	unsigned long temp = SPI0_DAT0;
 407              	15:
 408 01ec E5120CEF 		.loc 1 249 0
 409              		@ args = 0, pretend = 0, frame = 0
 410              		@ frame_needed = 0, uses_anonymous_args = 0
 240:../lib/io_driver.c **** 
 241:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 242:../lib/io_driver.c **** 	return temp;
 243:../lib/io_driver.c **** }
 411              	ink register save eliminated.
 412 01f0 E1A0F00E 	.LVL32:
 413              		.loc 1 253 0
 414              		mvn	r1, #61440
 415              		ldr	r3, [r1, #-3319]
 416              		.loc 1 249 0
 417              		and	r0, r0, #255
 418              		.loc 1 253 0
 419              		mov	r2, #1
 244:../lib/io_driver.c **** 
 245:../lib/io_driver.c **** // ******************************************************************************
 246:../lib/io_driver.c **** // Controls the CS of SPI0, enables a connected CS (turns it LOW)
 247:../lib/io_driver.c ****    void io_spi0_enable(unsigned char device)
 248:../lib/io_driver.c **** // ******************************************************************************
 249:../lib/io_driver.c **** {
 420              	r3, r2, asl r0
 421              		.loc 1 249 0
 422              		@ lr needed for prologue
 423              		.loc 1 253 0
 424              		str	r3, [r1, #-3319]
 250:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 251:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 252:../lib/io_driver.c **** 
 253:../lib/io_driver.c **** 		SPI0_SCSR = SPI0_SCSR | (1<<device);
 425              	 1 256 0
 426 01f4 E3E01A0F 		mov	pc, lr
 427 01f8 E5113CF7 	.LFE15:
 429 01fc E20000FF 		.align	2
 430              		.global	io_spi0_disable
 432 0204 E1833012 	io_spi0_disable:
 433              	.LFB16:
 434              		.loc 1 262 0
 435              		@ args = 0, pretend = 0, frame = 0
 436 0208 E5013CF7 		@ frame_needed = 0, uses_anonymous_args = 0
 254:../lib/io_driver.c **** 
 255:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 256:../lib/io_driver.c **** }
 437              	ster save eliminated.
 438 020c E1A0F00E 	.LVL33:
 439              		and	r0, r0, #255
 440              		.loc 1 266 0
 441              		mov	r2, #1
 442              		mov	r2, r2, asl r0
 443              		mvn	r1, #61440
 444              		ldr	r3, [r1, #-3319]
 445              		mvn	r2, r2
 257:../lib/io_driver.c **** 
 258:../lib/io_driver.c **** // ******************************************************************************
 259:../lib/io_driver.c **** // Controls the CS of SPI0, disables a connected CS (turns it HIGH)
 260:../lib/io_driver.c ****    void io_spi0_disable(unsigned char device)
 261:../lib/io_driver.c **** // ******************************************************************************
 262:../lib/io_driver.c **** {
 446              	r3, r2
 447              		.loc 1 262 0
 448              		@ lr needed for prologue
 449              		.loc 1 266 0
 450              		str	r3, [r1, #-3319]
 451 0210 E20000FF 		.loc 1 269 0
 263:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 264:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 265:../lib/io_driver.c **** 
 266:../lib/io_driver.c **** 		SPI0_SCSR = SPI0_SCSR & ~(1<<device);
 452              	c, lr
 453 0214 E3A02001 	.LFE16:
 455 021c E3E01A0F 		.align	2
 456 0220 E5113CF7 		.global	io_i2c0_speed
 458 0228 E0033002 	io_i2c0_speed:
 459              	.LFB17:
 460              		.loc 1 282 0
 461              		@ args = 0, pretend = 0, frame = 0
 462 022c E5013CF7 		@ frame_needed = 0, uses_anonymous_args = 0
 267:../lib/io_driver.c **** 
 268:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 269:../lib/io_driver.c **** }
 463              	ister save eliminated.
 464 0230 E1A0F00E 	.LVL34:
 465              		.loc 1 285 0
 466              		mvn	r2, #61440
 467              		ldr	r3, [r2, #-3047]
 468              		.loc 1 287 0
 469              		mov	r1, r0, lsr #8
 470              		.loc 1 285 0
 471              		bic	r3, r3, #128
 270:../lib/io_driver.c **** 
 271:../lib/io_driver.c **** 
 272:../lib/io_driver.c **** 
 273:../lib/io_driver.c **** 
 274:../lib/io_driver.c **** // ################################################################################################
 275:../lib/io_driver.c **** // Inter Intergrated Circuit Interface (I²C_CONTROLLER_0)
 276:../lib/io_driver.c **** // ################################################################################################
 277:../lib/io_driver.c **** 
 278:../lib/io_driver.c **** // ******************************************************************************
 279:../lib/io_driver.c **** // Configure SPI 0 CLK frequency -> (sys_clk/(5*i2c_clock)-1
 280:../lib/io_driver.c ****    void io_i2c0_speed(unsigned long clk_divider)
 281:../lib/io_driver.c **** // ******************************************************************************
 282:../lib/io_driver.c **** {
 472              	[r2, #-3047]
 473              		.loc 1 286 0
 474              		str	r0, [r2, #-3055]
 475              		.loc 1 287 0
 476              		str	r1, [r2, #-3051]
 283:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 284:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 285:../lib/io_driver.c **** 		I2C0_CTRL = I2C0_CTRL & ~(1<<I2C_EN); // disable i2c core
 477              	 1 288 0
 478 0234 E3E02A0F 		ldr	r3, [r2, #-3047]
 479 0238 E5123BE7 		orr	r3, r3, #128
 286:../lib/io_driver.c **** 		I2C0_PRLO = clk_divider;
 287:../lib/io_driver.c **** 		I2C0_PRHI = clk_divider >> 8;
 480              	oc 1 282 0
 481 023c E1A01420 		@ lr needed for prologue
 482              		.loc 1 288 0
 483 0240 E3C33080 		str	r3, [r2, #-3047]
 484 0244 E5023BE7 		.loc 1 290 0
 485              		mov	pc, lr
 486 0248 E5020BEF 	.LFE17:
 488 024c E5021BEB 		.align	2
 288:../lib/io_driver.c **** 		I2C0_CTRL = I2C0_CTRL | (1<<I2C_EN); // enable i2c core
 489              	io_i2c0_byte_transfer
 491 0254 E3833080 	io_i2c0_byte_transfer:
 492              	.LFB18:
 493              		.loc 1 300 0
 494              		@ args = 4, pretend = 0, frame = 0
 495 0258 E5023BE7 		@ frame_needed = 0, uses_anonymous_args = 0
 289:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 290:../lib/io_driver.c **** }
 496              	
 497 025c E1A0F00E 		stmfd	sp!, {r4, r5, lr}
 498              	.LCFI1:
 499              		.loc 1 306 0
 500              		mov	ip, #144
 501              		.loc 1 305 0
 502              		and	r4, r1, #254
 503              		mvn	lr, #61440
 504              	.LVL36:
 291:../lib/io_driver.c **** 
 292:../lib/io_driver.c **** // ******************************************************************************
 293:../lib/io_driver.c **** // Read/write byte from/to I²C slave, max 2 address bytes
 294:../lib/io_driver.c ****    int io_i2c0_byte_transfer(unsigned char rw,        // 'r' read / 'w' write cycle
 295:../lib/io_driver.c ****                              unsigned char id,        // device ID
 296:../lib/io_driver.c **** 							 unsigned long data_adr,  // data address
 297:../lib/io_driver.c **** 							 unsigned char adr_bytes, // number of adr bytes
 298:../lib/io_driver.c **** 							 unsigned char data)      // data byte
 299:../lib/io_driver.c **** // ******************************************************************************
 300:../lib/io_driver.c **** {
 505              	300 0
 506              		ldrb	r5, [sp, #15]	@ zero_extendqisi2
 507              		and	r0, r0, #255
 508              		.loc 1 305 0
 509 0260 E92D4030 		str	r4, [lr, #-3043]
 510              		.loc 1 300 0
 301:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 302:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 303:../lib/io_driver.c **** 
 304:../lib/io_driver.c **** 	// transfer slave identification address
 305:../lib/io_driver.c **** 	I2C0_DATA = id & 0xFE;                  // device id and write
 306:../lib/io_driver.c **** 	I2C0_CMD = (1<<I2C_STA) | (1<<I2C_WR);  // start condition and write cycle
 511              	1, r1, #255
 512 0264 E3A0C090 		.loc 1 306 0
 513              		str	ip, [lr, #-3071]
 514 0268 E20140FE 		.loc 1 300 0
 515 026c E3E0EA0F 		mov	r4, r2
 516              		and	ip, r3, #255
 517              	.LVL37:
 518 0270 E5DD500F 	.L69:
 519 0274 E20000FF 		.loc 1 307 0
 520              		ldr	r3, [lr, #-3071]
 521 0278 E50E4BE3 		tst	r3, #2
 522              		bne	.L69
 523 027c E20110FF 		.loc 1 308 0
 524              		ldr	r3, [lr, #-3071]
 525 0280 E50ECBFF 		tst	r3, #128
 526              		mvnne	r0, #0
 527 0284 E1A04002 	.LVL38:
 528 0288 E203C0FF 		ldmnefd	sp!, {r4, r5, pc}
 529              	.L80:
 530              		.loc 1 314 0
 307:../lib/io_driver.c **** 	while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
 531              	09
 532 028c E51E3BFF 		.loc 1 315 0
 533 0290 E3130002 		sub	r3, ip, #1
 534 0294 1AFFFFFC 		and	ip, r3, #255
 308:../lib/io_driver.c **** 	if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
 535              	c 1 316 0
 536 0298 E51E3BFF 		cmp	ip, #1
 537 029c E3130080 		.loc 1 317 0
 538 02a0 13E00000 		moveq	r2, r4, lsr #8
 539              		mvneq	r3, #61440
 540 02a4 18BD8030 		.loc 1 319 0
 541              		mvnne	r3, #61440
 309:../lib/io_driver.c **** //		set_cmsr(_cmsr);
 310:../lib/io_driver.c **** 		return -1;
 311:../lib/io_driver.c **** 	}
 312:../lib/io_driver.c **** 
 313:../lib/io_driver.c **** 	// transfer data address
 314:../lib/io_driver.c **** 	while(adr_bytes != 0){
 542              	 317 0
 543 02a8 E35C0000 		streq	r2, [r3, #-3043]
 544 02ac 0A000012 		.loc 1 319 0
 315:../lib/io_driver.c **** 		adr_bytes--;
 545              	rne	r4, [r3, #-3043]
 546 02b0 E24C3001 		.loc 1 320 0
 547 02b4 E203C0FF 		mvn	r2, #61440
 316:../lib/io_driver.c **** 		if(adr_bytes == 1)
 548              	v	r3, #16
 549 02b8 E35C0001 		str	r3, [r2, #-3071]
 317:../lib/io_driver.c **** 			I2C0_DATA = data_adr >> 8;          // high byte
 550              	78:
 551 02bc 01A02424 		.loc 1 321 0
 552 02c0 03E03A0F 		ldr	r3, [r2, #-3071]
 318:../lib/io_driver.c **** 		else
 319:../lib/io_driver.c **** 			I2C0_DATA = data_adr;               // low byte
 553              	t	r3, #2
 554 02c4 13E03A0F 		bne	.L78
 555              		.loc 1 322 0
 556 02c8 05032BE3 		ldr	r3, [r2, #-3071]
 557              		tst	r3, #128
 558 02cc 15034BE3 		beq	.L80
 320:../lib/io_driver.c **** 		I2C0_CMD = (1<<I2C_WR);                 // write cycle
 559              	0, #1
 560 02d0 E3E02A0F 		ldmfd	sp!, {r4, r5, pc}
 561 02d4 E3A03010 	.LVL39:
 562 02d8 E5023BFF 	.L109:
 563              	.LVL40:
 321:../lib/io_driver.c **** 		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
 564              	 1 328 0
 565 02dc E5123BFF 		cmp	r0, #119
 566 02e0 E3130002 		bne	.L83
 567 02e4 1AFFFFFC 		.loc 1 330 0
 322:../lib/io_driver.c **** 		if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
 568              		r3, #61440
 569 02e8 E5123BFF 		.loc 1 331 0
 570 02ec E3130080 		mov	r2, #80
 571 02f0 0AFFFFEC 		.loc 1 330 0
 572 02f4 E3E00001 		str	r5, [r3, #-3043]
 573 02f8 E8BD8030 		.loc 1 331 0
 574              		str	r2, [r3, #-3071]
 575              		mov	r2, r3
 576              	.L85:
 323:../lib/io_driver.c **** //			set_cmsr(_cmsr);
 324:../lib/io_driver.c **** 			return -2;
 325:../lib/io_driver.c **** 		}
 326:../lib/io_driver.c **** 	}
 327:../lib/io_driver.c **** 
 328:../lib/io_driver.c **** 	if(rw == 'w'){
 577              	32 0
 578 02fc E3500077 		ldr	r3, [r2, #-3071]
 579 0300 1A00000C 		tst	r3, #2
 329:../lib/io_driver.c **** 		// write adressed byte
 330:../lib/io_driver.c **** 		I2C0_DATA = data;                       // send data
 580              	e	.L85
 581 0304 E3E03A0F 		.loc 1 333 0
 331:../lib/io_driver.c **** 		I2C0_CMD = (1<<I2C_STO) | (1<<I2C_WR);  // stop condition and write cycle
 582              	dr	r3, [r2, #-3071]
 583 0308 E3A02050 		ands	r0, r3, #128
 584              	.LVL41:
 585 030c E5035BE3 		ldmeqfd	sp!, {r4, r5, pc}
 586              	.L87:
 587 0310 E5032BFF 		.loc 1 355 0
 588 0314 E1A02003 		mvn	r0, #2
 589              		.loc 1 360 0
 332:../lib/io_driver.c **** 		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
 590              	p!, {r4, r5, pc}
 591 0318 E5123BFF 	.LVL42:
 592 031c E3130002 	.L83:
 593 0320 1AFFFFFC 		.loc 1 343 0
 333:../lib/io_driver.c **** 		if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
 594              		r0, #114
 595 0324 E5123BFF 		mvnne	r0, #3
 596 0328 E2130080 	.LVL43:
 597              		ldmnefd	sp!, {r4, r5, pc}
 598 032c 08BD8030 		.loc 1 345 0
 599              		orr	r3, r1, #1
 334:../lib/io_driver.c **** //			set_cmsr(_cmsr);
 335:../lib/io_driver.c **** 			return -3;
 336:../lib/io_driver.c **** 		}
 337:../lib/io_driver.c **** 		else{
 338:../lib/io_driver.c **** //			set_cmsr(_cmsr);
 339:../lib/io_driver.c **** 			return 0;
 340:../lib/io_driver.c **** 		}
 341:../lib/io_driver.c **** 	}
 342:../lib/io_driver.c **** 
 343:../lib/io_driver.c **** 	if(rw == 'r'){
 344:../lib/io_driver.c **** 		// re-send control byte - this time with read-bit
 345:../lib/io_driver.c **** 		I2C0_DATA = id | 0x01;                  // device id and READ
 346:../lib/io_driver.c **** 		I2C0_CMD = (1<<I2C_STA) | (1<<I2C_WR);  // start condition and write cycle
 347:../lib/io_driver.c **** 		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
 348:../lib/io_driver.c **** 		if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
 349:../lib/io_driver.c **** //			set_cmsr(_cmsr);
 350:../lib/io_driver.c **** 			return -3;
 351:../lib/io_driver.c **** 		}
 352:../lib/io_driver.c **** 		// read adressed byte
 353:../lib/io_driver.c **** 		I2C0_CMD = (1<<I2C_STO) | (1<<I2C_RD) | (1<<I2C_ACK);
 354:../lib/io_driver.c **** 		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
 355:../lib/io_driver.c **** 		return I2C0_DATA;
 600              	2, #61440
 601 0330 E3E00002 		.loc 1 346 0
 356:../lib/io_driver.c **** 	}
 357:../lib/io_driver.c **** 
 358:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 359:../lib/io_driver.c **** 	return -4;
 360:../lib/io_driver.c **** }
 602              	ov	r1, #144
 603 0334 E8BD8030 	.LVL44:
 604              		.loc 1 345 0
 605              		str	r3, [r2, #-3043]
 606              		.loc 1 346 0
 607 0338 E3500072 		str	r1, [r2, #-3071]
 608 033c 13E00003 	.L91:
 609              		.loc 1 347 0
 610 0340 18BD8030 		ldr	r3, [r2, #-3071]
 611              		tst	r3, #2
 612 0344 E3813001 		bne	.L91
 613 0348 E3E02A0F 		.loc 1 348 0
 614              		ldr	r3, [r2, #-3071]
 615 034c E3A01090 		tst	r3, #128
 616              		bne	.L87
 617              		.loc 1 353 0
 618 0350 E5023BE3 		mov	r3, #104
 619              		str	r3, [r2, #-3071]
 620 0354 E5021BFF 		mvn	r0, #61440
 621              	.L94:
 622              		.loc 1 354 0
 623 0358 E5123BFF 		ldr	r3, [r0, #-3071]
 624 035c E3130002 		tst	r3, #2
 625 0360 1AFFFFFC 		bne	.L94
 626              		.loc 1 355 0
 627 0364 E5123BFF 		ldr	r0, [r0, #-3043]
 628 0368 E3130080 		ldmfd	sp!, {r4, r5, pc}
 629 036c 1AFFFFEF 	.LFE18:
 631 0370 E3A03068 		.align	2
 632 0374 E5023BFF 		.global	get_syscpreg
 634              	get_syscpreg:
 635              	.LFB19:
 636 037c E5103BFF 		.loc 1 373 0
 637 0380 E3130002 		@ args = 0, pretend = 0, frame = 0
 638 0384 1AFFFFFC 		@ frame_needed = 0, uses_anonymous_args = 0
 639              		@ link register save eliminated.
 640 0388 E5100BE3 	.LVL45:
 641 038c E8BD8030 		and	r0, r0, #255
 642              		@ lr needed for prologue
 643              		.loc 1 375 0
 644              		cmp	r0, #15
 645              		ldrls	pc, [pc, r0, asl #2]
 646              		b	.L111
 647              		.p2align 2
 648              	.L128:
 361:../lib/io_driver.c **** 
 362:../lib/io_driver.c **** 
 363:../lib/io_driver.c **** 
 364:../lib/io_driver.c **** 
 365:../lib/io_driver.c **** // ################################################################################################
 366:../lib/io_driver.c **** // System
 367:../lib/io_driver.c **** // ################################################################################################
 368:../lib/io_driver.c **** 
 369:../lib/io_driver.c **** // ******************************************************************************
 370:../lib/io_driver.c **** // read system coprocessor register x
 371:../lib/io_driver.c ****    unsigned long get_syscpreg(unsigned char index)
 372:../lib/io_driver.c **** // ******************************************************************************
 373:../lib/io_driver.c **** {
 649              	L115
 650              		.word	.L116
 651              		.word	.L117
 652              		.word	.L118
 653              		.word	.L119
 654 0390 E20000FF 		.word	.L120
 655              		.word	.L121
 374:../lib/io_driver.c **** 	unsigned long _cp_val;
 375:../lib/io_driver.c **** 	switch(index){
 656              	.L122
 657 0394 E350000F 		.word	.L123
 658 0398 979FF100 		.word	.L124
 659 039c EA00000F 		.word	.L125
 660              		.word	.L126
 661              		.word	.L127
 662 03a0 00000460 	.L111:
 663 03a4 00000458 		mov	r0, #0
 664 03a8 00000450 	.LVL46:
 665 03ac 00000448 		mov	pc, lr
 666 03b0 00000440 	.LVL47:
 667 03b4 00000438 	.L127:
 668 03b8 00000430 		.loc 1 391 0
 669 03bc 00000428 		mrc p15,0,r0,c15,c15
 670 03c0 00000420 	.LVL48:
 671 03c4 00000418 	.LVL49:
 672 03c8 00000410 		.loc 1 395 0
 673 03cc 00000408 		mov	pc, lr
 674 03d0 00000400 	.LVL50:
 675 03d4 000003F8 	.L126:
 676 03d8 000003F0 		.loc 1 390 0
 677 03dc 000003E8 		mrc p15,0,r0,c14,c14
 678              	.LVL51:
 679 03e0 E3A00000 		mov	pc, lr
 680              	.LVL52:
 681 03e4 E1A0F00E 	.L125:
 682              		.loc 1 389 0
 683              		mrc p15,0,r0,c13,c13
 376:../lib/io_driver.c **** 		case ID_REG_0:   asm volatile ("mrc p15,0,%0, c0, c0" : "=r" (_cp_val) : /* no inputs */  ); brea
 377:../lib/io_driver.c **** 		case ID_REG_1:   asm volatile ("mrc p15,0,%0, c1, c1" : "=r" (_cp_val) : /* no inputs */  ); brea
 378:../lib/io_driver.c **** 		case ID_REG_2:   asm volatile ("mrc p15,0,%0, c2, c2" : "=r" (_cp_val) : /* no inputs */  ); brea
 379:../lib/io_driver.c **** 		case 3:          asm volatile ("mrc p15,0,%0, c3, c3" : "=r" (_cp_val) : /* no inputs */  ); brea
 380:../lib/io_driver.c **** 		case 4:          asm volatile ("mrc p15,0,%0, c4, c4" : "=r" (_cp_val) : /* no inputs */  ); brea
 381:../lib/io_driver.c **** 		case 5:          asm volatile ("mrc p15,0,%0, c5, c5" : "=r" (_cp_val) : /* no inputs */  ); brea
 382:../lib/io_driver.c **** 		case SYS_CTRL_0: asm volatile ("mrc p15,0,%0, c6, c6" : "=r" (_cp_val) : /* no inputs */  ); brea
 383:../lib/io_driver.c **** 		case 7:          asm volatile ("mrc p15,0,%0, c7, c7" : "=r" (_cp_val) : /* no inputs */  ); brea
 384:../lib/io_driver.c **** 		case CSTAT:      asm volatile ("mrc p15,0,%0, c8, c8" : "=r" (_cp_val) : /* no inputs */  ); brea
 385:../lib/io_driver.c **** 		case ADR_FB:     asm volatile ("mrc p15,0,%0, c9, c9" : "=r" (_cp_val) : /* no inputs */  ); brea
 386:../lib/io_driver.c **** 		case 10:         asm volatile ("mrc p15,0,%0,c10,c10" : "=r" (_cp_val) : /* no inputs */  ); brea
 387:../lib/io_driver.c **** 		case LFSR_POLY:  asm volatile ("mrc p15,0,%0,c11,c11" : "=r" (_cp_val) : /* no inputs */  ); brea
 388:../lib/io_driver.c **** 		case LFSR_DATA:  asm volatile ("mrc p15,0,%0,c12,c12" : "=r" (_cp_val) : /* no inputs */  ); brea
 389:../lib/io_driver.c **** 		case SYS_IO:     asm volatile ("mrc p15,0,%0,c13,c13" : "=r" (_cp_val) : /* no inputs */  ); brea
 390:../lib/io_driver.c **** 		case 14:         asm volatile ("mrc p15,0,%0,c14,c14" : "=r" (_cp_val) : /* no inputs */  ); brea
 391:../lib/io_driver.c **** 		case 15:         asm volatile ("mrc p15,0,%0,c15,c15" : "=r" (_cp_val) : /* no inputs */  ); brea
 684              	.L124:
 685 03e8 EE1F0F1F 		.loc 1 388 0
 686              		mrc p15,0,r0,c12,c12
 687              	.LVL55:
 392:../lib/io_driver.c **** 		default:         _cp_val = 0; break;
 393:../lib/io_driver.c **** 	}
 394:../lib/io_driver.c **** 	return _cp_val;
 395:../lib/io_driver.c **** }
 688              		pc, lr
 689 03ec E1A0F00E 	.LVL56:
 690              	.L123:
 691              		.loc 1 387 0
 692              		mrc p15,0,r0,c11,c11
 693 03f0 EE1E0F1E 	.LVL57:
 694              		mov	pc, lr
 695 03f4 E1A0F00E 	.LVL58:
 696              	.L122:
 697              		.loc 1 386 0
 698              		mrc p15,0,r0,c10,c10
 699 03f8 EE1D0F1D 	.LVL59:
 700              		mov	pc, lr
 701 03fc E1A0F00E 	.LVL60:
 702              	.L121:
 703              		.loc 1 385 0
 704              		mrc p15,0,r0, c9, c9
 705 0400 EE1C0F1C 	.LVL61:
 706              		mov	pc, lr
 707 0404 E1A0F00E 	.LVL62:
 708              	.L120:
 709              		.loc 1 384 0
 710              		mrc p15,0,r0, c8, c8
 711 0408 EE1B0F1B 	.LVL63:
 712              		mov	pc, lr
 713 040c E1A0F00E 	.LVL64:
 714              	.L119:
 715              		.loc 1 383 0
 716              		mrc p15,0,r0, c7, c7
 717 0410 EE1A0F1A 	.LVL65:
 718              		mov	pc, lr
 719 0414 E1A0F00E 	.LVL66:
 720              	.L118:
 721              		.loc 1 382 0
 722              		mrc p15,0,r0, c6, c6
 723 0418 EE190F19 	.LVL67:
 724              		mov	pc, lr
 725 041c E1A0F00E 	.LVL68:
 726              	.L117:
 727              		.loc 1 381 0
 728              		mrc p15,0,r0, c5, c5
 729 0420 EE180F18 	.LVL69:
 730              		mov	pc, lr
 731 0424 E1A0F00E 	.LVL70:
 732              	.L116:
 733              		.loc 1 380 0
 734              		mrc p15,0,r0, c4, c4
 735 0428 EE170F17 	.LVL71:
 736              		mov	pc, lr
 737 042c E1A0F00E 	.LVL72:
 738              	.L115:
 739              		.loc 1 379 0
 740              		mrc p15,0,r0, c3, c3
 741 0430 EE160F16 	.LVL73:
 742              		mov	pc, lr
 743 0434 E1A0F00E 	.LVL74:
 744              	.L114:
 745              		.loc 1 378 0
 746              		mrc p15,0,r0, c2, c2
 747 0438 EE150F15 	.LVL75:
 748              		mov	pc, lr
 749 043c E1A0F00E 	.LVL76:
 750              	.L113:
 751              		.loc 1 377 0
 752              		mrc p15,0,r0, c1, c1
 753 0440 EE140F14 	.LVL77:
 754              		mov	pc, lr
 755 0444 E1A0F00E 	.LVL78:
 756              	.L112:
 757              		.loc 1 376 0
 758              		mrc p15,0,r0, c0, c0
 759 0448 EE130F13 	.LVL79:
 760              		mov	pc, lr
 761 044c E1A0F00E 	.LFE19:
 763              		.align	2
 764              		.global	set_syscpreg
 766              	set_syscpreg:
 767 0454 E1A0F00E 	.LFB20:
 768              		.loc 1 401 0
 769              		@ args = 0, pretend = 0, frame = 0
 770              		@ frame_needed = 0, uses_anonymous_args = 0
 771 0458 EE110F11 		@ link register save eliminated.
 772              	.LVL80:
 773 045c E1A0F00E 		and	r1, r1, #255
 774              		.loc 1 402 0
 775              		sub	r1, r1, #6
 776              	.LVL81:
 777 0460 EE100F10 		.loc 1 401 0
 778              		@ lr needed for prologue
 779 0464 E1A0F00E 		.loc 1 402 0
 780              		cmp	r1, #7
 781              		ldrls	pc, [pc, r1, asl #2]
 782              		b	.L138
 783              		.p2align 2
 784              	.L137:
 785              		.word	.L133
 786              		.word	.L138
 396:../lib/io_driver.c **** 
 397:../lib/io_driver.c **** // ******************************************************************************
 398:../lib/io_driver.c **** // write system coprocessor register x
 399:../lib/io_driver.c ****    void set_syscpreg(unsigned long _cp_val, unsigned char index)
 400:../lib/io_driver.c **** // ******************************************************************************
 401:../lib/io_driver.c **** {
 787              		mcr p15,0,r0,c13,c13,0
 788              	.L138:
 789              		mov	pc, lr
 790              	.L133:
 791              		.loc 1 409 0
 792 0468 E20110FF 		mcr p15,0,r0, c6, c6,0
 402:../lib/io_driver.c **** 	switch(index){
 793              	c, lr
 794 046c E2411006 	.L134:
 795              		.loc 1 414 0
 796              		mcr p15,0,r0,c11,c11,0
 797              		mov	pc, lr
 798              	.L135:
 799 0470 E3510007 		.loc 1 415 0
 800 0474 979FF101 		mcr p15,0,r0,c12,c12,0
 801 0478 EA000008 		mov	pc, lr
 802              	.LFE20:
 804 047c 000004A4 		.align	2
 805 0480 000004A0 		.global	uart0_printf
 807 0488 000004A0 	uart0_printf:
 808 048c 000004A0 	.LFB25:
 809 0490 000004AC 		.file 2 "../lib/uart.c"
 810 0494 000004B4 		.loc 2 7 0
 811 0498 0000049C 		@ args = 0, pretend = 0, frame = 0
 812              		@ frame_needed = 0, uses_anonymous_args = 0
 403:../lib/io_driver.c **** //		case ID_REG_0:   asm volatile ("mcr p15,0,%0, c0, c0,0" : /* no outputs */ : "r" (_cp_val)); br
 404:../lib/io_driver.c **** //		case ID_REG_1:   asm volatile ("mcr p15,0,%0, c1, c1,0" : /* no outputs */ : "r" (_cp_val)); br
 405:../lib/io_driver.c **** //		case ID_REG_2:   asm volatile ("mcr p15,0,%0, c2, c2,0" : /* no outputs */ : "r" (_cp_val)); br
 406:../lib/io_driver.c **** //		case 3:          asm volatile ("mcr p15,0,%0, c3, c3,0" : /* no outputs */ : "r" (_cp_val)); br
 407:../lib/io_driver.c **** //		case 4:          asm volatile ("mcr p15,0,%0, c4, c4,0" : /* no outputs */ : "r" (_cp_val)); br
 408:../lib/io_driver.c **** //		case 5:          asm volatile ("mcr p15,0,%0, c5, c5,0" : /* no outputs */ : "r" (_cp_val)); br
 409:../lib/io_driver.c **** 		case SYS_CTRL_0: asm volatile ("mcr p15,0,%0, c6, c6,0" : /* no outputs */ : "r" (_cp_val)); brea
 410:../lib/io_driver.c **** //		case 7:          asm volatile ("mcr p15,0,%0, c7, c7,0" : /* no outputs */ : "r" (_cp_val)); br
 411:../lib/io_driver.c **** //		case CSTAT:      asm volatile ("mcr p15,0,%0, c8, c8,0" : /* no outputs */ : "r" (_cp_val)); br
 412:../lib/io_driver.c **** //		case ADR_FB:     asm volatile ("mcr p15,0,%0, c9, c9,0" : /* no outputs */ : "r" (_cp_val)); br
 413:../lib/io_driver.c **** //		case 10:         asm volatile ("mcr p15,0,%0,c10,c10,0" : /* no outputs */ : "r" (_cp_val)); br
 414:../lib/io_driver.c **** 		case LFSR_POLY:  asm volatile ("mcr p15,0,%0,c11,c11,0" : /* no outputs */ : "r" (_cp_val)); brea
 415:../lib/io_driver.c **** 		case LFSR_DATA:  asm volatile ("mcr p15,0,%0,c12,c12,0" : /* no outputs */ : "r" (_cp_val)); brea
 416:../lib/io_driver.c **** 		case SYS_IO:     asm volatile ("mcr p15,0,%0,c13,c13,0" : /* no outputs */ : "r" (_cp_val)); brea
 813              	{r4, lr}
 814 049c EE0D0F1D 	.LCFI2:
 815              		.loc 2 7 0
 816 04a0 E1A0F00E 		mov	r4, r0
 817              		.loc 2 10 0
 818              		ldrb	r0, [r0, #0]	@ zero_extendqisi2
 819 04a4 EE060F16 	.LVL83:
 820 04a8 E1A0F00E 		cmp	r0, #0
 821              		bne	.L144
 822              		b	.L140
 823 04ac EE0B0F1B 	.LVL84:
 824 04b0 E1A0F00E 	.L146:
 825              		ldrb	r0, [r4, #1]!	@ zero_extendqisi2
 826              	.LVL85:
 827 04b4 EE0C0F1C 		cmp	r0, #0
 828 04b8 E1A0F00E 		beq	.L140
 829              	.L144:
 830              		.loc 2 11 0
 831              		bl	io_uart0_send_byte
 832              	.LVL86:
 833              		cmp	r0, #0
 834              		bgt	.L146
 835              	.LVL87:
 836              	.L140:
   1:../lib/uart.c **** #include "uart.h"
   2:../lib/uart.c **** 
   3:../lib/uart.c **** // ############################################################################################
   4:../lib/uart.c **** // Print text string via UART 0
   5:../lib/uart.c ****    const char *uart0_printf(const char *string)
   6:../lib/uart.c **** // ############################################################################################
   7:../lib/uart.c **** {
 837              	
 838              	.LVL88:
 839              		ldmfd	sp!, {r4, pc}
 840              	.LFE25:
 842              		.section	.rodata
 843              		.align	2
 844 04c0 E1A04000 	.LC0:
   8:../lib/uart.c **** 	char ch;
   9:../lib/uart.c **** 
  10:../lib/uart.c **** 	while ((ch = *string)){
 845              		"\000\000"
 846 04c4 E5D00000 		.text
 847              		.align	2
 848 04c8 E3500000 		.global	uart0_scanf
 850 04d0 EA000005 	uart0_scanf:
 851              	.LFB26:
 852              		.loc 2 22 0
 853 04d4 E5F40001 		@ args = 0, pretend = 0, frame = 0
 854              		@ frame_needed = 0, uses_anonymous_args = 0
 855 04d8 E3500000 	.LVL89:
 856 04dc 0A000002 		stmfd	sp!, {r4, r5, r6, lr}
 857              	.LCFI3:
  11:../lib/uart.c **** 		if (io_uart0_send_byte(ch)<=0)
 858              		subs	r4, r1, #0
 859 04e0 EBFFFFFE 		.loc 2 22 0
 860              		mov	r5, r0
 861 04e4 E3500000 		and	r6, r2, #255
 862 04e8 CAFFFFF9 		.loc 2 25 0
 863              		ble	.L148
 864              	.LVL90:
  12:../lib/uart.c **** 			break;
  13:../lib/uart.c **** 		string++;
  14:../lib/uart.c **** 	}
  15:../lib/uart.c **** 	return string;
  16:../lib/uart.c **** }
 865              		.loc 2 26 0
 866 04ec E1A00004 		bl	io_uart0_read_byte
 867              	.LVL91:
 868 04f0 E8BD8010 	.LVL92:
 869              		.loc 2 27 0
 870              		cmn	r0, #1
 871              		.loc 2 28 0
 872              		and	r3, r0, #255
 873              	.LVL93:
 874 0000 0000     		.loc 2 27 0
 875 0002 0000     		beq	.L150
 876              		.loc 2 30 0
 877              		cmp	r6, #1
 878              	.LVL94:
 879              		.loc 2 29 0
 880              		strb	r3, [r5, #0]
  17:../lib/uart.c **** 
  18:../lib/uart.c **** // ############################################################################################
  19:../lib/uart.c **** // Read text string via UART 0
  20:../lib/uart.c ****    void uart0_scanf(unsigned char *buffer, int length, unsigned char en_echo)
  21:../lib/uart.c **** // ############################################################################################
  22:../lib/uart.c **** {
 881              	31 0
 882              		mov	r0, r3
 883              	.LVL96:
 884              		.loc 2 29 0
 885 04f4 E92D4070 		add	r5, r5, #1
 886              		.loc 2 30 0
  23:../lib/uart.c **** 	int temp = 0;
  24:../lib/uart.c **** 
  25:../lib/uart.c **** 	while(length > 0){
 887              	L157
 888 04f8 E2514000 	.LVL97:
 889              	.L152:
 890 04fc E1A05000 		.loc 2 32 0
 891 0500 E20260FF 		sub	r4, r4, #1
 892              	.LVL98:
 893 0504 DA00000B 	.L150:
 894              		.loc 2 25 0
 895              		cmp	r4, #0
  26:../lib/uart.c **** 		temp = io_uart0_read_byte();
 896              	5
 897 0508 EBFFFFFE 	.LVL99:
 898              	.L148:
 899              		.loc 2 35 0
  27:../lib/uart.c **** 		if(temp != -1){
 900              		r3, .L158
 901 050c E3700001 	.LVL100:
  28:../lib/uart.c **** 			temp = (unsigned char)(temp & 0x000000FF);
 902              	trb	r3, [r5, #0]
 903 0510 E20030FF 		.loc 2 36 0
 904              		ldmfd	sp!, {r4, r5, r6, pc}
 905              	.LVL101:
 906 0514 0A000005 	.L157:
  29:../lib/uart.c **** 			*buffer++ = temp;
  30:../lib/uart.c **** 			if(en_echo == 1)
 907              	 2 31 0
 908 0518 E3560001 		bl	io_uart0_send_byte
 909              	.LVL102:
 910              		b	.L152
 911 051c E5C53000 	.L159:
 912              		.align	2
  31:../lib/uart.c **** 				io_uart0_send_byte(temp); // echo
 913              	
 914 0520 E1A00003 		.word	.LC0
 915              	.LFE26:
 917 0524 E2855001 		.align	2
 918              		.global	uart0_print_buffer
 920              	uart0_print_buffer:
 921              	.LFB27:
  32:../lib/uart.c **** 			length--;
 922              	42 0
 923 052c E2444001 		@ args = 0, pretend = 0, frame = 0
 924              		@ frame_needed = 0, uses_anonymous_args = 0
 925              	.LVL103:
 926              		stmfd	sp!, {r4, r5, lr}
 927 0530 E3540000 	.LCFI4:
 928 0534 CAFFFFF3 		.loc 2 44 0
 929              		subs	r4, r1, #0
 930              		.loc 2 42 0
  33:../lib/uart.c **** 		}
  34:../lib/uart.c **** 	}
  35:../lib/uart.c **** 	*buffer="\0";
 931              	r0
 932 0538 E59F300C 		.loc 2 44 0
 933              		ldmlefd	sp!, {r4, r5, pc}
 934 053c E5C53000 	.LVL104:
  36:../lib/uart.c **** }
 935              	4:
 936 0540 E8BD8070 		.loc 2 46 0
 937              		ldrb	r0, [r5], #1	@ zero_extendqisi2
 938              	.LVL105:
 939              		bl	io_uart0_send_byte
 940 0544 EBFFFFFE 	.LVL106:
 941              		.loc 2 44 0
 942 0548 EAFFFFF7 		subs	r4, r4, #1
 943              		bne	.L164
 944              		ldmfd	sp!, {r4, r5, pc}
 945              	.LFE27:
 947              		.align	2
 948              		.global	long_to_hex_string
 950              	long_to_hex_string:
 951              	.LFB28:
 952              		.file 3 "../lib/utilities.c"
 953              		.loc 3 9 0
  37:../lib/uart.c **** 
  38:../lib/uart.c **** // ############################################################################################
  39:../lib/uart.c **** // Print character buffer via UART 0
  40:../lib/uart.c ****    void uart0_print_buffer(unsigned char *buffer, int size)
  41:../lib/uart.c **** // ############################################################################################
  42:../lib/uart.c **** {
 954              	d = 0, frame = 0
 955              		@ frame_needed = 0, uses_anonymous_args = 0
 956              	.LVL107:
 957              		stmfd	sp!, {r4, lr}
 958 0550 E92D4030 	.LCFI5:
 959              		.loc 3 9 0
  43:../lib/uart.c **** 	unsigned char char_buffer = 0;
  44:../lib/uart.c **** 	while(size > 0){
 960              	4, r2, #255
 961 0554 E2514000 		.loc 3 14 0
 962              		cmp	r4, #8
 963 0558 E1A05000 		movhi	r4, #8
 964              		bhi	.L169
 965 055c D8BD8030 	.LVL108:
 966              		.loc 3 16 0
 967              		cmp	r4, #0
  45:../lib/uart.c **** 		char_buffer = *buffer++;
  46:../lib/uart.c **** 		io_uart0_send_byte((int)char_buffer);
 968              	39 0
 969 0560 E4D50001 		moveq	r4, #1
 970              	.L169:
 971 0564 EBFFFFFE 		mov	r2, r1
 972              	.LVL109:
 973              		mov	lr, r4
 974 0568 E2544001 	.LVL110:
 975 056c 1AFFFFFB 	.L171:
 976 0570 E8BD8030 		.loc 3 22 0
 977              		mov	r3, lr, asl #2
 978              		.loc 3 21 0
 979              		cmp	lr, #1
 980              		.loc 3 22 0
 981              		sub	r3, r3, #4
 982              		.loc 3 21 0
 983              		mov	ip, r0
 984              	.LVL111:
   1:../lib/utilities.c **** #include "utilities.h"
   2:../lib/utilities.c **** 
   3:../lib/utilities.c **** // ############################################################################################
   4:../lib/utilities.c **** // Convert 4/8/12/16/20/24/28/32 bit hexadecimal value to ASCII string
   5:../lib/utilities.c ****    void long_to_hex_string(unsigned long data,    // max 32 bit data word
   6:../lib/utilities.c ****                            unsigned char *buffer, // buffer to store the string
   7:../lib/utilities.c **** 						   unsigned char numbers) // number of places, max 8
   8:../lib/utilities.c **** // ############################################################################################
   9:../lib/utilities.c **** {
 985              	hi	ip, r0, lsr r3
 986              		.loc 3 26 0
 987              		sub	r3, lr, #1
 988              		.loc 3 25 0
 989 0574 E92D4010 		and	ip, ip, #15
 990              	.LVL112:
 991              		.loc 3 26 0
 992 0578 E20240FF 		and	lr, r3, #255
  10:../lib/utilities.c **** 	unsigned char temp_char = 0;
  11:../lib/utilities.c **** 	unsigned long temp_data = 0;
  12:../lib/utilities.c **** 
  13:../lib/utilities.c **** 	// fit into range
  14:../lib/utilities.c **** 	if(numbers > 8)
 993              	29 0
 994 057c E3540008 		cmp	ip, #9
 995 0580 83A04008 		.loc 3 30 0
 996 0584 8A000001 		add	r3, ip, #48
 997              	.LVL113:
  15:../lib/utilities.c **** 		numbers = 8;
  16:../lib/utilities.c **** 	if(numbers < 1)
 998              	 3 32 0
 999 0588 E3540000 		addhi	r3, ip, #55
  17:../lib/utilities.c **** 		numbers = 1;
  18:../lib/utilities.c **** 
  19:../lib/utilities.c **** 	while(numbers > 0){
  20:../lib/utilities.c **** 		// isolate one 4-bit value
  21:../lib/utilities.c **** 		if(numbers > 1)
  22:../lib/utilities.c **** 			temp_data = data >> ((numbers-1)*4);
  23:../lib/utilities.c **** 		else
  24:../lib/utilities.c **** 			temp_data = data;
  25:../lib/utilities.c **** 		temp_data = temp_data & 0x0000000F;
  26:../lib/utilities.c **** 		numbers--;
  27:../lib/utilities.c **** 
  28:../lib/utilities.c **** 		// convert 4-bit value temp_data to char temp_char
  29:../lib/utilities.c **** 		if(temp_data < 10)
  30:../lib/utilities.c **** 			temp_char = '0' + temp_data;
  31:../lib/utilities.c **** 		else
  32:../lib/utilities.c **** 			temp_char = 'A' + temp_data - 10;
  33:../lib/utilities.c **** 
  34:../lib/utilities.c **** 		// save character
  35:../lib/utilities.c **** 		*buffer++ = temp_char;
  36:../lib/utilities.c **** 	}
  37:../lib/utilities.c **** 
  38:../lib/utilities.c **** 	*buffer++ = 0; // terminate string
  39:../lib/utilities.c **** }
 1000              	loc 3 19 0
 1001 058c 03A04001 		cmp	lr, #0
 1002              		.loc 3 35 0
 1003 0590 E1A02001 		strb	r3, [r2], #1
 1004              		.loc 3 19 0
 1005 0594 E1A0E004 		bne	.L171
 1006              		.loc 3 38 0
 1007              		sub	r3, r4, #1
 1008              	.LVL114:
 1009 0598 E1A0310E 		and	r3, r3, #255
 1010              		add	r3, r1, r3
 1011 059c E35E0001 		strb	lr, [r3, #1]
 1012              		.loc 3 39 0
 1013 05a0 E2433004 		ldmfd	sp!, {r4, pc}
 1014              	.LFE28:
 1016              		.align	2
 1017              		.global	get_adc
 1019              	get_adc:
 1020 05ac E24E3001 	.LFB29:
 1021              		.loc 3 45 0
 1022 05b0 E20CC00F 		@ args = 0, pretend = 0, frame = 0
 1023              		@ frame_needed = 0, uses_anonymous_args = 0
 1024              	.LVL115:
 1025 05b4 E203E0FF 		stmfd	sp!, {r4, lr}
 1026              	.LCFI6:
 1027 05b8 E35C0009 		.loc 3 45 0
 1028              		mov	r4, r0
 1029 05bc E28C3030 		.loc 3 48 0
 1030              		cmp	r4, #7
 1031              		.loc 3 52 0
 1032 05c0 828C3037 		mov	r1, #16
 1033              		mov	r0, #1
 1034 05c4 E35E0000 	.LVL116:
 1035              		.loc 3 48 0
 1036 05c8 E4C23001 		bls	.L188
 1037              		.loc 3 58 0
 1038 05cc 1AFFFFF1 		mov	r0, #0
 1039              		ldmfd	sp!, {r4, pc}
 1040 05d0 E2443001 	.L188:
 1041              		.loc 3 52 0
 1042 05d4 E20330FF 		bl	io_spi0_config
 1043 05d8 E0813003 		.loc 3 53 0
 1044 05dc E5C3E001 		mov	r0, #6
 1045              		bl	io_spi0_enable
 1046 05e0 E8BD8010 		.loc 3 56 0
 1047              		mov	r0, #0
 1048              		bl	io_spi0_trans
 1049              		.loc 3 57 0
 1050              		mov	r0, r4, asl #11
 1051              		.loc 3 58 0
 1052              		ldmfd	sp!, {r4, lr}
 1053              		.loc 3 57 0
  40:../lib/utilities.c **** 
  41:../lib/utilities.c **** // ############################################################################################
  42:../lib/utilities.c **** // read external ADC value
  43:../lib/utilities.c ****    unsigned int get_adc(int adc_index) // adc 0..7
  44:../lib/utilities.c **** // ############################################################################################
  45:../lib/utilities.c **** {
 1054              	lign	2
 1055              		.global	delay
 1057              	delay:
 1058 05e4 E92D4010 	.LFB30:
 1059              		.loc 3 64 0
 1060              		@ args = 0, pretend = 0, frame = 0
 1061 05e8 E1A04000 		@ frame_needed = 0, uses_anonymous_args = 0
  46:../lib/utilities.c **** 	unsigned long temp;
  47:../lib/utilities.c **** 
  48:../lib/utilities.c **** 	if ((adc_index < 0) || (adc_index > 7))
 1062              	register save eliminated.
 1063 05ec E3540007 	.LVL117:
  49:../lib/utilities.c **** 		return 0;
  50:../lib/utilities.c **** 
  51:../lib/utilities.c **** 	// config spi
  52:../lib/utilities.c **** 	io_spi0_config(1,16); // auto assert cs, 16 bit transfer
 1064              	loc 3 65 0
 1065 05f0 E3A01010 		rsb	r3, r0, r0, asl #5
 1066 05f4 E3A00001 		add	r0, r0, r3, asl #2
 1067              	.LVL118:
 1068              		add	r0, r0, r0, asl #2
 1069 05f8 9A000001 		mov	r0, r0, asl #4
  53:../lib/utilities.c **** 	io_spi0_enable(adc_cs);
  54:../lib/utilities.c **** 
  55:../lib/utilities.c **** 	temp = adc_index * 2048;
  56:../lib/utilities.c **** 	io_spi0_trans(0); // dummy read
  57:../lib/utilities.c **** 	return (unsigned int)io_spi0_trans(temp);
  58:../lib/utilities.c **** }
 1070              	9:
 1071 05fc E3A00000 		.loc 3 66 0
 1072 0600 E8BD8010 		cmp	r0, #0
 1073              		.loc 3 64 0
 1074              		@ lr needed for prologue
 1075 0604 EBFFFFFE 		.loc 3 66 0
 1076              		movle	pc, lr
 1077 0608 E3A00006 	.L193:
 1078 060c EBFFFFFE 		.loc 3 67 0
 1079              		NOP
 1080 0610 E3A00000 		.loc 3 66 0
 1081 0614 EBFFFFFE 		subs	r0, r0, #1
 1082              		bne	.L193
 1083 0618 E1A00584 		mov	pc, lr
 1084              	.LFE30:
 1086              		.align	2
 1087 0620 EAFFFFFE 		.global	string_cmpc
 1089              	string_cmpc:
 1090              	.LFB31:
 1091              		.loc 3 76 0
 1092              		@ args = 0, pretend = 0, frame = 0
 1093              		@ frame_needed = 0, uses_anonymous_args = 0
 1094              		@ link register save eliminated.
  59:../lib/utilities.c **** 
  60:../lib/utilities.c **** // ############################################################################################
  61:../lib/utilities.c **** // simple delay routine
  62:../lib/utilities.c ****    void delay(int time) // waits time*10000 clock ticks
  63:../lib/utilities.c **** // ############################################################################################
  64:../lib/utilities.c **** {
 1095              	ds	ip, r2, #255
 1096              		.loc 3 76 0
 1097              		@ lr needed for prologue
 1098              		.loc 3 77 0
 1099              		beq	.L196
  65:../lib/utilities.c **** 	time = time*2500*4;
 1100              	21:
 1101 0624 E0603280 		.loc 3 78 0
 1102 0628 E0800103 		ldrb	r2, [r0, #0]	@ zero_extendqisi2
 1103              		ldrb	r3, [r1, #0]	@ zero_extendqisi2
 1104 062c E0800100 		cmp	r2, r3
 1105 0630 E1A00200 		beq	.L200
 1106              		b	.L198
  66:../lib/utilities.c **** 	while(time > 0){
 1107              	.LVL122:
 1108 0634 E3500000 		ldrb	r2, [r0, #1]!	@ zero_extendqisi2
 1109              	.LVL123:
 1110              		ldrb	r3, [r1, #1]!	@ zero_extendqisi2
 1111              		cmp	r2, r3
 1112 0638 D1A0F00E 		bne	.L198
 1113              	.LVL124:
  67:../lib/utilities.c **** 		asm volatile ("NOP");
 1114              		.loc 3 80 0
 1115 063c E1A00000 		sub	r3, ip, #1
 1116              		.loc 3 77 0
 1117 0640 E2500001 		ands	ip, r3, #255
 1118 0644 1AFFFFFC 		bne	.L201
 1119 0648 E1A0F00E 	.LVL125:
 1120              	.L196:
 1121              		mov	r0, #1
 1122              	.LVL126:
 1123              		.loc 3 83 0
 1124              		mov	pc, lr
 1125              	.LVL127:
 1126              	.L198:
  68:../lib/utilities.c **** 		time--;
  69:../lib/utilities.c **** 	}
  70:../lib/utilities.c **** }
  71:../lib/utilities.c **** 
  72:../lib/utilities.c **** // ############################################################################################
  73:../lib/utilities.c **** // String compare, buffered string with immediate const char string
  74:../lib/utilities.c ****    unsigned char string_cmpc(unsigned char *string1, const char *string2, unsigned char length)
  75:../lib/utilities.c **** // ############################################################################################
  76:../lib/utilities.c **** {
 1127              		mov	r0, #0
 1128              	.LVL128:
 1129              		mov	pc, lr
 1130              	.LFE31:
  77:../lib/utilities.c **** 	while(length != 0){
 1132              	gn	2
 1133 064c E212C0FF 		.global	hex_string_to_long
 1135              	hex_string_to_long:
 1136              	.LFB32:
 1137 0650 0A00000B 		.file 4 "main.c"
 1138              		.loc 4 20 0
  78:../lib/utilities.c **** 		if(*string1++ != (unsigned char)*string2++)
 1139              	 = 0, pretend = 0, frame = 0
 1140 0654 E5D02000 		@ frame_needed = 0, uses_anonymous_args = 0
 1141 0658 E5D13000 	.LVL129:
 1142 065c E1520003 		stmfd	sp!, {r4, r5, lr}
 1143 0660 0A000004 	.LCFI7:
 1144 0664 EA000008 		.loc 4 24 0
 1145              		mov	r4, r1, asl #1
 1146              		cmp	r4, #0
 1147 0668 E5F02001 		.loc 4 20 0
 1148              		mov	r5, r0
 1149 066c E5F13001 		.loc 4 24 0
 1150 0670 E1520003 		movle	r0, #0
 1151 0674 1A000004 	.LVL130:
 1152              		ldmlefd	sp!, {r4, r5, pc}
 1153              		mov	r0, #0
  79:../lib/utilities.c **** 			return(0); // missmatch
  80:../lib/utilities.c **** 		length--;
 1154              	L131:
 1155 0678 E24C3001 	.L208:
 1156              		.loc 4 25 0
 1157 067c E213C0FF 		ldrb	r2, [r1, r5]	@ zero_extendqisi2
 1158 0680 1AFFFFF8 		sub	r3, r2, #48
 1159              		.loc 4 26 0
 1160              		add	ip, r2, r0, asl #4
 1161 0684 E3A00001 		.loc 4 25 0
 1162              		cmp	r3, #9
  81:../lib/utilities.c **** 	}
  82:../lib/utilities.c **** 	return(1); // match
  83:../lib/utilities.c **** }
 1163              	7 0
 1164 0688 E1A0F00E 		sub	lr, r2, #65
 1165              		.loc 4 26 0
 1166              		subls	r0, ip, #48
 1167              		.loc 4 25 0
 1168 068c E3A00000 		bls	.L211
 1169              		.loc 4 28 0
 1170 0690 E1A0F00E 		add	r3, r2, r0, asl #4
 1171              		.loc 4 27 0
 1172              		cmp	lr, #5
 1173              		.loc 4 29 0
 1174              		sub	ip, r2, #97
 1175              		.loc 4 28 0
 1176              		subls	r0, r3, #55
 1177              		.loc 4 27 0
 1178              		bls	.L211
   1:main.c        **** #include "../lib/storm_core.h"
   2:main.c        **** #include "../lib/storm_soc_basic.h"
   3:main.c        **** #include "../lib/io_driver.c"
   4:main.c        **** #include "../lib/uart.c"
   5:main.c        **** #include "../lib/utilities.c"
   6:main.c        **** 
   7:main.c        **** // #define DUMPADDRESS 0x00000000
   8:main.c        **** // #define JUMPADDRESS 0x04000000
   9:main.c        **** //#define SRAM
  10:main.c        **** 
  11:main.c        **** #ifdef SRAM
  12:main.c        **** 	#define DUMPADDRESS 0x00000000
  13:main.c        **** 	#define JUMPADDRESS 0x00000000
  14:main.c        **** #else
  15:main.c        **** 	#define DUMPADDRESS 0x04000000
  16:main.c        **** 	#define JUMPADDRESS 0x04000000
  17:main.c        **** #endif
  18:main.c        **** 
  19:main.c        **** unsigned long int hex_string_to_long ( char *hexstr, int charlen )
  20:main.c        **** {
 1179              	d	r3, r2, r0, asl #4
 1180              		.loc 4 29 0
 1181              		cmp	ip, #5
 1182              		.loc 4 30 0
 1183 0694 E92D4030 		subls	r0, r3, #87
 1184              	.L211:
  21:main.c        **** 	unsigned long int hexval =  0 ;
  22:main.c        **** 	int i;
  23:main.c        **** 
  24:main.c        **** 	for (i=0 ; i< (charlen*2) ; i++ ) {
 1185              	4 24 0
 1186 0698 E1A04081 		add	r1, r1, #1
 1187 069c E3540000 		cmp	r1, r4
 1188              		bne	.L208
 1189 06a0 E1A05000 	.LVL132:
 1190              		.loc 4 34 0
 1191 06a4 D3A00000 		ldmfd	sp!, {r4, r5, pc}
 1192              	.LFE32:
 1194 06ac E3A00000 		.section	.rodata.str1.4,"aMS",%progbits,1
 1195 06b0 E1A01000 		.align	2
 1196              	.LC1:
 1197              		.ascii	"\015\012\015\012\015\012+--------------------------"
  25:main.c        **** 		if (( hexstr[i] >= 48 ) & (hexstr[i] <= 57 )) 
 1198              	----------------------------------+\015\012\000"
 1199 06b4 E7D12005 		.align	2
 1200 06b8 E2423030 	.LC2:
  26:main.c        **** 			hexval = (hexval <<4 ) + hexstr[i] - (int) '0';
 1201              	scii	"|    <<< STORM Core Processor System - By Stephan N"
 1202 06bc E082C200 		.ascii	"olting >>>    |\015\012\000"
 1203              		.align	2
 1204 06c0 E3530009 	.LC3:
  27:main.c        **** 		else if (( hexstr[i] >= 65 ) & ( hexstr[i] <= 70 )) 
 1205              	cii	"+--------------------------------------------------"
 1206 06c4 E242E041 		.ascii	"--------------+\015\012\000"
 1207              		.align	2
 1208 06c8 924C0030 	.LC4:
 1209              		.ascii	"|         Bootloader for STORM SoC   Version: 20120"
 1210 06cc 9A000007 		.ascii	"524-D         |\015\012\000"
  28:main.c        **** 			hexval = (hexval <<4 ) + hexstr[i] + 10 - (int) 'A';
 1211              	n	2
 1212 06d0 E0823200 	.LC5:
 1213              		.ascii	"|               Contact: stnolting@googlemail.com  "
 1214 06d4 E35E0005 		.ascii	"              |\015\012\000"
  29:main.c        **** 		else if (( hexstr[i] >= 97 ) & ( hexstr[i] <= 102)) 
 1215              	ign	2
 1216 06d8 E242C061 	.LC6:
 1217              		.ascii	"+--------------------------------------------------"
 1218 06dc 92430037 		.ascii	"--------------+\015\012\015\012\000"
 1219              		.align	2
 1220 06e0 9A000002 	.LC7:
  30:main.c        **** 			hexval = (hexval <<4 ) + hexstr[i] +10 - (int) 'a';
 1221              	i	"connected to I2C_CONTROLLER_0, operating frequency "
 1222 06e4 E0823200 		.ascii	"is 100kHz,\015\012\000"
 1223              		.align	2
 1224 06e8 E35C0005 	.LC8:
 1225              		.ascii	"maximum EEPROM size = 65536 byte => 16 bit addresse"
 1226 06ec 92430057 		.ascii	"s,\015\012\000"
 1227              		.align	2
 1228              	.LC9:
 1229 06f0 E2811001 		.ascii	"fixed boot device address: 0xA0\015\012\015\012\000"
 1230 06f4 E1510004 		.align	2
 1231 06f8 1AFFFFED 	.LC10:
 1232              		.ascii	"Boot EEPROM: 24xxnnn (like 24AA64), 7 bit address +"
  31:main.c        **** 	} //for
  32:main.c        ****  
  33:main.c        **** 	return hexval;
  34:main.c        **** }
 1233              	nt-care bit,\015\012\000"
 1234 06fc E8BD8030 		.align	2
 1235              	.LC11:
 1236              		.ascii	" < Welcome to the STORM SoC bootloader console! >\015"
 1237              		.ascii	"\012 < Select an operation from the menu below or p"
 1238              		.ascii	"ress >\015\012\000"
 1239              		.align	2
 1240 0000 0D0A0D0A 	.LC12:
 1240      0D0A2B2D 
 1240      2D2D2D2D 
 1240      2D2D2D2D 
 1240      2D2D2D2D 
 1241 0021 2D2D2D2D 		.ascii	" < the boot key for immediate application start. >\015"
 1241      2D2D2D2D 
 1241      2D2D2D2D 
 1241      2D2D2D2D 
 1241      2D2D2D2D 
 1242 004b 00       		.ascii	"\012\015\012\000"
 1243              		.align	2
 1244 004c 7C202020 	.LC13:
 1244      203C3C3C 
 1244      2053544F 
 1244      524D2043 
 1244      6F726520 
 1245 007f 6F6C7469 		.ascii	" 0 - boot from core RAM (start application)\015\012"
 1245      6E67203E 
 1245      3E3E2020 
 1245      20207C0D 
 1245      0A00
 1246 0091 000000   		.ascii	" 1 - program core RAM via UART_0\015\012 2 - core R"
 1247              		.ascii	"AM dump\015\012\000"
 1248 0094 2B2D2D2D 		.align	2
 1248      2D2D2D2D 
 1248      2D2D2D2D 
 1248      2D2D2D2D 
 1248      2D2D2D2D 
 1249 00c7 2D2D2D2D 	.LC14:
 1249      2D2D2D2D 
 1249      2D2D2D2D 
 1249      2D2D2B0D 
 1249      0A00
 1250 00d9 000000   		.ascii	" 3 - boot from I2C EEPROM\015\012 4 - program I2C E"
 1251              		.ascii	"EPROM via UART_0\015\012 5 - show content of I2C EE"
 1252 00dc 7C202020 		.ascii	"PROM\015\012\000"
 1252      20202020 
 1252      2020426F 
 1252      6F746C6F 
 1252      61646572 
 1253 010f 3532342D 		.align	2
 1253      44202020 
 1253      20202020 
 1253      20207C0D 
 1253      0A00
 1254 0121 000000   	.LC15:
 1255              		.ascii	" a - automatic boot configuration\015\012 h - help\015"
 1256 0124 7C202020 		.ascii	"\012 r - restart system\015\012\015\012Select: \000"
 1256      20202020 
 1256      20202020 
 1256      20202020 
 1256      436F6E74 
 1257 0157 20202020 		.text
 1257      20202020 
 1257      20202020 
 1257      20207C0D 
 1257      0A00
 1258 0169 000000   		.align	2
 1259              		.global	help_info
 1261 019f 2D2D2D2D 	help_info:
 1261      2D2D2D2D 
 1261      2D2D2D2D 
 1261      2D2D2B0D 
 1261      0A0D0A00 
 1262 01b3 00       	.LFB33:
 1263              		.loc 4 35 0
 1264 01b4 636F6E6E 		@ args = 0, pretend = 0, frame = 0
 1264      65637465 
 1264      6420746F 
 1264      20493243 
 1264      5F434F4E 
 1265 01e7 69732031 		@ frame_needed = 0, uses_anonymous_args = 0
 1265      30306B48 
 1265      7A2C0D0A 
 1265      00
 1266              		str	lr, [sp, #-4]!
 1267              	.LCFI8:
 1268 01f4 6D617869 		.loc 4 36 0
 1268      6D756D20 
 1268      45455052 
 1268      4F4D2073 
 1268      697A6520 
 1269 0227 732C0D0A 		ldr	r0, .L219
 1269      00
 1270              		bl	uart0_printf
 1271              		.loc 4 37 0
 1272 022c 66697865 		ldr	r0, .L219+4
 1272      6420626F 
 1272      6F742064 
 1272      65766963 
 1272      65206164 
 1273              		bl	uart0_printf
 1274              		.loc 4 38 0
 1275 0250 426F6F74 		ldr	r0, .L219+8
 1275      20454550 
 1275      524F4D3A 
 1275      20323478 
 1275      786E6E6E 
 1276 0283 20646F6E 		bl	uart0_printf
 1276      742D6361 
 1276      72652062 
 1276      69742C0D 
 1276      0A00
 1277 0295 000000   		.loc 4 39 0
 1278              		ldr	r0, .L219+12
 1279 0298 203C2057 		bl	uart0_printf
 1279      656C636F 
 1279      6D652074 
 1279      6F207468 
 1279      65205354 
 1280 02ca 0A203C20 		.loc 4 40 0
 1280      53656C65 
 1280      63742061 
 1280      6E206F70 
 1280      65726174 
 1281 02fa 72657373 		ldr	r0, .L219+16
 1281      203E0D0A 
 1281      00
 1282 0303 00       		bl	uart0_printf
 1283              		.loc 4 41 0
 1284 0304 203C2074 		ldr	r0, .L219+20
 1284      68652062 
 1284      6F6F7420 
 1284      6B657920 
 1284      666F7220 
 1285 0337 0A0D0A00 		bl	uart0_printf
 1286 033b 00       		.loc 4 42 0
 1287              		ldr	r0, .L219+24
 1288 033c 2030202D 		bl	uart0_printf
 1288      20626F6F 
 1288      74206672 
 1288      6F6D2063 
 1288      6F726520 
 1289 0369 2031202D 		.loc 4 43 0
 1289      2070726F 
 1289      6772616D 
 1289      20636F72 
 1289      65205241 
 1290 0396 414D2064 		ldr	r0, .L219+28
 1290      756D700D 
 1290      0A00
 1291              		bl	uart0_printf
 1292              		.loc 4 44 0
 1293 03a0 2033202D 		ldr	r0, .L219+32
 1293      20626F6F 
 1293      74206672 
 1293      6F6D2049 
 1293      32432045 
 1294 03cd 4550524F 		bl	uart0_printf
 1294      4D207669 
 1294      61205541 
 1294      52545F30 
 1294      0D0A2035 
 1295 03fa 50524F4D 		.loc 4 45 0
 1295      0D0A00
 1296 0401 000000   		ldr	r0, .L219+36
 1297              		bl	uart0_printf
 1298 0404 2061202D 		.loc 4 46 0
 1298      20617574 
 1298      6F6D6174 
 1298      69632062 
 1298      6F6F7420 
 1299 0431 0A207220 		ldr	r0, .L219+40
 1299      2D207265 
 1299      73746172 
 1299      74207379 
 1299      7374656D 
 1300              		bl	uart0_printf
 1301              		.loc 4 47 0
 1302              		ldr	r0, .L219+44
 1303              		bl	uart0_printf
 1304              		.loc 4 50 0
 1305              		ldr	r0, .L219+48
  35:main.c        **** void help_info () {
 1306              	52 0
 1307              		ldr	r0, .L219+56
 1308              		.loc 4 61 0
 1309 0700 E52DE004 		ldr	lr, [sp], #4
 1310              		.loc 4 52 0
  36:main.c        **** 	uart0_printf("\r\n\r\n\r\n+----------------------------------------------------------------+\r\n")
 1311              	rt0_printf
 1312 0704 E59F0074 	.L220:
 1313 0708 EBFFFFFE 		.align	2
  37:main.c        **** 	uart0_printf(            "|    <<< STORM Core Processor System - By Stephan Nolting >>>    |\r\n")
 1314              	19:
 1315 070c E59F0070 		.word	.LC1
 1316 0710 EBFFFFFE 		.word	.LC2
  38:main.c        **** 	uart0_printf(            "+----------------------------------------------------------------+\r\n")
 1317              	ord	.LC3
 1318 0714 E59F006C 		.word	.LC4
 1319 0718 EBFFFFFE 		.word	.LC5
  39:main.c        **** 	uart0_printf(            "|         Bootloader for STORM SoC   Version: 20120524-D         |\r\n")
 1320              	ord	.LC6
 1321 071c E59F0068 		.word	.LC7
 1322 0720 EBFFFFFE 		.word	.LC8
  40:main.c        **** 	uart0_printf(            "|               Contact: stnolting@googlemail.com                |\r\n")
 1323              	ord	.LC9
 1324 0724 E59F0064 		.word	.LC10
 1325 0728 EBFFFFFE 		.word	.LC11
  41:main.c        **** 	uart0_printf(            "+----------------------------------------------------------------+\r\n\r
 1326              	ord	.LC12
 1327 072c E59F0060 		.word	.LC13
 1328 0730 EBFFFFFE 		.word	.LC14
  42:main.c        **** 	uart0_printf("connected to I2C_CONTROLLER_0, operating frequency is 100kHz,\r\n");
 1329              	ord	.LC15
 1330 0734 E59F005C 	.LFE33:
  43:main.c        **** 	uart0_printf("maximum EEPROM size = 65536 byte => 16 bit addresses,\r\n");
 1332              	lign	2
 1333 073c E59F0058 		.global	qbytes_to_long
  44:main.c        **** 	uart0_printf("fixed boot device address: 0xA0\r\n\r\n");
 1335              	tes_to_long:
 1336 0744 E59F0054 	.LFB34:
 1337 0748 EBFFFFFE 		.loc 4 63 0
  45:main.c        **** 	uart0_printf("Boot EEPROM: 24xxnnn (like 24AA64), 7 bit address + dont-care bit,\r\n");
 1338              	args = 0, pretend = 0, frame = 0
 1339 074c E59F0050 		@ frame_needed = 0, uses_anonymous_args = 0
 1340 0750 EBFFFFFE 		@ link register save eliminated.
  46:main.c        **** 	uart0_printf(            " < Welcome to the STORM SoC bootloader console! >\r\n < Select an operat
 1341              	L133:
 1342 0754 E59F004C 		ldrb	r3, [r0, #3]	@ zero_extendqisi2
 1343 0758 EBFFFFFE 		ldrb	r2, [r0, #2]	@ zero_extendqisi2
  47:main.c        **** 	uart0_printf(            " < the boot key for immediate application start. >\r\n\r\n");
 1344              	rb	r1, [r0, #0]	@ zero_extendqisi2
 1345 075c E59F0048 		orr	r3, r3, r2, asl #8
 1346 0760 EBFFFFFE 		ldrb	r0, [r0, #1]	@ zero_extendqisi2
  48:main.c        **** 
  49:main.c        **** 	// Console menu
  50:main.c        **** 	uart0_printf(" 0 - boot from core RAM (start application)\r\n 1 - program core RAM via UART_0\r\n 
 1347              	L134:
 1348 0764 E59F0044 		orr	r3, r3, r1, asl #24
 1349 0768 EBFFFFFE 		.loc 4 73 0
  51:main.c        **** 	uart0_printf(" 3 - boot from I2C EEPROM\r\n 4 - program I2C EEPROM via UART_0\r\n 5 - show content
 1350              	r	r0, r3, r0, asl #16
 1351 076c E59F0040 		.loc 4 63 0
 1352 0770 EBFFFFFE 		@ lr needed for prologue
  52:main.c        **** 	uart0_printf(" a - automatic boot configuration\r\n h - help\r\n r - restart system\r\n\r\nSelect:
 1353              	oc 4 73 0
 1354 0774 E59F003C 		mov	pc, lr
  53:main.c        **** 
  54:main.c        **** 
  55:main.c        **** 	// uart0_printf("Terminal setup: 9600 baud, 8 data bits, no parity, 1 stop bit\r\n\r\n");
  56:main.c        **** 	// uart0_printf("For more information see the STORM Core / STORM SoC datasheet\r\n");
  57:main.c        **** 	// uart0_printf("http://opencores.org/project,storm_core\r\n");
  58:main.c        **** 	// uart0_printf("http://opencores.org/project,storm_soc\r\n");
  59:main.c        **** 	// uart0_printf("Contact: stnolting@googlemail.com\r\n");
  60:main.c        **** 	// uart0_printf("(c) 2012 by Stephan Nolting\r\n\r\nSelect: ");
  61:main.c        **** }
 1355              	FE34:
 1357              		.section	.rodata.str1.4
 1358 077c EAFFFFFE 		.align	2
 1359              	.LC16:
 1360              		.ascii	"Address of adr_buffer: \000"
 1361              		.align	2
 1362 0780 00000000 	.LC17:
 1363 0784 0000004C 		.ascii	" \012\015 \000"
 1364 0788 00000094 		.align	2
 1365 078c 000000DC 	.LC18:
 1366 0790 00000124 		.ascii	" Load Address: \000"
 1367 0794 0000016C 		.align	2
 1368 0798 000001B4 	.LC19:
 1369 079c 000001F4 		.ascii	"\015\012\015\012Application will start automaticall"
 1370 07a0 0000022C 		.ascii	"y after download.\015\012-> Waiting for 'storm_prog"
 1371 07a4 00000250 		.ascii	"ram.bin' in byte-stream mode...\000"
 1372 07a8 00000298 		.align	2
 1373 07ac 00000304 	.LC20:
 1374 07b0 0000033C 		.ascii	" SDRAM ERROR! Program file too big!\015\012\015\012"
 1375 07b4 000003A0 		.ascii	"\000"
 1376 07b8 00000404 		.align	2
 1377              	.LC21:
 1378              		.ascii	"Last mem access: \000"
 1379              		.align	2
 1380              	.LC22:
 1381              		.ascii	"!\012\015\000"
 1382              		.align	2
 1383              	.LC23:
  62:main.c        **** unsigned long int qbytes_to_long ( unsigned char *buffer )
  63:main.c        **** {
 1384              	2\000"
 1385              		.align	2
 1386              	.LC24:
 1387              		.ascii	"LAST ADDRESS:\000"
 1388              		.align	2
 1389 07bc E5D03003 	.LC25:
 1390 07c0 E5D02002 		.ascii	" Invalid programming file!\015\012\015\012Select: \000"
 1391 07c4 E5D01000 		.align	2
 1392 07c8 E1833402 	.LC26:
 1393 07cc E5D00001 		.ascii	"\015\012\015\012Abort dumping by pressing any key.\015"
 1394              		.ascii	"\012Press any key to continue.\015\012\015\012\000"
 1395 07d0 E1833C01 		.align	2
  64:main.c        **** 	unsigned char d = buffer[0];
  65:main.c        **** 	unsigned char c = buffer[1];
  66:main.c        **** 	unsigned char b = buffer[2];
  67:main.c        **** 	unsigned char a = buffer[3];
  68:main.c        **** 	unsigned long n;
  69:main.c        **** 
  70:main.c        **** 
  71:main.c        **** 	n = a|(b<<8)|(c<<16)|(d<<24);
  72:main.c        **** 	return n;
  73:main.c        **** }
 1396              	ii	"\015\012\015\012Dumping completed.\015\012\015\012S"
 1397 07d4 E1830800 		.ascii	"elect: \000"
 1398              		.align	2
 1399              	.LC28:
 1400              		.ascii	"\015\012\015\012Enter device address (2x hex_chars,"
 1401 07d8 E1A0F00E 		.ascii	" set LSB to '0'): \000"
 1402              		.align	2
 1403              	.LC29:
 1404              		.ascii	" Invalid address!\015\012\015\012Select: \000"
 1405 0452 0000     		.align	2
 1406              	.LC30:
 1407 0454 41646472 		.ascii	"\015\012Application will start automatically after "
 1407      65737320 
 1407      6F662061 
 1407      64725F62 
 1407      75666665 
 1408              		.ascii	"upload.\015\012-> Loading boot image...\000"
 1409              		.align	2
 1410 046c 200A0D20 	.LC31:
 1410      00
 1411 0471 000000   		.ascii	" Upload complete\015\012\000"
 1412              		.align	2
 1413 0474 204C6F61 	.LC32:
 1413      64204164 
 1413      64726573 
 1413      733A2000 
 1414              		.ascii	" Invalid boot device or file!\015\012\015\012Select"
 1415              		.ascii	": \000"
 1416 0484 0D0A0D0A 		.align	2
 1416      4170706C 
 1416      69636174 
 1416      696F6E20 
 1416      77696C6C 
 1417 04ab 79206166 	.LC33:
 1417      74657220 
 1417      646F776E 
 1417      6C6F6164 
 1417      2E0D0A2D 
 1418 04d8 72616D2E 		.ascii	"\015\012Invalid address!\015\012\015\012Select: \000"
 1418      62696E27 
 1418      20696E20 
 1418      62797465 
 1418      2D737472 
 1419              		.align	2
 1420              	.LC34:
 1421 04f8 20534452 		.ascii	"\015\012Data will overwrite RAM content!\015\012-> "
 1421      414D2045 
 1421      52524F52 
 1421      21205072 
 1421      6F677261 
 1422 051f 00       		.ascii	"Waiting for 'storm_program.bin' in byte-stream mode"
 1423              		.ascii	"...\000"
 1424              		.align	2
 1425 0520 4C617374 	.LC35:
 1425      206D656D 
 1425      20616363 
 1425      6573733A 
 1425      2000
 1426 0532 0000     		.ascii	" ERROR! Program file too big!\015\012\015\012\000"
 1427              		.align	2
 1428 0534 210A0D00 	.LC36:
 1429              		.ascii	" Download completed\015\012\000"
 1430              		.align	2
 1431 0538 446F6E65 	.LC37:
 1431      204C6F61 
 1431      64696E67 
 1431      210D0A00 
 1432              		.ascii	"Writing buffer to i2c EEPROM...\000"
 1433              		.align	2
 1434 0548 4C415354 	.LC38:
 1434      20414444 
 1434      52455353 
 1434      3A00
 1435 0556 0000     		.ascii	" Completed\015\012\015\012\000"
 1436              		.align	2
 1437 0558 20496E76 	.LC39:
 1437      616C6964 
 1437      2070726F 
 1437      6772616D 
 1437      6D696E67 
 1438 057f 00       		.ascii	" Invalid boot device or file!\015\012\015\012\000"
 1439              		.align	2
 1440 0580 0D0A0D0A 	.LC40:
 1440      41626F72 
 1440      74206475 
 1440      6D70696E 
 1440      67206279 
 1441 05a7 0A507265 		.ascii	"Select: \000"
 1441      73732061 
 1441      6E79206B 
 1441      65792074 
 1441      6F20636F 
 1442 05c7 00       		.align	2
 1443              	.LC41:
 1444 05c8 0D0A0D0A 		.ascii	"\015\012\015\012Enter device address (2 hex-chars, "
 1444      44756D70 
 1444      696E6720 
 1444      636F6D70 
 1444      6C657465 
 1445 05e3 656C6563 		.ascii	"set LSB to '0'): \000"
 1445      743A2000 
 1446 05eb 00       		.align	2
 1447              	.LC42:
 1448 05ec 0D0A0D0A 		.ascii	"\015\012\015\012Abort dumping by pressing any key. "
 1448      456E7465 
 1448      72206465 
 1448      76696365 
 1448      20616464 
 1449 0613 20736574 		.ascii	"If no data is shown,\015\012\000"
 1449      204C5342 
 1449      20746F20 
 1449      27302729 
 1449      3A2000
 1450 0626 0000     		.align	2
 1451              	.LC43:
 1452 0628 20496E76 		.ascii	"the selected device is not responding. Press any ke"
 1452      616C6964 
 1452      20616464 
 1452      72657373 
 1452      210D0A0D 
 1453 0646 0000     		.ascii	"y to continue.\015\012\015\012\000"
 1454              		.align	2
 1455 0648 0D0A4170 	.LC44:
 1455      706C6963 
 1455      6174696F 
 1455      6E207769 
 1455      6C6C2073 
 1456 0675 75706C6F 		.ascii	"\015\012\015\012Automatic boot configuration for po"
 1456      61642E0D 
 1456      0A2D3E20 
 1456      4C6F6164 
 1456      696E6720 
 1457 0697 00       		.ascii	"wer-up:\015\012\000"
 1458              		.align	2
 1459 0698 2055706C 	.LC45:
 1459      6F616420 
 1459      636F6D70 
 1459      6C657465 
 1459      0D0A00
 1460 06ab 00       		.ascii	"[3210] configuration DIP switch\015\012 0000 - Star"
 1461              		.ascii	"t bootloader console\015\012 0001 - Automatic boot "
 1462 06ac 20496E76 		.ascii	"from core RAM\015\012\000"
 1462      616C6964 
 1462      20626F6F 
 1462      74206465 
 1462      76696365 
 1463 06d3 3A2000   		.align	2
 1464 06d6 0000     	.LC46:
 1465              		.ascii	" 0010 - Automatic boot from I2C EEPROM (Address 0xA"
 1466 06d8 0D0A496E 		.ascii	"0)\015\012\015\012Select: \000"
 1466      76616C69 
 1466      64206164 
 1466      64726573 
 1466      73210D0A 
 1467 06f7 00       		.align	2
 1468              	.LC47:
 1469 06f8 0D0A4461 		.ascii	"\015\012\015\012We'll send you back - to the future"
 1469      74612077 
 1469      696C6C20 
 1469      6F766572 
 1469      77726974 
 1470 071f 57616974 		.ascii	"!.\015\012\015\012\000"
 1470      696E6720 
 1470      666F7220 
 1470      2773746F 
 1470      726D5F70 
 1471 0752 2E2E2E00 		.align	2
 1472 0756 0000     	.LC48:
 1473              		.ascii	" - Doctor Emmet L. Brown\015\012\015\012Select: \000"
 1474 0758 20455252 		.align	2
 1474      4F522120 
 1474      50726F67 
 1474      72616D20 
 1474      66696C65 
 1475 077a 0000     	.LC49:
 1476              		.ascii	" Invalid operation!\015\012Try again: \000"
 1477 077c 20446F77 		.align	2
 1477      6E6C6F61 
 1477      6420636F 
 1477      6D706C65 
 1477      7465640D 
 1478 0792 0000     	.LC50:
 1479              		.ascii	"\015\012\015\012-> Starting application...\015\012\015"
 1480 0794 57726974 		.ascii	"\012\000"
 1480      696E6720 
 1480      62756666 
 1480      65722074 
 1480      6F206932 
 1481              		.align	2
 1482              	.LC51:
 1483 07b4 20436F6D 		.ascii	"\015\012\015\012-> disable write-through strategy.."
 1483      706C6574 
 1483      65640D0A 
 1483      0D0A00
 1484 07c3 00       		.ascii	".\015\012\015\012\000"
 1485              		.align	2
 1486 07c4 20496E76 	.LC52:
 1486      616C6964 
 1486      20626F6F 
 1486      74206465 
 1486      76696365 
 1487 07e6 0000     		.ascii	"\015\012\015\012-> jump to application...\015\012\015"
 1488              		.ascii	"\012\000"
 1489 07e8 53656C65 		.align	2
 1489      63743A20 
 1489      00
 1490 07f1 000000   	.LC53:
 1491              		.ascii	"!!should not be here!!\015\012\000"
 1492 07f4 0D0A0D0A 		.align	2
 1492      456E7465 
 1492      72206465 
 1492      76696365 
 1492      20616464 
 1493 081b 73657420 	.LC54:
 1493      4C534220 
 1493      746F2027 
 1493      3027293A 
 1493      2000
 1494 082d 000000   		.ascii	"\015\012\015\012Aborted!\000"
 1495              		.text
 1496 0830 0D0A0D0A 		.align	2
 1496      41626F72 
 1496      74206475 
 1496      6D70696E 
 1496      67206279 
 1497 0857 4966206E 		.global	main
 1497      6F206461 
 1497      74612069 
 1497      73207368 
 1497      6F776E2C 
 1499              	main:
 1500 0870 74686520 	.LFB35:
 1500      73656C65 
 1500      63746564 
 1500      20646576 
 1500      69636520 
 1501 08a3 7920746F 		.loc 4 79 0
 1501      20636F6E 
 1501      74696E75 
 1501      652E0D0A 
 1501      0D0A00
 1502 08b6 0000     		@ args = 0, pretend = 0, frame = 20
 1503              		@ frame_needed = 0, uses_anonymous_args = 0
 1504 08b8 0D0A0D0A 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1504      4175746F 
 1504      6D617469 
 1504      6320626F 
 1504      6F742063 
 1505 08df 7765722D 	.LCFI9:
 1505      75703A0D 
 1505      0A00
 1506 08e9 000000   		.loc 4 85 0
 1507              		mov	r0, #0
 1508 08ec 5B333231 		.loc 4 79 0
 1508      305D2063 
 1508      6F6E6669 
 1508      67757261 
 1508      74696F6E 
 1509 0919 7420626F 		sub	sp, sp, #24
 1509      6F746C6F 
 1509      61646572 
 1509      20636F6E 
 1509      736F6C65 
 1510 0946 66726F6D 	.LCFI10:
 1510      20636F72 
 1510      65205241 
 1510      4D0D0A00 
 1511 0956 0000     		.loc 4 85 0
 1512              		bl	io_set_gpio0_port
 1513 0958 20303031 		.loc 4 86 0
 1513      30202D20 
 1513      4175746F 
 1513      6D617469 
 1513      6320626F 
 1514 098b 30290D0A 		mov	r1, #13
 1514      0D0A5365 
 1514      6C656374 
 1514      3A2000
 1515 099a 0000     		mov	r0, #195
 1516              		bl	set_syscpreg
 1517 099c 0D0A0D0A 		.loc 4 89 0
 1517      5765276C 
 1517      6C207365 
 1517      6E642079 
 1517      6F752062 
 1518 09c3 212E0D0A 		mov	r0, #99
 1518      0D0A00
 1519 09ca 0000     		bl	io_i2c0_speed
 1520              		.loc 4 92 0
 1521 09cc 202D2044 		mov	r0, #6
 1521      6F63746F 
 1521      7220456D 
 1521      6D657420 
 1521      4C2E2042 
 1522 09f1 000000   		bl	get_syscpreg
 1523              		mov	r1, #6
 1524 09f4 20496E76 		orr	r0, r0, #8
 1524      616C6964 
 1524      206F7065 
 1524      72617469 
 1524      6F6E210D 
 1525 0a15 000000   		bl	set_syscpreg
 1526              		.loc 4 95 0
 1527 0a18 0D0A0D0A 		mov	r0, #13
 1527      2D3E2053 
 1527      74617274 
 1527      696E6720 
 1527      6170706C 
 1528 0a39 0A00     		bl	get_syscpreg
 1529 0a3b 00       		.loc 4 96 0
 1530              		mov	r0, r0, lsr #17
 1531 0a3c 0D0A0D0A 		mvn	r0, r0
 1531      2D3E2064 
 1531      69736162 
 1531      6C652077 
 1531      72697465 
 1532 0a63 2E0D0A0D 		and	r0, r0, #15
 1532      0A00
 1533 0a69 000000   		cmp	r0, #1
 1534              		moveq	r4, #48
 1535 0a6c 0D0A0D0A 	.LVL135:
 1535      2D3E206A 
 1535      756D7020 
 1535      746F2061 
 1535      70706C69 
 1536 0a8c 0A00     		addeq	sl, sp, #6
 1537 0a8e 0000     		addeq	r9, sp, #15
 1538              		beq	.L227
 1539 0a90 21217368 		cmp	r0, #2
 1539      6F756C64 
 1539      206E6F74 
 1539      20626520 
 1539      68657265 
 1540 0aa9 000000   		beq	.L343
 1541              		.loc 4 117 0
 1542 0aac 0D0A0D0A 		bl	help_info
 1542      41626F72 
 1542      74656421 
 1542      00
 1543 0ab9 000000   		.loc 4 119 0
 1544              		add	sl, sp, #6
 1545              		.loc 4 118 0
 1546              		ldr	r0, .L354
 1547              		bl	uart0_printf
 1548              		.loc 4 119 0
  74:main.c        **** 
  75:main.c        **** // ############################################################################################
  76:main.c        **** // STORM SoC Bootloader
  77:main.c        ****    int main(void)
  78:main.c        **** // ############################################################################################
  79:main.c        **** {
 1549              	f
 1550              		.loc 4 122 0
 1551              		ldr	r0, .L354+8
 1552 07dc E92D47F0 		bl	uart0_printf
 1553              		.loc 4 123 0
  80:main.c        **** 	int function_sel, data, i, start_app = 0;
  81:main.c        **** 	unsigned long *data_pointer, word_buffer, test_buffer, adr_buffer, end_address, cnt;
  82:main.c        **** 	unsigned char buffer[5], temp_string[9], char_tmp, *char_pointer, device_id;
  83:main.c        **** 	unsigned char buffer1[5], buffer2[5];
  84:main.c        **** 	// show reset ack
  85:main.c        **** 	io_set_gpio0_port(0);
 1554              	r1, sl
 1555 07e0 E3A00000 		mov	r2, #8
 1556              		mov	r0, #67108864
 1557 07e4 E24DD018 		bl	long_to_hex_string
 1558              		.loc 4 124 0
 1559              		mov	r0, sl
 1560 07e8 EBFFFFFE 		bl	uart0_printf
  86:main.c        **** 	set_syscpreg(0xC3, SYS_IO);
 1561              	 125 0
 1562 07ec E3A0100D 		ldr	r0, .L354+4
 1563 07f0 E3A000C3 		bl	uart0_printf
 1564 07f4 EBFFFFFE 		add	r9, sp, #15
  87:main.c        **** 
  88:main.c        **** 	// init I²C
  89:main.c        **** 	io_i2c0_speed(0x0063); // 100kHz
 1565              	136:
 1566 07f8 E3A00063 	.L228:
 1567 07fc EBFFFFFE 		.loc 4 130 0
  90:main.c        **** 
  91:main.c        **** 	// enable write-through strategy
  92:main.c        **** 	set_syscpreg(get_syscpreg(SYS_CTRL_0) | (1<<DC_WTHRU), SYS_CTRL_0);
 1568              		io_uart0_read_byte
 1569 0800 E3A00006 		mov	r4, r0
 1570 0804 EBFFFFFE 	.LVL137:
 1571 0808 E3A01006 	.L227:
 1572 080c E3800008 		.loc 4 135 0
 1573 0810 EBFFFFFE 		mov	r0, #13
  93:main.c        **** 
  94:main.c        **** 	// Check config switches for immediate boot-config
  95:main.c        **** 	function_sel = (int)((~(get_syscpreg(SYS_IO) >> 17)) & 0x0F);
 1574              	t_syscpreg
 1575 0814 E3A0000D 		tst	r0, #65536
 1576 0818 EBFFFFFE 		.loc 4 272 0
  96:main.c        **** 	switch(function_sel){
 1577              	veq	r6, #1
 1578 081c E1A008A0 	.LVL138:
 1579 0820 E1E00000 		moveq	r4, #160
 1580 0824 E200000F 	.LVL139:
 1581 0828 E3500001 		.loc 4 135 0
 1582 082c 03A04030 		bne	.L344
 1583              	.LVL140:
 1584 0830 028DA006 	.L270:
 1585 0834 028D900F 		.loc 4 278 0
 1586 0838 0A00001A 		mov	r5, #0
 1587 083c E3500002 	.LVL141:
 1588 0840 0A000077 		.loc 4 276 0
  97:main.c        **** 		case 1: function_sel = '0'; goto main_menu; break; // auto start application from RAM
  98:main.c        **** 		case 2: function_sel = '3'; goto main_menu; start_app = 1; device_id = 0xA0; break; // auto boot 
  99:main.c        **** 		default: break;
 100:main.c        **** 	}
 101:main.c        **** 
 102:main.c        **** 	// Intro screen
 103:main.c        **** 	// uart0_printf("\r\n\r\n\r\n+----------------------------------------------------------------+\r\
 104:main.c        **** 	// uart0_printf(            "|    <<< STORM Core Processor System - By Stephan Nolting >>>    |\r\
 105:main.c        **** 	// uart0_printf(            "+----------------------------------------------------------------+\r\
 106:main.c        **** 	// uart0_printf(            "|         Bootloader for STORM SoC   Version: 20120524-D         |\r\
 107:main.c        **** 	// uart0_printf(            "|               Contact: stnolting@googlemail.com                |\r\
 108:main.c        **** 	// uart0_printf(            "+----------------------------------------------------------------+\r\
 109:main.c        **** 
 110:main.c        **** 	// uart0_printf(            " < Welcome to the STORM SoC bootloader console! >\r\n < Select an ope
 111:main.c        **** 	// uart0_printf(            " < the boot key for immediate application start. >\r\n\r\n");
 112:main.c        **** 
 113:main.c        **** 	// // Console menu
 114:main.c        **** 	// uart0_printf(" 0 - boot from core RAM (start application)\r\n 1 - program core RAM via UART_0\r
 115:main.c        **** 	// uart0_printf(" 3 - boot from I2C EEPROM\r\n 4 - program I2C EEPROM via UART_0\r\n 5 - show cont
 116:main.c        **** 	// uart0_printf(" a - automatic boot configuration\r\n h - help\r\n r - restart system\r\n\r\nSele
 117:main.c        **** 	help_info();
 1589              	54+12
 1590 0844 EBFFFFFE 		bl	uart0_printf
 118:main.c        **** 	uart0_printf("Address of adr_buffer: ");
 119:main.c        **** 	long_to_hex_string(&adr_buffer, temp_string, 8);
 1591              	VL142:
 1592 0848 E28DA006 		.loc 4 278 0
 1593              		mov	r1, r4
 1594 084c E59F0808 		mov	r2, r5
 1595 0850 EBFFFFFE 		mov	r3, #2
 1596              		mov	r0, #114
 1597 0854 E1A0100A 		str	r5, [sp, #0]
 1598 0858 E3A02008 		bl	io_i2c0_byte_transfer
 1599 085c E28D0014 		.loc 4 279 0
 1600 0860 EBFFFFFE 		mov	r1, r4
 120:main.c        **** 	uart0_printf(temp_string);
 1601              	8 0
 1602 0864 E1A0000A 		strb	r0, [sp, #15]
 1603 0868 EBFFFFFE 		.loc 4 279 0
 121:main.c        **** 	uart0_printf(" \n\r ");
 1604              	v	r2, #1
 1605 086c E59F07EC 		mov	r3, #2
 1606 0870 EBFFFFFE 		mov	r0, #114
 122:main.c        **** 	uart0_printf(" Load Address: ");
 1607              	r	r5, [sp, #0]
 1608 0874 E59F07E8 		bl	io_i2c0_byte_transfer
 1609 0878 EBFFFFFE 		.loc 4 280 0
 123:main.c        **** 	long_to_hex_string(JUMPADDRESS, temp_string, 8);
 1610              	v	r2, #2
 1611 087c E1A0100A 		mov	r3, r2
 1612 0880 E3A02008 		.loc 4 279 0
 1613 0884 E3A00301 		strb	r0, [sp, #16]
 1614 0888 EBFFFFFE 		.loc 4 280 0
 124:main.c        **** 	uart0_printf(temp_string);
 1615              	r1, r4
 1616 088c E1A0000A 		mov	r0, #114
 1617 0890 EBFFFFFE 		str	r5, [sp, #0]
 125:main.c        **** 	uart0_printf(" \n\r ");
 1618              		io_i2c0_byte_transfer
 1619 0894 E59F07C4 		.loc 4 281 0
 1620 0898 EBFFFFFE 		mov	r3, #2
 1621 089c E28D900F 		.loc 4 280 0
 1622              		strb	r0, [sp, #17]
 1623              		.loc 4 281 0
 126:main.c        **** 	
 127:main.c        **** 	while(1){
 128:main.c        **** 
 129:main.c        **** 		// console input
 130:main.c        **** 		function_sel = io_uart0_read_byte();
 1624              	1, r4
 1625 08a0 EBFFFFFE 		mov	r0, #114
 1626 08a4 E1A04000 		mov	r2, #3
 1627              		str	r5, [sp, #0]
 1628              		bl	io_i2c0_byte_transfer
 131:main.c        **** 
 132:main.c        **** main_menu:
 133:main.c        **** 
 134:main.c        **** 		// boot button
 135:main.c        **** 		if (((get_syscpreg(SYS_IO) >> 16) & 0x01) == 0){
 1629              	 4 282 0
 1630 08a8 E3A0000D 		ldrb	r3, [sp, #15]	@ zero_extendqisi2
 1631 08ac EBFFFFFE 		.loc 4 281 0
 1632 08b0 E3100801 		and	r0, r0, #255
 136:main.c        **** 			function_sel = '3';
 137:main.c        **** 			start_app    = 1;
 138:main.c        **** 			device_id    = 0xA0;
 139:main.c        **** 		}
 140:main.c        **** 
 141:main.c        **** 		// main functions
 142:main.c        **** 		switch(function_sel){
 143:main.c        **** 			// case 't':
 144:main.c        **** 				 // io_uart0_send_byte((char)function_sel);
 145:main.c        **** 				 // uart0_printf("\r\n\r\nApplication HEADDtest_buffer.\r\n");
 146:main.c        **** 				// uart0_scanf(buffer1,4,0); // get storm master boot record code
 147:main.c        **** 				
 148:main.c        **** 				// uart0_scanf(buffer2,4,0); // get image size
 149:main.c        **** 				
 150:main.c        **** 				// uart0_printf("HEADER:");
 151:main.c        **** 				// test_buffer = qbytes_to_long(buffer1);
 152:main.c        **** 				// long_to_hex_string(test_buffer, temp_string,8);
 153:main.c        **** 				// uart0_printf(temp_string);
 154:main.c        **** 				// uart0_printf("!\n\r");
 155:main.c        **** 
 156:main.c        **** 				// uart0_printf("how big:");
 157:main.c        **** 				// test_buffer = qbytes_to_long(buffer2);
 158:main.c        **** 				// long_to_hex_string(test_buffer, temp_string,8);
 159:main.c        **** 				// uart0_printf(temp_string);
 160:main.c        **** 				// uart0_printf("!\n\r");
 161:main.c        **** 				
 162:main.c        **** 				// break;
 163:main.c        **** 			// boot from RAM (start application)
 164:main.c        **** 			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 165:main.c        **** 			case '0':
 166:main.c        **** 				io_uart0_send_byte((char)function_sel);
 167:main.c        **** 				start_app = 1;
 168:main.c        **** 				break;
 169:main.c        **** 
 170:main.c        **** 			// load ram via UART0
 171:main.c        **** 			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 172:main.c        **** 			case '1':
 173:main.c        **** 				io_uart0_send_byte((char)function_sel);
 174:main.c        **** 				uart0_printf("\r\n\r\nApplication will start automatically after download.\r\n-> Waiting for 's
 175:main.c        **** 				uart0_scanf(buffer,4,0); // get storm master boot record code
 176:main.c        **** 				if((buffer[0] == 'S') && (buffer[1] == 'M') && (buffer[2] == 'B') && (buffer[3] == 'R')){
 177:main.c        **** 					//asm volatile ("NOP");asm volatile ("NOP");
 178:main.c        **** 					uart0_scanf(buffer,4,0); // get image size
 179:main.c        **** 				// test_buffer = qbytes_to_long(buffer);
 180:main.c        **** 				// long_to_hex_string(test_buffer, temp_string,8);
 181:main.c        **** 				// uart0_printf(temp_string);
 182:main.c        **** 				// uart0_printf("!\n\r");
 183:main.c        **** 					adr_buffer = qbytes_to_long(buffer);
 184:main.c        **** 					//long_to_hex_string(adr_buffer, temp_string,8);
 185:main.c        **** 					
 186:main.c        **** 					#ifdef SRAM
 187:main.c        **** 					if (adr_buffer > RAM_SIZE-8){
 188:main.c        **** 						uart0_printf(" SRAM ERROR! Program file too big!\r\n\r\n");
 189:main.c        **** 						break;
 190:main.c        **** 					}
 191:main.c        **** 					#else
 192:main.c        **** 						if (adr_buffer > XRAM_SIZE-8){
 193:main.c        **** 						uart0_printf(" SDRAM ERROR! Program file too big!\r\n\r\n");
 194:main.c        **** 						break;
 195:main.c        **** 					}
 196:main.c        **** 					#endif
 197:main.c        **** 					data_pointer = JUMPADDRESS;
 198:main.c        **** 					end_address = (adr_buffer + 4 + (unsigned long) JUMPADDRESS);
 199:main.c        **** 					
 200:main.c        **** 				 // long_to_hex_string(end_address, temp_string,8);
 201:main.c        **** 				 // uart0_printf(temp_string);
 202:main.c        **** 				 // uart0_printf("!\n\r");
 203:main.c        **** 
 204:main.c        **** 					while( (data_pointer) != end_address ){ // Adjust for address offset.
 205:main.c        **** 						uart0_scanf(buffer,4,0); // get word
 206:main.c        **** 						*data_pointer = qbytes_to_long(buffer); // store memory entry
 207:main.c        **** 						data_pointer = data_pointer + 1;
 208:main.c        **** 
 209:main.c        **** 
 210:main.c        **** 						// if (data_pointer > JUMPADDRESS + 0xA30){
 211:main.c        **** 							// long_to_hex_string(data_pointer, temp_string,8);
 212:main.c        **** 							// uart0_printf(temp_string);
 213:main.c        **** 							// uart0_printf("!\n\r");
 214:main.c        **** 						// }
 215:main.c        **** 
 216:main.c        **** 
 217:main.c        **** 
 218:main.c        **** 					}
 219:main.c        **** 					uart0_printf("Last mem access: ");
 220:main.c        **** 					long_to_hex_string(data_pointer, temp_string,8);
 221:main.c        **** 					uart0_printf(temp_string);
 222:main.c        **** 					uart0_printf("!\n\r");
 223:main.c        **** 					uart0_printf("Done Loading!\r\n");
 224:main.c        **** 				uart0_printf("LAST ADDRESS:");
 225:main.c        **** 				long_to_hex_string(data_pointer, temp_string,8);
 226:main.c        **** 				uart0_printf(temp_string);
 227:main.c        **** 				uart0_printf("!\n\r");
 228:main.c        **** 		
 229:main.c        **** 					start_app = 0;
 230:main.c        **** 				}
 231:main.c        **** 				else
 232:main.c        **** 					uart0_printf(" Invalid programming file!\r\n\r\nSelect: ");
 233:main.c        **** 				break;
 234:main.c        **** 
 235:main.c        **** 			// ram memory dump
 236:main.c        **** 			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 237:main.c        **** 			case '2':
 238:main.c        **** 				io_uart0_send_byte((char)function_sel);
 239:main.c        **** 				uart0_printf("\r\n\r\nAbort dumping by pressing any key.\r\nPress any key to continue.\r\n\r\n"
 240:main.c        **** 				while(io_uart0_read_byte() == -1);
 241:main.c        **** 				while(io_uart0_read_byte() != -1);
 242:main.c        **** 				data_pointer = (volatile unsigned long *)DUMPADDRESS;
 243:main.c        **** 				
 244:main.c        **** 				while(data_pointer < DUMPADDRESS +2532){
 245:main.c        **** 					word_buffer = *data_pointer;
 246:main.c        **** 					long_to_hex_string(word_buffer, temp_string,8);
 247:main.c        **** 					i=0;
 248:main.c        **** 					while (temp_string[i] != 0) {
 249:main.c        **** 						io_uart0_send_byte(temp_string[i]);
 250:main.c        **** 						i++;
 251:main.c        **** 					}
 252:main.c        **** 					io_uart0_send_byte(' ');
 253:main.c        **** 					data_pointer++;
 254:main.c        **** 					if(io_uart0_read_byte() != -1){
 255:main.c        **** 						break;
 256:main.c        **** 						uart0_printf("\r\n\r\nAborted!");
 257:main.c        **** 					}
 258:main.c        **** 				}
 259:main.c        **** 				uart0_printf("\r\n\r\nDumping completed.\r\n\r\nSelect: ");
 260:main.c        **** 				break;
 261:main.c        **** 
 262:main.c        **** 			// boot from I²C EEPROM
 263:main.c        **** 			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 264:main.c        **** 			case '3':
 265:main.c        **** 				if(start_app == 0){
 266:main.c        **** 					io_uart0_send_byte((char)function_sel);
 267:main.c        **** 					uart0_printf("\r\n\r\nEnter device address (2x hex_chars, set LSB to '0'): ");
 268:main.c        **** 					uart0_scanf(buffer,2,1);
 269:main.c        **** 					device_id = (unsigned char)hex_string_to_long(buffer, 2);
 270:main.c        **** 					if(device_id == 0){
 271:main.c        **** 						uart0_printf(" Invalid address!\r\n\r\nSelect: ");
 272:main.c        **** 						break;
 1633              	c 4 282 0
 1634 08b4 03A06001 		cmp	r3, #83
 1635              		.loc 4 281 0
 1636 08b8 03A040A0 		strb	r0, [sp, #18]
 1637              		.loc 4 282 0
 1638              		bne	.L271
 1639 08bc 1A00003C 		ldrb	r3, [sp, #16]	@ zero_extendqisi2
 1640              		cmp	r3, #77
 1641              		beq	.L345
 273:main.c        **** 					}
 274:main.c        **** 				}
 275:main.c        **** 
 276:main.c        **** 				uart0_printf("\r\nApplication will start automatically after upload.\r\n-> Loading boot image..
 277:main.c        **** 				cnt = 0;
 278:main.c        **** 				buffer[0] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 1642              	loc 4 301 0
 1643 08c0 E3A05000 		ldr	r0, .L354+16
 1644              		bl	uart0_printf
 1645              		.loc 4 459 0
 1646 08c4 E59F079C 		cmp	r6, #0
 1647 08c8 EBFFFFFE 		beq	.L228
 1648              	.LVL143:
 1649              	.L246:
 1650 08cc E1A01004 		.loc 4 465 0
 1651 08d0 E1A02005 		ldr	r0, .L354+20
 1652 08d4 E3A03002 		bl	uart0_printf
 1653 08d8 E3A00072 		.loc 4 466 0
 1654 08dc E58D5000 		mov	r1, #13
 1655 08e0 EBFFFFFE 		mov	r0, #0
 279:main.c        **** 				buffer[1] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 1656              	eg
 1657 08e4 E1A01004 		.loc 4 469 0
 1658              		ldr	r0, .L354+24
 1659 08e8 E5CD000F 		bl	uart0_printf
 1660              		.loc 4 470 0
 1661 08ec E3A02001 		mov	r0, #6
 1662 08f0 E3A03002 		bl	get_syscpreg
 1663 08f4 E3A00072 		mov	r1, #6
 1664 08f8 E58D5000 		bic	r0, r0, #8
 1665 08fc EBFFFFFE 		bl	set_syscpreg
 280:main.c        **** 				buffer[2] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 1666              	2 0
 1667 0900 E3A02002 		ldr	r0, .L354+28
 1668 0904 E1A03002 		bl	uart0_printf
 1669              		.loc 4 474 0
 1670 0908 E5CD0010 		mov	r0, #67108864
 1671              		bl	_jump_to_program
 1672 090c E1A01004 		.loc 4 476 0
 1673 0910 E3A00072 		ldr	r0, .L354+32
 1674 0914 E58D5000 		bl	uart0_printf
 1675 0918 EBFFFFFE 	.L312:
 281:main.c        **** 				buffer[3] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 1676              	LVL144:
 1677 091c E3A03002 	.L344:
 1678              	.LVL145:
 1679 0920 E5CD0011 		.loc 4 142 0
 1680              		cmp	r4, #52
 1681 0924 E1A01004 		beq	.L237
 1682 0928 E3A00072 		bgt	.L243
 1683 092c E3A02003 		cmp	r4, #49
 1684 0930 E58D5000 		beq	.L234
 1685 0934 EBFFFFFE 		ble	.L346
 282:main.c        **** 				if((buffer[0] == 'S') && (buffer[1] == 'M') && (buffer[2] == 'B') && (buffer[3] == 'R')){
 1686              	50
 1687 0938 E5DD300F 		beq	.L235
 1688              		cmp	r4, #51
 1689 093c E20000FF 		bne	.L231
 1690              		.loc 4 266 0
 1691 0940 E3530053 		mov	r0, r4
 1692              		bl	io_uart0_send_byte
 1693 0944 E5CD0012 		.loc 4 267 0
 1694              		ldr	r0, .L354+36
 1695 0948 1A000002 		bl	uart0_printf
 1696 094c E5DD3010 		.loc 4 268 0
 1697 0950 E353004D 		mov	r0, r9
 1698 0954 0A00006A 		mov	r1, #2
 1699              		mov	r2, #1
 283:main.c        **** 					buffer[0] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 284:main.c        **** 					buffer[1] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 285:main.c        **** 					buffer[2] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 286:main.c        **** 					buffer[3] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 287:main.c        **** 					adr_buffer = qbytes_to_long(buffer);
 288:main.c        **** 					data_pointer = 0;
 289:main.c        **** 					while((data_pointer != adr_buffer+4) && (data_pointer < IRAM_SIZE)){
 290:main.c        **** 						buffer[0] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 291:main.c        **** 						buffer[1] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 292:main.c        **** 						buffer[2] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 293:main.c        **** 						buffer[3] = (unsigned char)io_i2c0_byte_transfer('r',device_id,cnt++,2,0x00);
 294:main.c        **** 						*data_pointer = qbytes_to_long(buffer); // store memory entry
 295:main.c        **** 						data_pointer = data_pointer + 1;
 296:main.c        **** 					}
 297:main.c        **** 					uart0_printf(" Upload complete\r\n");
 298:main.c        **** 					start_app = 1;
 299:main.c        **** 				}
 300:main.c        **** 				else
 301:main.c        **** 					uart0_printf(" Invalid boot device or file!\r\n\r\nSelect: ");
 1700              	f
 1701 0958 E59F070C 		.loc 4 269 0
 1702 095c EBFFFFFE 		mov	r1, #2
 302:main.c        **** 				break;
 303:main.c        **** 
 304:main.c        **** 			// program I²C EEPROM
 305:main.c        **** 			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 306:main.c        **** 			case '4':
 307:main.c        **** 				io_uart0_send_byte((char)function_sel);
 308:main.c        **** 				uart0_printf("\r\n\r\nEnter device address (2x hex_chars, set LSB to '0'): ");
 309:main.c        **** 				uart0_scanf(buffer,2,1);
 310:main.c        **** 				device_id = (unsigned char)hex_string_to_long(buffer, 2);
 311:main.c        **** 				if(device_id == 0){
 312:main.c        **** 					uart0_printf("\r\nInvalid address!\r\n\r\nSelect: ");
 313:main.c        **** 					break;
 314:main.c        **** 				}
 315:main.c        **** 
 316:main.c        **** 				uart0_printf("\r\nData will overwrite RAM content!\r\n-> Waiting for 'storm_program.bin' in byt
 317:main.c        **** 				uart0_scanf(buffer,4,0);
 318:main.c        **** 				if((buffer[0]=='S') && (buffer[1]=='M') && (buffer[2]=='B') && (buffer[3]=='R')){
 319:main.c        **** 					char_pointer = 0; // beginning of RAM
 320:main.c        **** 					*char_pointer++ = 'S'; asm volatile ("NOP");
 321:main.c        **** 					*char_pointer++ = 'M'; asm volatile ("NOP");
 322:main.c        **** 					*char_pointer++ = 'B'; asm volatile ("NOP");
 323:main.c        **** 					*char_pointer++ = 'R'; asm volatile ("NOP");
 324:main.c        **** 					uart0_scanf(buffer,4,0);
 325:main.c        **** 					*char_pointer++ = buffer[0];
 326:main.c        **** 					*char_pointer++ = buffer[1];
 327:main.c        **** 					*char_pointer++ = buffer[2];
 328:main.c        **** 					*char_pointer++ = buffer[3];
 329:main.c        **** 					cnt = qbytes_to_long(buffer);
 330:main.c        **** 					if(cnt > 0xFFFC){
 331:main.c        **** 						uart0_printf(" ERROR! Program file too big!\r\n\r\n");
 332:main.c        **** 						break;
 333:main.c        **** 					}
 334:main.c        **** 
 335:main.c        **** 					for(i=0; i<cnt+4; i++){
 336:main.c        **** 						data = -1;
 337:main.c        **** 						while(data == -1)
 338:main.c        **** 							data = io_uart0_read_byte();
 339:main.c        **** 						*char_pointer++ = (unsigned char)data;
 340:main.c        **** 					}
 341:main.c        **** 					uart0_printf(" Download completed\r\n");
 342:main.c        **** 
 343:main.c        **** 					uart0_printf("Writing buffer to i2c EEPROM...");
 344:main.c        **** 					char_pointer = 0; // beginning of RAM
 345:main.c        **** 					for(i=0; i<cnt+12; i++){
 346:main.c        **** 						char_tmp = *char_pointer++;
 347:main.c        **** 						while(io_i2c0_byte_transfer('w', device_id, i, 2, char_tmp) != 0);
 348:main.c        **** 					}
 349:main.c        **** 					uart0_printf(" Completed\r\n\r\n");
 350:main.c        **** 				}
 351:main.c        **** 				else
 352:main.c        **** 					uart0_printf(" Invalid boot device or file!\r\n\r\n");
 353:main.c        **** 				uart0_printf("Select: ");
 354:main.c        **** 				break;
 355:main.c        **** 
 356:main.c        **** 			// show content of I2C EEPROM
 357:main.c        **** 			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 358:main.c        **** 			case '5':
 359:main.c        **** 				io_uart0_send_byte((char)function_sel);
 360:main.c        **** 				uart0_printf("\r\n\r\nEnter device address (2 hex-chars, set LSB to '0'): ");
 361:main.c        **** 				uart0_scanf(buffer,2,1);
 362:main.c        **** 				device_id = (unsigned char)hex_string_to_long(buffer, 2);
 363:main.c        **** 				if(device_id == 0){
 364:main.c        **** 					uart0_printf(" Invalid address!\r\n\r\nSelect: ");
 365:main.c        **** 					break;
 366:main.c        **** 				}
 367:main.c        **** 				uart0_printf("\r\n\r\nAbort dumping by pressing any key. If no data is shown,\r\n");
 368:main.c        **** 				uart0_printf("the selected device is not responding. Press any key to continue.\r\n\r\n");
 369:main.c        **** 				while(io_uart0_read_byte() == -1);
 370:main.c        **** 				while(io_uart0_read_byte() != -1);
 371:main.c        **** 				for(i=0; i<0xFFFF; i++){
 372:main.c        **** 						data = -1;
 373:main.c        **** 						while(data < 0){
 374:main.c        **** 							data = io_i2c0_byte_transfer('r', device_id, i, 2, 0x00);
 375:main.c        **** 							if(io_uart0_read_byte() != -1){
 376:main.c        **** 								function_sel = 'X';
 377:main.c        **** 								break;
 378:main.c        **** 							}
 379:main.c        **** 						}
 380:main.c        **** 						if(function_sel == 'X'){
 381:main.c        **** 							uart0_printf("\r\n\r\nAborted!");
 382:main.c        **** 							break;
 383:main.c        **** 						}
 384:main.c        **** 						io_uart0_send_byte(data);
 385:main.c        **** 				}
 386:main.c        **** 				uart0_printf("\r\n\r\nDumping completed.\r\n\r\nSelect: ");
 387:main.c        **** 				break;
 388:main.c        **** 
 389:main.c        **** 			// Automatic boot configuration
 390:main.c        **** 			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 391:main.c        **** 			case 'a':
 392:main.c        **** 				io_uart0_send_byte((char)function_sel);
 393:main.c        **** 				uart0_printf("\r\n\r\nAutomatic boot configuration for power-up:\r\n");
 394:main.c        **** 				uart0_printf("[3210] configuration DIP switch\r\n 0000 - Start bootloader console\r\n 0001 - Au
 395:main.c        **** 				uart0_printf(" 0010 - Automatic boot from I2C EEPROM (Address 0xA0)\r\n\r\nSelect: ");
 396:main.c        **** 				break;
 397:main.c        **** 
 398:main.c        **** 			// Help screen
 399:main.c        **** 			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 400:main.c        **** 			case 'h':
 401:main.c        **** 				io_uart0_send_byte((char)function_sel);
 402:main.c        **** //				io_uart0_send_byte((char)function_sel);
 403:main.c        **** 
 404:main.c        **** 				help_info();
 405:main.c        **** 				// uart0_printf("\r\n\r\nSTORM SoC bootloader\r\n");
 406:main.c        **** 				// uart0_printf("'0': Execute program in RAM.\r\n");
 407:main.c        **** 				// uart0_printf("'1': Write 'storm_program.bin' to the core's RAM via UART.\r\n");
 408:main.c        **** 				// uart0_printf("'2': Print current content of complete core RAM.\r\n");
 409:main.c        **** 				// uart0_printf("'3': Load boot image from EEPROM and start application.\r\n");
 410:main.c        **** 				// uart0_printf("'4': Write 'storm_program.bin' to I2C EEPROM via UART.\r\n");
 411:main.c        **** 				// uart0_printf("'5': Print content of I2C EEPROM.\r\n");
 412:main.c        **** 				// uart0_printf("'a': Show DIP switch configurations for automatic boot.\r\n");
 413:main.c        **** 				// uart0_printf("'h': Show this screen.\r\n");
 414:main.c        **** 				// uart0_printf("'r': Reset system.\r\n\r\n");
 415:main.c        **** 				// uart0_printf("Boot EEPROM: 24xxnnn (like 24AA64), 7 bit address + dont-care bit,\r\n");
 416:main.c        **** 				// uart0_printf("connected to I2C_CONTROLLER_0, operating frequency is 100kHz,\r\n");
 417:main.c        **** 				// uart0_printf("maximum EEPROM size = 65536 byte => 16 bit addresses,\r\n");
 418:main.c        **** 				// uart0_printf("fixed boot device address: 0xA0\r\n\r\n");
 419:main.c        **** 				// uart0_printf("Terminal setup: 9600 baud, 8 data bits, no parity, 1 stop bit\r\n\r\n");
 420:main.c        **** 				// uart0_printf("For more information see the STORM Core / STORM SoC datasheet\r\n");
 421:main.c        **** 				// uart0_printf("http://opencores.org/project,storm_core\r\n");
 422:main.c        **** 				// uart0_printf("http://opencores.org/project,storm_soc\r\n");
 423:main.c        **** 				// uart0_printf("Contact: stnolting@googlemail.com\r\n");
 424:main.c        **** 				// uart0_printf("(c) 2012 by Stephan Nolting\r\n\r\nSelect: ");
 425:main.c        **** 				break;
 426:main.c        **** 
 427:main.c        **** 			// back to the future
 428:main.c        **** 			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 429:main.c        **** 			case 'f':
 430:main.c        **** 				io_uart0_send_byte((char)function_sel);
 431:main.c        **** 				uart0_printf("\r\n\r\nWe'll send you back - to the future!.\r\n\r\n");
 432:main.c        **** 				uart0_printf(" - Doctor Emmet L. Brown\r\n\r\nSelect: ");
 433:main.c        **** 				break;
 434:main.c        **** 
 435:main.c        **** 			// restart system
 436:main.c        **** 			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 437:main.c        **** 			case 'r':
 438:main.c        **** 				io_uart0_send_byte((char)function_sel);
 439:main.c        **** 				asm volatile ("mov r0,     #0x0FF00000");
 440:main.c        **** 				asm volatile ("add pc, r0, #0xF0000000"); // jump to bootloader
 441:main.c        **** 				while(1);
 442:main.c        **** 				break;
 443:main.c        **** 
 444:main.c        **** 			// no input
 445:main.c        **** 			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 446:main.c        **** 			case -1:
 447:main.c        **** 				break;
 448:main.c        **** 
 449:main.c        **** 			// invalid selection
 450:main.c        **** 			// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 451:main.c        **** 			default:
 452:main.c        **** 				io_uart0_send_byte((char)function_sel);
 453:main.c        **** 				uart0_printf(" Invalid operation!\r\nTry again: ");
 454:main.c        **** 				break;
 455:main.c        **** 
 456:main.c        **** 		}
 457:main.c        **** 
 458:main.c        **** 		// start application request
 459:main.c        **** 		if(start_app != 0)
 1703              	v	r0, r9
 1704 0960 E3560000 		bl	hex_string_to_long
 1705 0964 0AFFFFCD 		.loc 4 270 0
 1706              		ands	r1, r0, #255
 1707              	.LVL146:
 460:main.c        **** 			break;
 461:main.c        **** 
 462:main.c        **** 	}
 463:main.c        **** 
 464:main.c        **** 	// start application
 465:main.c        **** 	uart0_printf("\r\n\r\n-> Starting application...\r\n\r\n");
 1708              	e	r4, r1
 1709 0968 E59F0700 	.LVL147:
 1710 096c EBFFFFFE 		movne	r6, #0
 466:main.c        **** 	set_syscpreg(0x00, SYS_IO);
 1711              	e	.L270
 1712 0970 E3A0100D 	.LVL148:
 1713 0974 E3A00000 	.L340:
 1714 0978 EBFFFFFE 		.loc 4 364 0
 467:main.c        **** 
 468:main.c        **** 	// disable write-through strategy
 469:main.c        **** 	uart0_printf("\r\n\r\n-> disable write-through strategy...\r\n\r\n");
 1715              		r0, .L354+40
 1716 097c E59F06F0 		bl	uart0_printf
 1717 0980 EBFFFFFE 	.LVL149:
 470:main.c        **** 	set_syscpreg(get_syscpreg(SYS_CTRL_0) & ~(1<<DC_WTHRU), SYS_CTRL_0);
 1718              	.L228
 1719 0984 E3A00006 	.LVL150:
 1720 0988 EBFFFFFE 	.L343:
 1721 098c E3A01006 		.loc 4 96 0
 1722 0990 E3C00008 		mov	r4, #51
 1723 0994 EBFFFFFE 		add	sl, sp, #6
 471:main.c        **** 
 472:main.c        **** 	uart0_printf("\r\n\r\n-> jump to application...\r\n\r\n");
 1724              	9, sp, #15
 1725 0998 E59F06D8 		b	.L227
 1726 099c EBFFFFFE 	.LVL151:
 473:main.c        **** 	// jump to application
 474:main.c        **** 	_jump_to_program(JUMPADDRESS);
 1727              	43:
 1728 09a0 E3A00301 		.loc 4 142 0
 1729 09a4 EBFFFFFE 		cmp	r4, #102
 475:main.c        **** //	asm volatile ("mov pc, #0");
 476:main.c        **** 	uart0_printf("!!should not be here!!\r\n");
 1730              	q	.L240
 1731 09a8 E59F06CC 		ble	.L347
 1732 09ac EBFFFFFE 		cmp	r4, #104
 1733              		beq	.L241
 1734 09b0 EAFFFFFE 		cmp	r4, #114
 1735              		bne	.L231
 1736              		.loc 4 438 0
 1737              		mov	r0, r4
 1738              		bl	io_uart0_send_byte
 1739 09b4 E3540034 		.loc 4 439 0
 1740 09b8 0A000029 		mov r0,     #0x0FF00000
 1741 09bc CA00001C 		.loc 4 440 0
 1742 09c0 E3540031 		add pc, r0, #0xF0000000
 1743 09c4 0A000036 	.L311:
 1744 09c8 DA00009B 		b	.L311
 1745 09cc E3540032 	.L237:
 1746 09d0 0A0000A5 		.loc 4 307 0
 1747 09d4 E3540033 		mov	r0, r4
 1748 09d8 1A00009B 		bl	io_uart0_send_byte
 1749              		.loc 4 308 0
 1750 09dc E1A00004 		ldr	r0, .L354+36
 1751 09e0 EBFFFFFE 		bl	uart0_printf
 1752              		.loc 4 309 0
 1753 09e4 E59F0694 		mov	r0, r9
 1754 09e8 EBFFFFFE 		mov	r1, #2
 1755              		mov	r2, #1
 1756 09ec E1A00009 		bl	uart0_scanf
 1757 09f0 E3A01002 		.loc 4 310 0
 1758 09f4 E3A02001 		mov	r0, r9
 1759 09f8 EBFFFFFE 		mov	r1, #2
 1760              		bl	hex_string_to_long
 1761 09fc E3A01002 		.loc 4 311 0
 1762 0a00 E1A00009 		ands	r8, r0, #255
 1763 0a04 EBFFFFFE 		bne	.L280
 1764              		.loc 4 312 0
 1765 0a08 E21010FF 		ldr	r0, .L354+44
 1766              		bl	uart0_printf
 1767 0a0c 11A04001 		b	.L228
 1768              	.L234:
 1769 0a10 13A06000 		.loc 4 173 0
 1770 0a14 1AFFFFA9 		mov	r0, r4
 1771              		bl	io_uart0_send_byte
 1772              		.loc 4 174 0
 1773              		ldr	r0, .L354+48
 1774 0a18 E59F0664 		bl	uart0_printf
 1775 0a1c EBFFFFFE 		.loc 4 175 0
 1776              		mov	r0, r9
 1777 0a20 EAFFFF9E 		mov	r1, #4
 1778              		mov	r2, #0
 1779              		bl	uart0_scanf
 1780              		.loc 4 176 0
 1781 0a24 E3A04033 		ldrb	r3, [sp, #15]	@ zero_extendqisi2
 1782 0a28 E28DA006 		cmp	r3, #83
 1783 0a2c E28D900F 		bne	.L247
 1784 0a30 EAFFFF9C 		ldrb	r3, [sp, #16]	@ zero_extendqisi2
 1785              		cmp	r3, #77
 1786              		beq	.L348
 1787              	.L247:
 1788 0a34 E3540066 		.loc 4 232 0
 1789 0a38 0A00002A 		ldr	r0, .L354+52
 1790 0a3c DA0000B0 		bl	uart0_printf
 1791 0a40 E3540068 		b	.L228
 1792 0a44 0A000112 	.L240:
 1793 0a48 E3540072 		.loc 4 430 0
 1794 0a4c 1A00007E 		mov	r0, r4
 1795              		bl	io_uart0_send_byte
 1796 0a50 E1A00004 		.loc 4 431 0
 1797 0a54 EBFFFFFE 		ldr	r0, .L354+56
 1798              		bl	uart0_printf
 1799 0a58 E3A006FF 		.loc 4 432 0
 1800              		ldr	r0, .L354+60
 1801 0a5c E280F20F 		bl	uart0_printf
 1802              		b	.L228
 1803 0a60 EAFFFFFE 	.LVL152:
 1804              	.L345:
 1805              		.loc 4 282 0
 1806 0a64 E1A00004 		ldrb	r3, [sp, #17]	@ zero_extendqisi2
 1807 0a68 EBFFFFFE 		cmp	r3, #66
 1808              		bne	.L271
 1809 0a6c E59F060C 		cmp	r0, #82
 1810 0a70 EBFFFFFE 		bne	.L271
 1811              		.loc 4 283 0
 1812 0a74 E1A00009 		mov	r1, r4
 1813 0a78 E3A01002 		mov	r2, #4
 1814 0a7c E3A02001 		sub	r3, r3, #64
 1815 0a80 EBFFFFFE 		add	r0, r0, #32
 1816              		str	r5, [sp, #0]
 1817 0a84 E1A00009 		bl	io_i2c0_byte_transfer
 1818 0a88 E3A01002 		.loc 4 284 0
 1819 0a8c EBFFFFFE 		mov	r1, r4
 1820              		.loc 4 283 0
 1821 0a90 E21080FF 		strb	r0, [sp, #15]
 1822 0a94 1A0000A7 		.loc 4 284 0
 1823              		mov	r2, #5
 1824 0a98 E59F05E8 		mov	r3, #2
 1825 0a9c EBFFFFFE 		mov	r0, #114
 1826 0aa0 EAFFFF7E 		str	r5, [sp, #0]
 1827              		bl	io_i2c0_byte_transfer
 1828              		.loc 4 285 0
 1829 0aa4 E1A00004 		mov	r1, r4
 1830 0aa8 EBFFFFFE 		.loc 4 284 0
 1831              		strb	r0, [sp, #16]
 1832 0aac E59F05D8 		.loc 4 285 0
 1833 0ab0 EBFFFFFE 		mov	r2, #6
 1834              		mov	r3, #2
 1835 0ab4 E1A00009 		mov	r0, #114
 1836 0ab8 E3A01004 		str	r5, [sp, #0]
 1837 0abc E3A02000 		bl	io_i2c0_byte_transfer
 1838 0ac0 EBFFFFFE 		.loc 4 286 0
 1839              		mov	r1, r4
 1840 0ac4 E5DD300F 		.loc 4 285 0
 1841 0ac8 E3530053 		strb	r0, [sp, #17]
 1842 0acc 1A000002 		.loc 4 286 0
 1843 0ad0 E5DD3010 		mov	r2, #7
 1844 0ad4 E353004D 		mov	r3, #2
 1845 0ad8 0A0000F1 		mov	r0, #114
 1846              		str	r5, [sp, #0]
 1847              		bl	io_i2c0_byte_transfer
 1848 0adc E59F05AC 		strb	r0, [sp, #18]
 1849 0ae0 EBFFFFFE 		.loc 4 287 0
 1850 0ae4 EAFFFF6D 		mov	r0, r9
 1851              		bl	qbytes_to_long
 1852              		.loc 4 289 0
 1853 0ae8 E1A00004 		cmn	r0, #4
 1854 0aec EBFFFFFE 		.loc 4 287 0
 1855              		str	r0, [sp, #20]
 1856 0af0 E59F059C 		.loc 4 289 0
 1857 0af4 EBFFFFFE 		beq	.L276
 1858              	.LVL153:
 1859 0af8 E59F0598 		mov	r6, r5
 1860 0afc EBFFFFFE 	.LVL154:
 1861 0b00 EAFFFF66 	.LVL155:
 1862              	.L278:
 1863              		.loc 4 290 0
 1864              		add	r2, r5, #8
 1865 0b04 E5DD3011 		mov	r1, r4
 1866 0b08 E3530042 		mov	r3, #2
 1867 0b0c 1AFFFF91 		mov	r0, #114
 1868 0b10 E3500052 		str	r6, [sp, #0]
 1869 0b14 1AFFFF8F 		bl	io_i2c0_byte_transfer
 1870              		.loc 4 291 0
 1871 0b18 E1A01004 		add	r2, r5, #9
 1872 0b1c E3A02004 		.loc 4 290 0
 1873 0b20 E2433040 		strb	r0, [sp, #15]
 1874 0b24 E2800020 		.loc 4 291 0
 1875 0b28 E58D5000 		mov	r1, r4
 1876 0b2c EBFFFFFE 		mov	r3, #2
 1877              		mov	r0, #114
 1878 0b30 E1A01004 		str	r6, [sp, #0]
 1879              		bl	io_i2c0_byte_transfer
 1880 0b34 E5CD000F 		.loc 4 292 0
 1881              		add	r2, r5, #10
 1882 0b38 E3A02005 		.loc 4 291 0
 1883 0b3c E3A03002 		strb	r0, [sp, #16]
 1884 0b40 E3A00072 		.loc 4 292 0
 1885 0b44 E58D5000 		mov	r1, r4
 1886 0b48 EBFFFFFE 		mov	r3, #2
 1887              		mov	r0, #114
 1888 0b4c E1A01004 		str	r6, [sp, #0]
 1889              		bl	io_i2c0_byte_transfer
 1890 0b50 E5CD0010 		.loc 4 293 0
 1891              		add	r2, r5, #11
 1892 0b54 E3A02006 		mov	r3, #2
 1893 0b58 E3A03002 		.loc 4 292 0
 1894 0b5c E3A00072 		strb	r0, [sp, #17]
 1895 0b60 E58D5000 		.loc 4 293 0
 1896 0b64 EBFFFFFE 		mov	r1, r4
 1897              		mov	r0, #114
 1898 0b68 E1A01004 		str	r6, [sp, #0]
 1899              		bl	io_i2c0_byte_transfer
 1900 0b6c E5CD0011 		strb	r0, [sp, #18]
 1901              		.loc 4 294 0
 1902 0b70 E3A02007 		mov	r0, r9
 1903 0b74 E3A03002 		bl	qbytes_to_long
 1904 0b78 E3A00072 		str	r0, [r5], #4
 1905 0b7c E58D5000 		.loc 4 289 0
 1906 0b80 EBFFFFFE 		ldr	r3, [sp, #20]
 1907 0b84 E5CD0012 		add	r3, r3, #4
 1908              		cmp	r3, r5
 1909 0b88 E1A00009 		cmpne	r5, #32768
 1910 0b8c EBFFFFFE 		bcc	.L278
 1911              	.LVL156:
 1912 0b90 E3700004 	.L276:
 1913              		.loc 4 297 0
 1914 0b94 E58D0014 		ldr	r0, .L354+64
 1915              		bl	uart0_printf
 1916 0b98 0A000024 		b	.L246
 1917              	.LVL157:
 1918 0b9c E1A06005 	.L346:
 1919              		.loc 4 142 0
 1920              		cmn	r4, #1
 1921              		beq	.L228
 1922              		cmp	r4, #48
 1923 0ba0 E2852008 		beq	.L349
 1924 0ba4 E1A01004 	.L231:
 1925 0ba8 E3A03002 		.loc 4 452 0
 1926 0bac E3A00072 		and	r0, r4, #255
 1927 0bb0 E58D6000 		bl	io_uart0_send_byte
 1928 0bb4 EBFFFFFE 		.loc 4 453 0
 1929              		ldr	r0, .L354+68
 1930 0bb8 E2852009 		bl	uart0_printf
 1931              		b	.L228
 1932 0bbc E5CD000F 	.L349:
 1933              		.loc 4 166 0
 1934 0bc0 E1A01004 		mov	r0, r4
 1935 0bc4 E3A03002 		bl	io_uart0_send_byte
 1936 0bc8 E3A00072 		b	.L246
 1937 0bcc E58D6000 	.L235:
 1938 0bd0 EBFFFFFE 		.loc 4 238 0
 1939              		mov	r0, r4
 1940 0bd4 E285200A 		bl	io_uart0_send_byte
 1941              		.loc 4 239 0
 1942 0bd8 E5CD0010 		ldr	r0, .L354+72
 1943              		bl	uart0_printf
 1944 0bdc E1A01004 	.L259:
 1945 0be0 E3A03002 		.loc 4 240 0
 1946 0be4 E3A00072 		bl	io_uart0_read_byte
 1947 0be8 E58D6000 		cmn	r0, #1
 1948 0bec EBFFFFFE 		beq	.L259
 1949              	.L319:
 1950 0bf0 E285200B 		.loc 4 241 0
 1951 0bf4 E3A03002 		bl	io_uart0_read_byte
 1952              		cmn	r0, #1
 1953 0bf8 E5CD0011 		bne	.L319
 1954              		mov	r5, #67108864
 1955 0bfc E1A01004 	.LVL158:
 1956 0c00 E3A00072 	.LVL159:
 1957 0c04 E58D6000 	.L262:
 1958 0c08 EBFFFFFE 		.loc 4 246 0
 1959 0c0c E5CD0012 		ldr	r0, [r5, #0]
 1960              		mov	r1, sl
 1961 0c10 E1A00009 		mov	r2, #8
 1962 0c14 EBFFFFFE 		bl	long_to_hex_string
 1963 0c18 E4850004 		.loc 4 248 0
 1964              		ldrb	r0, [sp, #6]	@ zero_extendqisi2
 1965 0c1c E59D3014 		cmp	r0, #0
 1966 0c20 E2833004 		beq	.L263
 1967 0c24 E1530005 		mov	r4, #0
 1968 0c28 13550902 	.LVL160:
 1969 0c2c 3AFFFFDB 	.L265:
 1970              		.loc 4 250 0
 1971              		add	r4, r4, #1
 1972              		.loc 4 249 0
 1973 0c30 E59F0464 		bl	io_uart0_send_byte
 1974 0c34 EBFFFFFE 		.loc 4 248 0
 1975 0c38 EAFFFF4A 		ldrb	r0, [r4, sl]	@ zero_extendqisi2
 1976              		cmp	r0, #0
 1977              		bne	.L265
 1978              	.LVL161:
 1979 0c3c E3740001 	.L263:
 1980 0c40 0AFFFF16 		.loc 4 252 0
 1981 0c44 E3540030 		mov	r0, #32
 1982 0c48 0A000004 		bl	io_uart0_send_byte
 1983              		.loc 4 254 0
 1984              		bl	io_uart0_read_byte
 1985 0c4c E20400FF 		cmn	r0, #1
 1986 0c50 EBFFFFFE 		bne	.L310
 1987              		.loc 4 244 0
 1988 0c54 E59F0444 		mov	r3, #67108864
 1989 0c58 EBFFFFFE 		add	r3, r3, #2528
 1990 0c5c EAFFFF0F 		.loc 4 253 0
 1991              		add	r5, r5, #4
 1992              		.loc 4 244 0
 1993 0c60 E1A00004 		add	r3, r3, #4
 1994 0c64 EBFFFFFE 		cmp	r5, r3
 1995 0c68 EAFFFF3E 		bne	.L262
 1996              	.LVL162:
 1997              	.L310:
 1998 0c6c E1A00004 		.loc 4 386 0
 1999 0c70 EBFFFFFE 		ldr	r0, .L354+76
 2000              		bl	uart0_printf
 2001 0c74 E59F0428 		b	.L228
 2002 0c78 EBFFFFFE 	.LVL163:
 2003              	.L347:
 2004              		.loc 4 142 0
 2005 0c7c EBFFFFFE 		cmp	r4, #53
 2006 0c80 E3700001 		beq	.L238
 2007 0c84 0AFFFFFC 		cmp	r4, #97
 2008              		bne	.L231
 2009              		.loc 4 392 0
 2010 0c88 EBFFFFFE 		mov	r0, r4
 2011 0c8c E3700001 		bl	io_uart0_send_byte
 2012 0c90 1AFFFFFC 		.loc 4 393 0
 2013 0c94 E3A05301 		ldr	r0, .L354+80
 2014              		bl	uart0_printf
 2015              		.loc 4 394 0
 2016              		ldr	r0, .L354+84
 2017              		bl	uart0_printf
 2018 0c98 E5950000 		.loc 4 395 0
 2019 0c9c E1A0100A 		ldr	r0, .L354+88
 2020 0ca0 E3A02008 		bl	uart0_printf
 2021 0ca4 EBFFFFFE 		b	.L228
 2022              	.L280:
 2023 0ca8 E5DD0006 		.loc 4 316 0
 2024 0cac E3500000 		ldr	r0, .L354+92
 2025 0cb0 0A000005 		bl	uart0_printf
 2026 0cb4 E3A04000 		.loc 4 317 0
 2027              		mov	r0, r9
 2028              		mov	r1, #4
 2029              		mov	r2, #0
 2030 0cb8 E2844001 		bl	uart0_scanf
 2031              		.loc 4 318 0
 2032 0cbc EBFFFFFE 		ldrb	r3, [sp, #15]	@ zero_extendqisi2
 2033              		cmp	r3, #83
 2034 0cc0 E7D4000A 		bne	.L282
 2035 0cc4 E3500000 		ldrb	r2, [sp, #16]	@ zero_extendqisi2
 2036 0cc8 1AFFFFFA 		cmp	r2, #77
 2037              		beq	.L350
 2038              	.L282:
 2039              		.loc 4 352 0
 2040 0ccc E3A00020 		ldr	r0, .L354+96
 2041 0cd0 EBFFFFFE 		bl	uart0_printf
 2042              	.LVL164:
 2043 0cd4 EBFFFFFE 	.L299:
 2044 0cd8 E3700001 		.loc 4 353 0
 2045 0cdc 1A000005 		ldr	r0, .L354+100
 2046              		bl	uart0_printf
 2047 0ce0 E3A03301 		b	.L228
 2048 0ce4 E2833E9E 	.LVL165:
 2049              	.L350:
 2050 0ce8 E2855004 		.loc 4 318 0
 2051              		ldrb	r1, [sp, #17]	@ zero_extendqisi2
 2052 0cec E2833004 		cmp	r1, #66
 2053 0cf0 E1550003 		bne	.L282
 2054 0cf4 1AFFFFE7 		ldrb	r0, [sp, #18]	@ zero_extendqisi2
 2055              		cmp	r0, #82
 2056              		bne	.L282
 2057              		.loc 4 320 0
 2058 0cf8 E59F03A8 		mov	r4, #0
 2059 0cfc EBFFFFFE 	.LVL166:
 2060 0d00 EAFFFEE6 		strb	r3, [r4, #0]
 2061              		NOP
 2062              		.loc 4 321 0
 2063              		strb	r2, [r4, #1]
 2064 0d04 E3540035 		NOP
 2065 0d08 0A00009C 		.loc 4 322 0
 2066 0d0c E3540061 		strb	r1, [r4, #2]
 2067 0d10 1AFFFFCD 		NOP
 2068              		.loc 4 323 0
 2069 0d14 E1A00004 		strb	r0, [r4, #3]
 2070 0d18 EBFFFFFE 		NOP
 2071              		.loc 4 324 0
 2072 0d1c E59F0388 		sub	r1, r1, #62
 2073 0d20 EBFFFFFE 		mov	r0, r9
 2074              		mov	r2, r4
 2075 0d24 E59F0384 		bl	uart0_scanf
 2076 0d28 EBFFFFFE 		.loc 4 325 0
 2077              		ldrb	r3, [sp, #15]	@ zero_extendqisi2
 2078 0d2c E59F0380 		strb	r3, [r4, #4]
 2079 0d30 EBFFFFFE 		.loc 4 326 0
 2080 0d34 EAFFFED9 		ldrb	r2, [sp, #16]	@ zero_extendqisi2
 2081              		strb	r2, [r4, #5]
 2082              		.loc 4 327 0
 2083 0d38 E59F0378 		ldrb	r3, [sp, #17]	@ zero_extendqisi2
 2084 0d3c EBFFFFFE 		strb	r3, [r4, #6]
 2085              		.loc 4 328 0
 2086 0d40 E1A00009 		ldrb	r2, [sp, #18]	@ zero_extendqisi2
 2087 0d44 E3A01004 		.loc 4 329 0
 2088 0d48 E3A02000 		mov	r0, r9
 2089 0d4c EBFFFFFE 		.loc 4 328 0
 2090              		strb	r2, [r4, #7]
 2091 0d50 E5DD300F 		.loc 4 329 0
 2092 0d54 E3530053 		bl	qbytes_to_long
 2093 0d58 1A000002 		.loc 4 330 0
 2094 0d5c E5DD2010 		mov	r3, #65280
 2095 0d60 E352004D 		add	r3, r3, #252
 2096 0d64 0A000004 		cmp	r0, r3
 2097              		.loc 4 329 0
 2098              		mov	r5, r0
 2099 0d68 E59F034C 	.LVL167:
 2100 0d6c EBFFFFFE 		.loc 4 330 0
 2101              		bhi	.L287
 2102              		.loc 4 335 0
 2103              		cmn	r0, #4
 2104 0d70 E59F0348 	.LVL168:
 2105 0d74 EBFFFFFE 		addne	r4, r4, #8
 2106 0d78 EAFFFEC8 		addne	r6, r0, #11
 2107              	.LVL169:
 2108              		beq	.L289
 2109              	.LVL170:
 2110 0d7c E5DD1011 	.L341:
 2111 0d80 E3510042 		.loc 4 338 0
 2112 0d84 1AFFFFF7 		bl	io_uart0_read_byte
 2113 0d88 E5DD0012 	.LVL171:
 2114 0d8c E3500052 	.LVL172:
 2115 0d90 1AFFFFF4 		.loc 4 337 0
 2116              		cmn	r0, #1
 2117 0d94 E3A04000 		beq	.L341
 2118              		.loc 4 335 0
 2119 0d98 E5C43000 		cmp	r6, r4
 2120 0d9c E1A00000 	.LVL173:
 2121              		.loc 4 339 0
 2122 0da0 E5C42001 		strb	r0, [r4, #0]
 2123 0da4 E1A00000 		add	r4, r4, #1
 2124              		.loc 4 335 0
 2125 0da8 E5C41002 		bne	.L341
 2126 0dac E1A00000 	.LVL174:
 2127              	.L289:
 2128 0db0 E5C40003 		.loc 4 341 0
 2129 0db4 E1A00000 		ldr	r0, .L354+104
 2130              	.LVL175:
 2131 0db8 E241103E 		bl	uart0_printf
 2132 0dbc E1A00009 		.loc 4 343 0
 2133 0dc0 E1A02004 		ldr	r0, .L354+108
 2134 0dc4 EBFFFFFE 		bl	uart0_printf
 2135              		.loc 4 345 0
 2136 0dc8 E5DD300F 		cmn	r5, #12
 2137 0dcc E5C43004 		beq	.L294
 2138              		mov	r4, #0
 2139 0dd0 E5DD2010 	.LVL176:
 2140 0dd4 E5C42005 		add	r7, r5, #12
 2141              		mov	r6, r4
 2142 0dd8 E5DD3011 	.L296:
 2143 0ddc E5C43006 		ldrb	r5, [r4, #0]	@ zero_extendqisi2
 2144              	.LVL177:
 2145 0de0 E5DD2012 	.L297:
 2146              		.loc 4 347 0
 2147 0de4 E1A00009 		mov	r0, #119
 2148              		mov	r1, r8
 2149 0de8 E5C42007 		mov	r2, r6
 2150              		mov	r3, #2
 2151 0dec EBFFFFFE 		str	r5, [sp, #0]
 2152              		bl	io_i2c0_byte_transfer
 2153 0df0 E3A03CFF 		cmp	r0, #0
 2154 0df4 E28330FC 		bne	.L297
 2155 0df8 E1500003 		.loc 4 345 0
 2156              		add	r4, r4, #1
 2157 0dfc E1A05000 		cmp	r7, r4
 2158              		mov	r6, r4
 2159              		bne	.L296
 2160 0e00 8A00008B 	.LVL178:
 2161              	.L294:
 2162 0e04 E3700004 		.loc 4 349 0
 2163              		ldr	r0, .L354+112
 2164 0e08 12844008 		bl	uart0_printf
 2165 0e0c 1280600B 		b	.L299
 2166              	.LVL179:
 2167 0e10 0A000006 	.L241:
 2168              		.loc 4 401 0
 2169              		mov	r0, r4
 2170              		bl	io_uart0_send_byte
 2171 0e14 EBFFFFFE 		.loc 4 404 0
 2172              		bl	help_info
 2173              		b	.L228
 2174              	.L348:
 2175 0e18 E3700001 		.loc 4 176 0
 2176 0e1c 0AFFFFFC 		ldrb	r3, [sp, #17]	@ zero_extendqisi2
 2177              		cmp	r3, #66
 2178 0e20 E1560004 		bne	.L247
 2179              		ldrb	r3, [sp, #18]	@ zero_extendqisi2
 2180              		cmp	r3, #82
 2181 0e24 E5C40000 		bne	.L247
 2182 0e28 E2844001 		.loc 4 178 0
 2183              		mov	r1, #4
 2184 0e2c 1AFFFFF8 		mov	r2, #0
 2185              		mov	r0, r9
 2186              		bl	uart0_scanf
 2187              		.loc 4 183 0
 2188 0e30 E59F028C 		mov	r0, r9
 2189              		bl	qbytes_to_long
 2190 0e34 EBFFFFFE 		.loc 4 192 0
 2191              		mov	r3, #33554432
 2192 0e38 E59F0288 		sub	r3, r3, #8
 2193 0e3c EBFFFFFE 		cmp	r0, r3
 2194              		.loc 4 183 0
 2195 0e40 E375000C 		str	r0, [sp, #20]
 2196 0e44 0A00000F 		.loc 4 192 0
 2197 0e48 E3A04000 		bhi	.L351
 2198              		.loc 4 198 0
 2199 0e4c E285700C 		add	r4, r0, #67108864
 2200 0e50 E1A06004 	.LVL180:
 2201              		add	r4, r4, #4
 2202 0e54 E5D45000 		.loc 4 204 0
 2203              		cmp	r4, #67108864
 2204              		beq	.L256
 2205              		mov	r5, #67108864
 2206 0e58 E3A00077 	.LVL181:
 2207 0e5c E1A01008 	.L257:
 2208 0e60 E1A02006 		.loc 4 205 0
 2209 0e64 E3A03002 		mov	r1, #4
 2210 0e68 E58D5000 		mov	r2, #0
 2211 0e6c EBFFFFFE 		mov	r0, r9
 2212 0e70 E3500000 		bl	uart0_scanf
 2213 0e74 1AFFFFF7 		.loc 4 206 0
 2214              		mov	r0, r9
 2215 0e78 E2844001 		bl	qbytes_to_long
 2216 0e7c E1570004 		str	r0, [r5], #4
 2217 0e80 E1A06004 		.loc 4 204 0
 2218 0e84 1AFFFFF2 		cmp	r5, r4
 2219              		bne	.L257
 2220              		mov	r4, r5
 2221              	.LVL182:
 2222 0e88 E59F023C 	.L256:
 2223 0e8c EBFFFFFE 		.loc 4 219 0
 2224 0e90 EAFFFFB6 		ldr	r0, .L354+116
 2225              		bl	uart0_printf
 2226              		.loc 4 220 0
 2227              		mov	r1, sl
 2228 0e94 E1A00004 		mov	r2, #8
 2229 0e98 EBFFFFFE 		mov	r0, r4
 2230              		bl	long_to_hex_string
 2231 0e9c EBFFFFFE 		.loc 4 221 0
 2232 0ea0 EAFFFE7E 		mov	r0, sl
 2233              		bl	uart0_printf
 2234              		.loc 4 222 0
 2235 0ea4 E5DD3011 		ldr	r0, .L354+120
 2236 0ea8 E3530042 		bl	uart0_printf
 2237 0eac 1AFFFF0A 		.loc 4 223 0
 2238 0eb0 E5DD3012 		ldr	r0, .L354+124
 2239 0eb4 E3530052 		bl	uart0_printf
 2240 0eb8 1AFFFF07 		.loc 4 224 0
 2241              		ldr	r0, .L354+128
 2242 0ebc E3A01004 		bl	uart0_printf
 2243 0ec0 E3A02000 		.loc 4 225 0
 2244 0ec4 E1A00009 		mov	r0, r4
 2245 0ec8 EBFFFFFE 		mov	r1, sl
 2246              		mov	r2, #8
 2247 0ecc E1A00009 		bl	long_to_hex_string
 2248 0ed0 EBFFFFFE 		.loc 4 226 0
 2249              		mov	r0, sl
 2250 0ed4 E3A03402 		bl	uart0_printf
 2251 0ed8 E2433008 		.loc 4 227 0
 2252 0edc E1500003 		ldr	r0, .L354+120
 2253              		bl	uart0_printf
 2254 0ee0 E58D0014 		b	.L228
 2255              	.LVL183:
 2256 0ee4 8A00004F 	.L238:
 2257              		.loc 4 359 0
 2258 0ee8 E2804301 		mov	r0, r4
 2259              		bl	io_uart0_send_byte
 2260 0eec E2844004 		.loc 4 360 0
 2261              		ldr	r0, .L354+132
 2262 0ef0 E3540301 		bl	uart0_printf
 2263 0ef4 0A00000A 		.loc 4 361 0
 2264 0ef8 E3A05301 		mov	r0, r9
 2265              		mov	r1, #2
 2266              		mov	r2, #1
 2267              		bl	uart0_scanf
 2268 0efc E3A01004 		.loc 4 362 0
 2269 0f00 E3A02000 		mov	r0, r9
 2270 0f04 E1A00009 		mov	r1, #2
 2271 0f08 EBFFFFFE 		bl	hex_string_to_long
 2272              		.loc 4 363 0
 2273 0f0c E1A00009 		ands	r6, r0, #255
 2274 0f10 EBFFFFFE 	.LVL184:
 2275 0f14 E4850004 		beq	.L340
 2276              		.loc 4 367 0
 2277 0f18 E1550004 		ldr	r0, .L354+136
 2278 0f1c 1AFFFFF6 		bl	uart0_printf
 2279 0f20 E1A04005 		.loc 4 368 0
 2280              		ldr	r0, .L354+140
 2281              		bl	uart0_printf
 2282              	.L302:
 2283 0f24 E59F01A4 		.loc 4 369 0
 2284 0f28 EBFFFFFE 		bl	io_uart0_read_byte
 2285              		cmn	r0, #1
 2286 0f2c E1A0100A 		beq	.L302
 2287 0f30 E3A02008 	.L320:
 2288 0f34 E1A00004 		.loc 4 370 0
 2289 0f38 EBFFFFFE 		bl	io_uart0_read_byte
 2290              		cmn	r0, #1
 2291 0f3c E1A0000A 		bne	.L320
 2292 0f40 EBFFFFFE 		.loc 4 477 0
 2293              		mov	r5, #0
 2294 0f44 E59F0188 	.LVL185:
 2295 0f48 EBFFFFFE 		b	.L342
 2296              	.LVL186:
 2297 0f4c E59F0184 	.L353:
 2298 0f50 EBFFFFFE 		.loc 4 373 0
 2299              		cmp	r4, #0
 2300 0f54 E59F0180 		bge	.L352
 2301 0f58 EBFFFFFE 	.LVL187:
 2302              	.L342:
 2303 0f5c E1A00004 		.loc 4 374 0
 2304 0f60 E1A0100A 		mov	ip, #0
 2305 0f64 E3A02008 		mov	r2, r5
 2306 0f68 EBFFFFFE 		mov	r1, r6
 2307              		mov	r3, #2
 2308 0f6c E1A0000A 		mov	r0, #114
 2309 0f70 EBFFFFFE 		str	ip, [sp, #0]
 2310              		bl	io_i2c0_byte_transfer
 2311 0f74 E59F0158 		mov	r4, r0
 2312 0f78 EBFFFFFE 	.LVL188:
 2313 0f7c EAFFFE47 		.loc 4 375 0
 2314              		bl	io_uart0_read_byte
 2315              		cmn	r0, #1
 2316              		.loc 4 384 0
 2317 0f80 E1A00004 		mov	r0, r4
 2318 0f84 EBFFFFFE 		.loc 4 375 0
 2319              		beq	.L353
 2320 0f88 E59F0150 	.LVL189:
 2321 0f8c EBFFFFFE 		.loc 4 381 0
 2322              		ldr	r0, .L354+144
 2323 0f90 E1A00009 	.LVL190:
 2324 0f94 E3A01002 		bl	uart0_printf
 2325 0f98 E3A02001 		b	.L310
 2326 0f9c EBFFFFFE 	.LVL191:
 2327              	.L351:
 2328 0fa0 E1A00009 		.loc 4 193 0
 2329 0fa4 E3A01002 		ldr	r0, .L354+148
 2330 0fa8 EBFFFFFE 		bl	uart0_printf
 2331              		b	.L228
 2332 0fac E21060FF 	.LVL192:
 2333              	.L287:
 2334 0fb0 0AFFFE98 		.loc 4 331 0
 2335              		ldr	r0, .L354+152
 2336 0fb4 E59F0128 		bl	uart0_printf
 2337 0fb8 EBFFFFFE 		b	.L228
 2338              	.LVL193:
 2339 0fbc E59F0124 	.L352:
 2340 0fc0 EBFFFFFE 		.loc 4 384 0
 2341              		bl	io_uart0_send_byte
 2342              		.loc 4 371 0
 2343 0fc4 EBFFFFFE 		mov	r3, #65536
 2344 0fc8 E3700001 		add	r5, r5, #1
 2345 0fcc 0AFFFFFC 		sub	r3, r3, #1
 2346              		cmp	r5, r3
 2347              		bne	.L342
 2348 0fd0 EBFFFFFE 		b	.L310
 2349 0fd4 E3700001 	.L355:
 2350 0fd8 1AFFFFFC 		.align	2
 477:main.c        **** 	while(1);
 2351              		.LC32
 2352 0fdc E3A05000 		.word	.LC50
 2353              		.word	.LC51
 2354 0fe0 EA000001 		.word	.LC52
 2355              		.word	.LC53
 2356              		.word	.LC28
 2357              		.word	.LC29
 2358 0fe4 E3540000 		.word	.LC33
 2359 0fe8 AA000014 		.word	.LC19
 2360              		.word	.LC25
 2361              		.word	.LC47
 2362              		.word	.LC48
 2363 0fec E3A0C000 		.word	.LC31
 2364 0ff0 E1A02005 		.word	.LC49
 2365 0ff4 E1A01006 		.word	.LC26
 2366 0ff8 E3A03002 		.word	.LC27
 2367 0ffc E3A00072 		.word	.LC44
 2368 1000 E58DC000 		.word	.LC45
 2369 1004 EBFFFFFE 		.word	.LC46
 2370 1008 E1A04000 		.word	.LC34
 2371              		.word	.LC39
 2372              		.word	.LC40
 2373 100c EBFFFFFE 		.word	.LC36
 2374 1010 E3700001 		.word	.LC37
 2375              		.word	.LC38
 2376 1014 E1A00004 		.word	.LC21
 2377              		.word	.LC22
 2378 1018 0AFFFFF1 		.word	.LC23
 2379              		.word	.LC24
 2380              		.word	.LC41
 2381 101c E59F00C8 		.word	.LC42
 2382              		.word	.LC43
 2383 1020 EBFFFFFE 		.word	.LC54
 2384 1024 EAFFFF33 		.word	.LC20
 2385              		.word	.LC35
 2386              	.LFE35:
 2388 1028 E59F00C0 		.align	2
 2389 102c EBFFFFFE 		.global	io_enable_xint
 2391              	io_enable_xint:
 2392              	.LFB23:
 2393              		.loc 1 444 0
 2394 1034 E59F00B8 		@ args = 0, pretend = 0, frame = 0
 2395 1038 EBFFFFFE 		@ frame_needed = 0, uses_anonymous_args = 0
 2396 103c EAFFFE17 		@ link register save eliminated.
 2397              		@ lr needed for prologue
 2398              	.LBB6:
 2399              	.LBB7:
 2400 1040 EBFFFFFE 		.loc 1 428 0
 2401              		 mrs r3, cpsr
 2402 1044 E3A03801 	.LVL194:
 2403 1048 E2855001 	.LBE7:
 2404 104c E2433001 	.LBE6:
 2405 1050 E1550003 	.LBB8:
 2406 1054 1AFFFFE4 	.LBB9:
 2407 1058 EAFFFF26 		.loc 1 437 0
 2408              		bic	r3, r3, #192
 2409              	.LVL195:
 2410              		 msr cpsr, r3
 2411 105c 00000454 	.LBE9:
 2412 1060 0000046C 	.LBE8:
 2413 1064 00000474 		.loc 1 448 0
 2414 1068 00000648 		mov	pc, lr
 2415 106c 000006AC 	.LFE23:
 2417 1074 00000A3C 		.align	2
 2418 1078 00000A6C 		.global	io_disable_xint
 2420 1080 000005EC 	io_disable_xint:
 2421 1084 00000628 	.LFB24:
 2422 1088 000006D8 		.loc 1 454 0
 2423 108c 00000484 		@ args = 0, pretend = 0, frame = 0
 2424 1090 00000558 		@ frame_needed = 0, uses_anonymous_args = 0
 2425 1094 0000099C 		@ link register save eliminated.
 2426 1098 000009CC 		@ lr needed for prologue
 2427 109c 00000698 	.LBB14:
 2428 10a0 000009F4 	.LBB15:
 2429 10a4 00000580 		.loc 1 428 0
 2430 10a8 000005C8 		 mrs r3, cpsr
 2431 10ac 000008B8 	.LVL196:
 2432 10b0 000008EC 	.LBE15:
 2433 10b4 00000958 	.LBE14:
 2434 10b8 000006F8 	.LBB16:
 2435 10bc 000007C4 	.LBB17:
 2436 10c0 000007E8 		.loc 1 437 0
 2437 10c4 0000077C 		orr	r3, r3, #192
 2438 10c8 00000794 	.LVL197:
 2439 10cc 000007B4 		 msr cpsr, r3
 2440 10d0 00000520 	.LBE17:
 2441 10d4 00000534 	.LBE16:
 2442 10d8 00000538 		.loc 1 458 0
 2443 10dc 00000548 		mov	pc, lr
 2444 10e0 000007F4 	.LFE24:
 2446 10e8 00000870 		.section	.debug_frame,"",%progbits
 2447 10ec 00000AAC 	.Lframe0:
 2448 10f0 000004F8 		.4byte	.LECIE0-.LSCIE0
 2449 10f4 00000758 	.LSCIE0:
 2450              		.4byte	0xffffffff
 2451              		.byte	0x1
 2452              		.ascii	"\000"
 2453              		.uleb128 0x1
 2454              		.sleb128 -4
 2455              		.byte	0xe
 2456              		.byte	0xc
 417:../lib/io_driver.c **** //		case 14:         asm volatile ("mcr p15,0,%0,c14,c14,0" : /* no outputs */ : "r" (_cp_val)); br
 418:../lib/io_driver.c **** //		case 15:         asm volatile ("mcr p15,0,%0,c15,c15,0" : /* no outputs */ : "r" (_cp_val)); br
 419:../lib/io_driver.c **** 		default:         break;
 420:../lib/io_driver.c **** 	}
 421:../lib/io_driver.c **** }
 422:../lib/io_driver.c **** // ******************************************************************************
 423:../lib/io_driver.c **** // read CMSR value
 424:../lib/io_driver.c ****    static inline unsigned long get_cmsr(void)
 425:../lib/io_driver.c **** // ******************************************************************************
 426:../lib/io_driver.c **** {
 427:../lib/io_driver.c **** 	unsigned long _cmsr;
 428:../lib/io_driver.c **** 	asm volatile (" mrs %0, cpsr" : "=r" (_cmsr) : /* no inputs */  );
 429:../lib/io_driver.c **** 	return _cmsr;
 430:../lib/io_driver.c **** }
 431:../lib/io_driver.c **** 
 432:../lib/io_driver.c **** // ******************************************************************************
 433:../lib/io_driver.c **** // write CMSR value
 434:../lib/io_driver.c ****    static inline void set_cmsr(unsigned long _cmsr)
 435:../lib/io_driver.c **** // ******************************************************************************
 436:../lib/io_driver.c **** {
 437:../lib/io_driver.c **** 	asm volatile (" msr cpsr, %0" : /* no outputs */ : "r" (_cmsr)  );
 438:../lib/io_driver.c **** }
 439:../lib/io_driver.c **** 
 440:../lib/io_driver.c **** // ******************************************************************************
 441:../lib/io_driver.c **** // Enable all external INTs
 442:../lib/io_driver.c ****    void io_enable_xint(void)
 443:../lib/io_driver.c **** // ******************************************************************************
 444:../lib/io_driver.c **** {
 2457              	0
 2458              		.4byte	.LFB2
 2459              		.4byte	.LFE2-.LFB2
 2460              		.align	2
 2461              	.LEFDE0:
 2462              	.LSFDE2:
 2463              		.4byte	.LEFDE2-.LASFDE2
 2464              	.LASFDE2:
 2465 10f8 E10F3000 		.4byte	.Lframe0
 2466              		.4byte	.LFB3
 2467              		.4byte	.LFE3-.LFB3
 2468              		.align	2
 2469              	.LEFDE2:
 2470              	.LSFDE4:
 2471              		.4byte	.LEFDE4-.LASFDE4
 2472 10fc E3C330C0 	.LASFDE4:
 2473              		.4byte	.Lframe0
 2474 1100 E129F003 		.4byte	.LFB4
 2475              		.4byte	.LFE4-.LFB4
 2476              		.align	2
 445:../lib/io_driver.c **** 	unsigned long _cmsr = get_cmsr();
 446:../lib/io_driver.c **** 	_cmsr = _cmsr & ~(1<<CMSR_FIQ) &~(1<<CMSR_IRQ);
 447:../lib/io_driver.c **** 	set_cmsr(_cmsr);
 448:../lib/io_driver.c **** }
 2477              	4byte	.LEFDE6-.LASFDE6
 2478 1104 E1A0F00E 	.LASFDE6:
 2479              		.4byte	.Lframe0
 2480              		.4byte	.LFB5
 2481              		.4byte	.LFE5-.LFB5
 2482              		.align	2
 2483              	.LEFDE6:
 2484              	.LSFDE8:
 2485              		.4byte	.LEFDE8-.LASFDE8
 449:../lib/io_driver.c **** 
 450:../lib/io_driver.c **** // ******************************************************************************
 451:../lib/io_driver.c **** // Disable all global IBTs
 452:../lib/io_driver.c ****    void io_disable_xint(void)
 453:../lib/io_driver.c **** // ******************************************************************************
 454:../lib/io_driver.c **** {
 2486              	
 2487              		.4byte	.Lframe0
 2488              		.4byte	.LFB6
 2489              		.4byte	.LFE6-.LFB6
 2490              		.align	2
 2491              	.LEFDE8:
 2492              	.LSFDE10:
 2493              		.4byte	.LEFDE10-.LASFDE10
 2494 1108 E10F3000 	.LASFDE10:
 2495              		.4byte	.Lframe0
 2496              		.4byte	.LFB7
 2497              		.4byte	.LFE7-.LFB7
 2498              		.align	2
 2499              	.LEFDE10:
 2500              	.LSFDE12:
 2501 110c E38330C0 		.4byte	.LEFDE12-.LASFDE12
 2502              	.LASFDE12:
 2503 1110 E129F003 		.4byte	.Lframe0
 2504              		.4byte	.LFB8
 2505              		.4byte	.LFE8-.LFB8
 455:../lib/io_driver.c **** 	unsigned long _cmsr = get_cmsr();
 456:../lib/io_driver.c **** 	_cmsr = _cmsr | (1<<CMSR_FIQ) | (1<<CMSR_IRQ);
 457:../lib/io_driver.c **** 	set_cmsr(_cmsr);
 458:../lib/io_driver.c **** }
 2506              	.LCFI0-.LFB8
 2507 1114 E1A0F00E 		.byte	0xe
 2508              		.uleb128 0x8
 2509              		.byte	0x8e
 2886              	.LLST14:
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:13     .text:00000000 io_read_gpio0_pin
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:22     .text:00000000 $a
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:39     .text:00000018 io_read_gpio0_port
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:59     .text:00000024 io_set_gpio0_pin
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:85     .text:00000040 io_clr_gpio0_pin
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:111    .text:00000064 io_toggle_gpio0_pin
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:137    .text:00000080 io_set_gpio0_port
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:157    .text:0000008c io_set_pwm
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:229    .text:00000108 io_get_pwm
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:282    .text:00000158 io_uart0_read_byte
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:306    .text:00000170 io_uart0_send_byte
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:331    .text:0000018c io_spi0_config
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:361    .text:000001b0 io_spi0_speed
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:381    .text:000001bc io_spi0_trans
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:418    .text:000001f4 io_spi0_enable
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:444    .text:00000210 io_spi0_disable
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:470    .text:00000234 io_i2c0_speed
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:503    .text:00000260 io_i2c0_byte_transfer
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:647    .text:00000390 get_syscpreg
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:662    .text:000003a0 $d
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:679    .text:000003e0 $a
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:785    .text:00000468 set_syscpreg
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:804    .text:0000047c $d
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:814    .text:0000049c $a
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:834    .text:000004bc uart0_printf
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:879    .text:000004f4 uart0_scanf
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:946    .text:0000054c $d
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:952    .text:00000550 uart0_print_buffer
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:958    .text:00000550 $a
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:982    .text:00000574 long_to_hex_string
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:1052   .text:000005e4 get_adc
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:1093   .text:00000624 delay
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:1125   .text:0000064c string_cmpc
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:1176   .text:00000694 hex_string_to_long
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:1304   .text:00000700 help_info
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:1362   .text:00000780 $d
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:1382   .text:000007bc qbytes_to_long
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:1389   .text:000007bc $a
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:1547   .text:000007dc main
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:2411   .text:0000105c $d
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:2455   .text:000010f8 io_enable_xint
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:2465   .text:000010f8 $a
C:\Users\jh\AppData\Local\Temp/cc0gcaaa.s:2484   .text:00001108 io_disable_xint

UNDEFINED SYMBOLS
_jump_to_program
