   1              		.file	"main.c"
   9              	.Ltext0:
  10              		.align	2
  11              		.global	io_read_gpio0_pin
  13              	io_read_gpio0_pin:
  14              	.LFB2:
  15              		.file 1 "../lib/io_driver.c"
   1:../lib/io_driver.c **** #include "io_driver.h"
   2:../lib/io_driver.c **** #include "storm_core.h"
   3:../lib/io_driver.c **** #include "storm_soc_basic.h"
   4:../lib/io_driver.c **** 
   5:../lib/io_driver.c **** // ################################################################################################
   6:../lib/io_driver.c **** // General Purpose IO (GENERAL_PURPOSE_CONTROLLER_0)
   7:../lib/io_driver.c **** // ################################################################################################
   8:../lib/io_driver.c **** 
   9:../lib/io_driver.c **** // ******************************************************************************
  10:../lib/io_driver.c **** // Read general purpose IO pin
  11:../lib/io_driver.c ****    unsigned long io_read_gpio0_pin(unsigned char pin)
  12:../lib/io_driver.c **** // ******************************************************************************
  13:../lib/io_driver.c **** {
  16              	 args = 0, pretend = 0, frame = 0
  17              		@ frame_needed = 0, uses_anonymous_args = 0
  18              		@ link register save eliminated.
  19              	.LVL0:
  20              		.loc 1 17 0
  14:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
  15:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
  16:../lib/io_driver.c **** 
  17:../lib/io_driver.c **** 		unsigned long temp = GPIO0_IN & (1<<pin);
  21              	r3, #61440
  22 0000 E3E03A0F 		ldr	r1, [r3, #-4091]
  23 0004 E5131FFB 		.loc 1 13 0
  24              		and	r2, r0, #255
  25 0008 E20020FF 		.loc 1 21 0
  18:../lib/io_driver.c **** 	
  19:../lib/io_driver.c **** //	set_cmsr(_cmsr);
  20:../lib/io_driver.c **** 	return temp;
  21:../lib/io_driver.c **** }
  26              	r0, #1
  27 000c E3A00001 	.LVL1:
  28              		and	r0, r1, r0, asl r2
  29 0010 E0010210 		.loc 1 13 0
  30              		@ lr needed for prologue
  31              		.loc 1 21 0
  32              		bx	lr
  33 0014 E12FFF1E 	.LFE2:
  35              		.align	2
  36              		.global	io_read_gpio0_port
  38              	io_read_gpio0_port:
  39              	.LFB3:
  40              		.loc 1 27 0
  22:../lib/io_driver.c **** 
  23:../lib/io_driver.c **** // ******************************************************************************
  24:../lib/io_driver.c **** // Read general purpose IO port
  25:../lib/io_driver.c ****    unsigned long io_read_gpio0_port(void)
  26:../lib/io_driver.c **** // ******************************************************************************
  27:../lib/io_driver.c **** {
  41              	etend = 0, frame = 0
  42              		@ frame_needed = 0, uses_anonymous_args = 0
  43              		@ link register save eliminated.
  44              		.loc 1 31 0
  28:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
  29:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
  30:../lib/io_driver.c **** 
  31:../lib/io_driver.c **** 		unsigned long temp = GPIO0_IN;
  45              		r3, #61440
  46 0018 E3E03A0F 		ldr	r0, [r3, #-4091]
  47 001c E5130FFB 	.LVL2:
  48              		.loc 1 27 0
  49              		@ lr needed for prologue
  50              	.LVL3:
  51              		.loc 1 35 0
  32:../lib/io_driver.c **** 
  33:../lib/io_driver.c **** //	set_cmsr(_cmsr);
  34:../lib/io_driver.c **** 	return temp;
  35:../lib/io_driver.c **** }
  52              	.LFE3:
  54              		.align	2
  55              		.global	io_set_gpio0_pin
  57              	io_set_gpio0_pin:
  58              	.LFB4:
  59              		.loc 1 41 0
  60              		@ args = 0, pretend = 0, frame = 0
  36:../lib/io_driver.c **** 
  37:../lib/io_driver.c **** // ******************************************************************************
  38:../lib/io_driver.c **** // Set general purpose IO port
  39:../lib/io_driver.c ****    void io_set_gpio0_pin(unsigned char pin)
  40:../lib/io_driver.c **** // ******************************************************************************
  41:../lib/io_driver.c **** {
  61              	needed = 0, uses_anonymous_args = 0
  62              		@ link register save eliminated.
  63              	.LVL4:
  64              		.loc 1 45 0
  65              		mvn	r1, #61440
  42:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
  43:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
  44:../lib/io_driver.c **** 
  45:../lib/io_driver.c **** 		GPIO0_OUT = GPIO0_OUT | (1<<pin);
  66              	r3, [r1, #-4095]
  67 0024 E3E01A0F 		.loc 1 41 0
  68 0028 E5113FFF 		and	r0, r0, #255
  69              		.loc 1 45 0
  70 002c E20000FF 		mov	r2, #1
  71              		orr	r3, r3, r2, asl r0
  72 0030 E3A02001 		.loc 1 41 0
  73 0034 E1833012 		@ lr needed for prologue
  74              		.loc 1 45 0
  75              		str	r3, [r1, #-4095]
  76              		.loc 1 48 0
  77 0038 E5013FFF 		bx	lr
  46:../lib/io_driver.c **** 
  47:../lib/io_driver.c **** //	set_cmsr(_cmsr);
  48:../lib/io_driver.c **** }
  78              	e	io_set_gpio0_pin, .-io_set_gpio0_pin
  79 003c E12FFF1E 		.align	2
  80              		.global	io_clr_gpio0_pin
  82              	io_clr_gpio0_pin:
  83              	.LFB5:
  84              		.loc 1 54 0
  85              		@ args = 0, pretend = 0, frame = 0
  86              		@ frame_needed = 0, uses_anonymous_args = 0
  49:../lib/io_driver.c **** 
  50:../lib/io_driver.c **** // ******************************************************************************
  51:../lib/io_driver.c **** // Clear general purpose IO port
  52:../lib/io_driver.c ****    void io_clr_gpio0_pin(unsigned char pin)
  53:../lib/io_driver.c **** // ******************************************************************************
  54:../lib/io_driver.c **** {
  87              	egister save eliminated.
  88              	.LVL5:
  89              		and	r0, r0, #255
  90              		.loc 1 58 0
  91              		mov	r2, #1
  92 0040 E20000FF 		mov	r2, r2, asl r0
  55:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
  56:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
  57:../lib/io_driver.c **** 
  58:../lib/io_driver.c **** 		GPIO0_OUT = GPIO0_OUT & ~(1<<pin);
  93              	1, #61440
  94 0044 E3A02001 		ldr	r3, [r1, #-4095]
  95 0048 E1A02012 		mvn	r2, r2
  96 004c E3E01A0F 		and	r3, r3, r2
  97 0050 E5113FFF 		.loc 1 54 0
  98 0054 E1E02002 		@ lr needed for prologue
  99 0058 E0033002 		.loc 1 58 0
 100              		str	r3, [r1, #-4095]
 101              		.loc 1 61 0
 102              		bx	lr
 103 005c E5013FFF 	.LFE5:
  59:../lib/io_driver.c **** 
  60:../lib/io_driver.c **** //	set_cmsr(_cmsr);
  61:../lib/io_driver.c **** }
 104              	lr_gpio0_pin, .-io_clr_gpio0_pin
 105 0060 E12FFF1E 		.align	2
 106              		.global	io_toggle_gpio0_pin
 108              	io_toggle_gpio0_pin:
 109              	.LFB6:
 110              		.loc 1 66 0
 111              		@ args = 0, pretend = 0, frame = 0
 112              		@ frame_needed = 0, uses_anonymous_args = 0
  62:../lib/io_driver.c **** // ******************************************************************************
  63:../lib/io_driver.c **** // Set general purpose IO port
  64:../lib/io_driver.c ****    void io_toggle_gpio0_pin(unsigned char pin)
  65:../lib/io_driver.c **** // ******************************************************************************
  66:../lib/io_driver.c **** {
 113              	egister save eliminated.
 114              	.LVL6:
 115              		.loc 1 70 0
 116              		mvn	r1, #61440
 117              		ldr	r3, [r1, #-4095]
  67:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
  68:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
  69:../lib/io_driver.c **** 
  70:../lib/io_driver.c **** 		GPIO0_OUT = GPIO0_OUT ^ (1<<pin);
 118              	 1 66 0
 119 0064 E3E01A0F 		and	r0, r0, #255
 120 0068 E5113FFF 		.loc 1 70 0
 121              		mov	r2, #1
 122 006c E20000FF 		eor	r3, r3, r2, asl r0
 123              		.loc 1 66 0
 124 0070 E3A02001 		@ lr needed for prologue
 125 0074 E0233012 		.loc 1 70 0
 126              		str	r3, [r1, #-4095]
 127              		.loc 1 73 0
 128              		bx	lr
 129 0078 E5013FFF 	.LFE6:
  71:../lib/io_driver.c **** 
  72:../lib/io_driver.c **** //	set_cmsr(_cmsr);
  73:../lib/io_driver.c **** }
 130              	ggle_gpio0_pin, .-io_toggle_gpio0_pin
 131 007c E12FFF1E 		.align	2
 132              		.global	io_set_gpio0_port
 134              	io_set_gpio0_port:
 135              	.LFB7:
 136              		.loc 1 79 0
 137              		@ args = 0, pretend = 0, frame = 0
 138              		@ frame_needed = 0, uses_anonymous_args = 0
  74:../lib/io_driver.c **** 
  75:../lib/io_driver.c **** // ******************************************************************************
  76:../lib/io_driver.c **** // Clear general purpose IO port
  77:../lib/io_driver.c ****    void io_set_gpio0_port(unsigned long value)
  78:../lib/io_driver.c **** // ******************************************************************************
  79:../lib/io_driver.c **** {
 139              	egister save eliminated.
 140              	.LVL7:
 141              		.loc 1 83 0
 142              		mvn	r3, #61440
 143              		.loc 1 79 0
  80:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
  81:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
  82:../lib/io_driver.c **** 
  83:../lib/io_driver.c **** 		GPIO0_OUT = value;
 144              	 needed for prologue
 145 0080 E3E03A0F 		.loc 1 83 0
 146              		str	r0, [r3, #-4095]
 147              		.loc 1 86 0
 148              		bx	lr
 149 0084 E5030FFF 	.LFE7:
  84:../lib/io_driver.c **** 
  85:../lib/io_driver.c **** //	set_cmsr(_cmsr);
  86:../lib/io_driver.c **** }
 150              		io_set_gpio0_port, .-io_set_gpio0_port
 151 0088 E12FFF1E 		.align	2
 152              		.global	io_set_pwm
 154              	io_set_pwm:
 155              	.LFB8:
 156              		.loc 1 98 0
 157              		@ args = 0, pretend = 0, frame = 0
 158              		@ frame_needed = 0, uses_anonymous_args = 0
  87:../lib/io_driver.c **** 
  88:../lib/io_driver.c **** 
  89:../lib/io_driver.c **** 
  90:../lib/io_driver.c **** // ################################################################################################
  91:../lib/io_driver.c **** // Pulse-Width-Modulation Controller
  92:../lib/io_driver.c **** // ################################################################################################
  93:../lib/io_driver.c **** 
  94:../lib/io_driver.c **** // ******************************************************************************
  95:../lib/io_driver.c **** // Set pwm value
  96:../lib/io_driver.c ****    void io_set_pwm(unsigned char port, unsigned char data)
  97:../lib/io_driver.c **** // ******************************************************************************
  98:../lib/io_driver.c **** {
 159              	nd	r0, r0, #255
 160              		.loc 1 105 0
 161              		cmp	r0, #7
 162              		.loc 1 98 0
 163 008c E20000FF 		stmfd	sp!, {r4, lr}
  99:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 100:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 101:../lib/io_driver.c **** 
 102:../lib/io_driver.c **** 	unsigned long temp = 0;
 103:../lib/io_driver.c **** 
 104:../lib/io_driver.c **** 	// value adjustment
 105:../lib/io_driver.c **** 	if(port > 7)
 164              	0:
 165 0090 E3500007 		.loc 1 105 0
 166              		mov	ip, #0
 167 0094 E92D4010 		mvn	lr, #255
 168              		.loc 1 98 0
 169              		and	r1, r1, #255
 170 0098 E3A0C000 		.loc 1 105 0
 171 009c E3E0E0FF 		bhi	.L16
 172              		.loc 1 117 0
 173 00a0 E20110FF 		sub	r3, r0, #4
 174              		and	r3, r3, #255
 175 00a4 8A000011 		.loc 1 108 0
 106:../lib/io_driver.c **** 		port = 0;
 107:../lib/io_driver.c **** 
 108:../lib/io_driver.c **** 	if(port < 4){
 109:../lib/io_driver.c **** 		temp = PWM0_CONF0; // get working copy
 110:../lib/io_driver.c **** 		temp = temp & ~(0xFF << (port*8)); // clear old value
 111:../lib/io_driver.c **** 		temp = temp | (unsigned long)(data << (port*8)); // insert new value
 112:../lib/io_driver.c **** 		PWM0_CONF0 = temp;
 113:../lib/io_driver.c **** 	}
 114:../lib/io_driver.c **** 	else{
 115:../lib/io_driver.c **** 		port = port-4;
 116:../lib/io_driver.c **** 		temp = PWM0_CONF1; // get working copy
 117:../lib/io_driver.c **** 		temp = temp & ~(0xFF << (port*8)); // clear old value
 176              		.loc 1 117 0
 177 00a8 E2403004 		mov	lr, r3, asl #3
 178 00ac E20330FF 		.loc 1 116 0
 179              		mvn	r4, #61440
 180 00b0 E3500003 		.loc 1 108 0
 181              		mov	ip, r0, asl #3
 182 00b4 E1A0E183 		bls	.L22
 183              		.loc 1 117 0
 184 00b8 E3E04A0F 		mov	r3, #255
 185              		mov	r3, r3, asl lr
 186 00bc E1A0C180 		.loc 1 116 0
 187 00c0 9A000007 		ldr	r2, [r4, #-3979]
 188              	.LVL9:
 189 00c4 E3A030FF 		.loc 1 117 0
 190 00c8 E1A03E13 		mvn	r3, r3
 191              		and	r2, r2, r3
 192 00cc E5142F8B 	.LVL10:
 193              		.loc 1 118 0
 194              		orr	r2, r2, r1, asl lr
 195 00d0 E1E03003 	.LVL11:
 196 00d4 E0022003 		.loc 1 119 0
 197              		str	r2, [r4, #-3979]
 118:../lib/io_driver.c **** 		temp = temp | (unsigned long)(data << (port*8)); // insert new value
 198              	LVL12:
 199 00d8 E1822E11 	.L22:
 200              		.loc 1 108 0
 119:../lib/io_driver.c **** 		PWM0_CONF1 = temp;
 201              	v	r3, #255
 202 00dc E5042F8B 		mov	r3, r3, asl ip
 203 00e0 E8BD8010 		mvn	lr, r3
 204              	.L16:
 205              		.loc 1 109 0
 206              		mvn	r2, #61440
 207 00e4 E3A030FF 		ldr	r3, [r2, #-3983]
 208 00e8 E1A03C13 	.LVL13:
 209 00ec E1E0E003 		.loc 1 110 0
 210              		and	r3, r3, lr
 211              	.LVL14:
 212 00f0 E3E02A0F 		.loc 1 111 0
 213 00f4 E5123F8F 		orr	r3, r3, r1, asl ip
 214              	.LVL15:
 215              		.loc 1 112 0
 216 00f8 E003300E 		str	r3, [r2, #-3983]
 217              		ldmfd	sp!, {r4, pc}
 218              	.LFE8:
 220              		.align	2
 221              		.global	io_get_pwm
 223 0104 E8BD8010 	io_get_pwm:
 224              	.LFB9:
 225              		.loc 1 128 0
 226              		@ args = 0, pretend = 0, frame = 0
 227              		@ frame_needed = 0, uses_anonymous_args = 0
 228              		@ link register save eliminated.
 229              	.LVL16:
 230              		and	r0, r0, #255
 120:../lib/io_driver.c **** 	}
 121:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 122:../lib/io_driver.c **** }
 123:../lib/io_driver.c **** 
 124:../lib/io_driver.c **** // ******************************************************************************
 125:../lib/io_driver.c **** // Set pwm value
 126:../lib/io_driver.c ****    unsigned char io_get_pwm(unsigned char port)
 127:../lib/io_driver.c **** // ******************************************************************************
 128:../lib/io_driver.c **** {
 231              	c 1 128 0
 232              		@ lr needed for prologue
 233              		.loc 1 135 0
 234              		mov	r2, #0
 235              		bhi	.L26
 236 0108 E20000FF 		.loc 1 142 0
 129:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 130:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 131:../lib/io_driver.c **** 
 132:../lib/io_driver.c **** 	unsigned long temp = 0;
 133:../lib/io_driver.c **** 
 134:../lib/io_driver.c **** 	// value adjustment
 135:../lib/io_driver.c **** 	if(port > 7)
 237              	3, r0, #4
 238 010c E3500007 		.loc 1 138 0
 239              		cmp	r0, #3
 240              		.loc 1 142 0
 241              		and	r2, r3, #255
 242 0110 E3A02000 		.loc 1 138 0
 243 0114 8A00000A 		bls	.L31
 136:../lib/io_driver.c **** 		port = 0;
 137:../lib/io_driver.c **** 
 138:../lib/io_driver.c **** 	if(port < 4)
 139:../lib/io_driver.c **** 		temp = PWM0_CONF0; // get config register
 140:../lib/io_driver.c **** 	else{
 141:../lib/io_driver.c **** 		port = port-4;
 142:../lib/io_driver.c **** 		temp = PWM0_CONF1; // get config register
 244              	 142 0
 245 0118 E2403004 		mvn	r3, #61440
 246              		ldr	r0, [r3, #-3979]
 247 011c E3500003 	.LVL17:
 248              		mov	r2, r2, asl #3
 249 0120 E20320FF 		mov	r0, r0, lsr r2
 250              	.LVL18:
 251 0124 9A000005 		and	r0, r0, #255
 252              		.loc 1 149 0
 253 0128 E3E03A0F 		bx	lr
 254 012c E5130F8B 	.LVL19:
 255              	.L31:
 256 0130 E1A02182 		.loc 1 138 0
 257 0134 E1A00230 		mov	r2, r0, asl #3
 258              	.L26:
 259 0138 E20000FF 		.loc 1 139 0
 143:../lib/io_driver.c **** 	}
 144:../lib/io_driver.c **** 
 145:../lib/io_driver.c **** 	temp = temp >> (port*8); // only keep designated byte
 146:../lib/io_driver.c **** 
 147:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 148:../lib/io_driver.c **** 	return (unsigned char)temp;
 149:../lib/io_driver.c **** }
 260              		ldr	r0, [r3, #-3983]
 261 013c E12FFF1E 	.LVL20:
 262              		.loc 1 142 0
 263              		mov	r0, r0, lsr r2
 264              	.LVL21:
 265 0140 E1A02180 		and	r0, r0, #255
 266              		.loc 1 149 0
 267              		bx	lr
 268 0144 E3E03A0F 	.LFE9:
 270              		.align	2
 271              		.global	io_uart0_read_byte
 273              	io_uart0_read_byte:
 274 0150 E20000FF 	.LFB10:
 275              		.loc 1 161 0
 276 0154 E12FFF1E 		@ args = 0, pretend = 0, frame = 0
 277              		@ frame_needed = 0, uses_anonymous_args = 0
 278              		@ link register save eliminated.
 279              		.loc 1 166 0
 280              		mvn	r2, #61440
 281              		ldr	r3, [r2, #-3835]
 282              		tst	r3, #2
 283              		mvn	r0, #0
 150:../lib/io_driver.c **** 
 151:../lib/io_driver.c **** 
 152:../lib/io_driver.c **** 
 153:../lib/io_driver.c **** // ################################################################################################
 154:../lib/io_driver.c **** // General Purpose UART "miniUART" (UART_0)
 155:../lib/io_driver.c **** // ################################################################################################
 156:../lib/io_driver.c **** 
 157:../lib/io_driver.c **** // ******************************************************************************
 158:../lib/io_driver.c **** // Read one byte via UART 0
 159:../lib/io_driver.c ****    int io_uart0_read_byte(void)
 160:../lib/io_driver.c **** // ******************************************************************************
 161:../lib/io_driver.c **** {
 284              	drne	r0, [r2, #-3839]
 285              		.loc 1 161 0
 286              		@ lr needed for prologue
 287              	.LVL23:
 162:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 163:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 164:../lib/io_driver.c **** 
 165:../lib/io_driver.c **** 	int temp;
 166:../lib/io_driver.c **** 	if ((UART0_SREG & (1<<CUART_RXD)) != 0) // byte available?
 288              	c 1 173 0
 289 0158 E3E02A0F 		bx	lr
 290 015c E5123EFB 	.LFE10:
 292 0164 E3E00000 		.align	2
 293              		.global	io_uart0_send_byte
 167:../lib/io_driver.c **** 		temp = UART0_DATA;
 294              		io_uart0_send_byte, %function
 295 0168 15120EFF 	io_uart0_send_byte:
 296              	.LFB11:
 297              		.loc 1 179 0
 298              		@ args = 0, pretend = 0, frame = 0
 168:../lib/io_driver.c **** 	else
 169:../lib/io_driver.c **** 		temp = -1;
 170:../lib/io_driver.c **** 
 171:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 172:../lib/io_driver.c **** 	return temp;
 173:../lib/io_driver.c **** }
 299              	ame_needed = 0, uses_anonymous_args = 0
 300 016c E12FFF1E 		@ link register save eliminated.
 301              	.LVL24:
 302              		@ lr needed for prologue
 303              		mvn	r2, #61440
 304              	.L39:
 305              		.loc 1 183 0
 306              		ldr	r3, [r2, #-3835]
 307              		tst	r3, #1
 174:../lib/io_driver.c **** 
 175:../lib/io_driver.c **** // ******************************************************************************
 176:../lib/io_driver.c **** // Write one byte via UART 0
 177:../lib/io_driver.c ****    int io_uart0_send_byte(int ch)
 178:../lib/io_driver.c **** // ******************************************************************************
 179:../lib/io_driver.c **** {
 308              	
 309              		.loc 1 184 0
 310              		and	r3, r0, #255
 311              		str	r3, [r2, #-3839]
 312              	.LVL25:
 313              		.loc 1 188 0
 314 0170 E3E02A0F 		bx	lr
 315              	.LFE11:
 180:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 181:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 182:../lib/io_driver.c **** 
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 316              	io_uart0_send_byte, .-io_uart0_send_byte
 317 0174 E5123EFB 		.align	2
 318 0178 E3130001 		.global	io_spi0_config
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 320              	pi0_config:
 321 0180 E20030FF 	.LFB12:
 322 0184 E5023EFF 		.loc 1 200 0
 323              		@ args = 0, pretend = 0, frame = 0
 185:../lib/io_driver.c **** 
 186:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 187:../lib/io_driver.c **** 	return ch;
 188:../lib/io_driver.c **** }
 324              	rame_needed = 0, uses_anonymous_args = 0
 325 0188 E12FFF1E 		@ link register save eliminated.
 326              	.LVL26:
 327              		and	r0, r0, #255
 328              		.loc 1 206 0
 329              		cmp	r0, #1
 330              		.loc 1 209 0
 331              		orr	r2, r1, #1024
 332              		.loc 1 207 0
 189:../lib/io_driver.c **** 
 190:../lib/io_driver.c **** 
 191:../lib/io_driver.c **** 
 192:../lib/io_driver.c **** // ################################################################################################
 193:../lib/io_driver.c **** // Serial Peripherial Interface (SPI_CONTROLLER_0)
 194:../lib/io_driver.c **** // ################################################################################################
 195:../lib/io_driver.c **** 
 196:../lib/io_driver.c **** // ******************************************************************************
 197:../lib/io_driver.c **** // Configure SPI 0
 198:../lib/io_driver.c ****    void io_spi0_config(unsigned char auto_cs, unsigned long data_size)
 199:../lib/io_driver.c **** // ******************************************************************************
 200:../lib/io_driver.c **** {
 333              	, #61440
 334              		orr	r1, r1, #9216
 335              	.LVL27:
 336              		.loc 1 209 0
 337              		mvnne	r3, #61440
 338 018c E20000FF 		.loc 1 200 0
 201:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 202:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 203:../lib/io_driver.c **** 	// devices update their serial input on a rising edge of sclk,
 204:../lib/io_driver.c **** 	// so we need to update the mosi output of the core before
 205:../lib/io_driver.c **** 	// -> at the falling edge of sclk = set SPI_TX_NEG
 206:../lib/io_driver.c **** 	if(auto_cs == 1)
 339              	needed for prologue
 340 0190 E3500001 		.loc 1 207 0
 207:../lib/io_driver.c **** 		SPI0_CONF = (1<<SPI_ACS) | (1<<SPI_TX_NEG) | data_size; // auto assert cs
 208:../lib/io_driver.c **** 	else
 209:../lib/io_driver.c **** 		SPI0_CONF = (0<<SPI_ACS) | (1<<SPI_TX_NEG) | data_size; // manual assert cs
 341              	treq	r1, [r3, #-3327]
 342 0194 E3812B01 		.loc 1 209 0
 343              		strne	r2, [r3, #-3327]
 344 0198 03E03A0F 		bx	lr
 345 019c E3811B09 	.LFE12:
 347              		.align	2
 348 01a0 13E03A0F 		.global	io_spi0_speed
 350              	io_spi0_speed:
 351              	.LFB13:
 352 01a4 05031CFF 		.loc 1 217 0
 353              		@ args = 0, pretend = 0, frame = 0
 354 01a8 15032CFF 		@ frame_needed = 0, uses_anonymous_args = 0
 355 01ac E12FFF1E 		@ link register save eliminated.
 356              	.LVL28:
 357              		.loc 1 221 0
 358              		mvn	r3, #61440
 359              		.loc 1 217 0
 360              		@ lr needed for prologue
 361              		.loc 1 221 0
 362              		str	r0, [r3, #-3323]
 210:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 211:../lib/io_driver.c **** }
 212:../lib/io_driver.c **** 
 213:../lib/io_driver.c **** // ******************************************************************************
 214:../lib/io_driver.c **** // Configure SPI 0 CLK frequency -> (sys_clk/(spi_clk*2))-1
 215:../lib/io_driver.c ****    void io_spi0_speed(unsigned long clk_divider)
 216:../lib/io_driver.c **** // ******************************************************************************
 217:../lib/io_driver.c **** {
 363              	LFE13:
 365              		.align	2
 366              		.global	io_spi0_trans
 218:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 219:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 220:../lib/io_driver.c **** 
 221:../lib/io_driver.c **** 		SPI0_PRSC = clk_divider; // (sys_clk/(spi_clk*2))-1;
 368              	i0_trans:
 369 01b0 E3E03A0F 	.LFB14:
 370              		.loc 1 230 0
 371              		@ args = 0, pretend = 0, frame = 0
 372              		@ frame_needed = 0, uses_anonymous_args = 0
 373 01b4 E5030CFB 		@ link register save eliminated.
 222:../lib/io_driver.c **** 
 223:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 224:../lib/io_driver.c **** }
 374              	:
 375 01b8 E12FFF1E 		@ lr needed for prologue
 376              		mvn	r2, #61440
 377              	.L53:
 378              		.loc 1 235 0
 379              		ldr	r3, [r2, #-3327]
 380              		tst	r3, #256
 381              		bne	.L53
 382              		.loc 1 236 0
 225:../lib/io_driver.c **** 
 226:../lib/io_driver.c **** // ******************************************************************************
 227:../lib/io_driver.c **** // Sends/receives max 32 bits via SPI, CS and config must be done outside
 228:../lib/io_driver.c ****    unsigned long io_spi0_trans(unsigned long data)
 229:../lib/io_driver.c **** // ******************************************************************************
 230:../lib/io_driver.c **** {
 383              	[r2, #-3311]
 384              		.loc 1 237 0
 385              		ldr	r3, [r2, #-3327]
 386              		orr	r3, r3, #256
 387              		str	r3, [r2, #-3327]
 388              		mvn	r2, #61440
 389 01bc E3E02A0F 	.L55:
 390              		.loc 1 238 0
 231:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 232:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 233:../lib/io_driver.c **** 
 234:../lib/io_driver.c **** 	// spi transmission
 235:../lib/io_driver.c **** 	while((SPI0_CONF & (1<<SPI_BUSY)) != 0); // wait for prev tx to finish
 391              	 [r2, #-3327]
 392 01c0 E5123CFF 		tst	r3, #256
 393 01c4 E3130C01 		bne	.L55
 394 01c8 1AFFFFFC 		.loc 1 239 0
 236:../lib/io_driver.c **** 	SPI0_DAT0 = data;
 395              		r0, [r2, #-3311]
 396 01cc E5020CEF 	.LVL30:
 237:../lib/io_driver.c **** 	SPI0_CONF = SPI0_CONF | (1<<SPI_BUSY); // start transmitter
 397              	VL31:
 398 01d0 E5123CFF 		.loc 1 243 0
 399 01d4 E3833C01 		bx	lr
 400 01d8 E5023CFF 	.LFE14:
 402              		.align	2
 238:../lib/io_driver.c **** 	while((SPI0_CONF & (1<<SPI_BUSY)) != 0); // wait for rx to finish
 403              	al	io_spi0_enable
 405 01e4 E3130C01 	io_spi0_enable:
 406 01e8 1AFFFFFC 	.LFB15:
 239:../lib/io_driver.c **** 	unsigned long temp = SPI0_DAT0;
 407              	c 1 249 0
 408 01ec E5120CEF 		@ args = 0, pretend = 0, frame = 0
 409              		@ frame_needed = 0, uses_anonymous_args = 0
 410              		@ link register save eliminated.
 240:../lib/io_driver.c **** 
 241:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 242:../lib/io_driver.c **** 	return temp;
 243:../lib/io_driver.c **** }
 411              	32:
 412 01f0 E12FFF1E 		.loc 1 253 0
 413              		mvn	r1, #61440
 414              		ldr	r3, [r1, #-3319]
 415              		.loc 1 249 0
 416              		and	r0, r0, #255
 417              		.loc 1 253 0
 418              		mov	r2, #1
 419              		orr	r3, r3, r2, asl r0
 244:../lib/io_driver.c **** 
 245:../lib/io_driver.c **** // ******************************************************************************
 246:../lib/io_driver.c **** // Controls the CS of SPI0, enables a connected CS (turns it LOW)
 247:../lib/io_driver.c ****    void io_spi0_enable(unsigned char device)
 248:../lib/io_driver.c **** // ******************************************************************************
 249:../lib/io_driver.c **** {
 420              	49 0
 421              		@ lr needed for prologue
 422              		.loc 1 253 0
 423              		str	r3, [r1, #-3319]
 424              		.loc 1 256 0
 250:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 251:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 252:../lib/io_driver.c **** 
 253:../lib/io_driver.c **** 		SPI0_SCSR = SPI0_SCSR | (1<<device);
 425              	r
 426 01f4 E3E01A0F 	.LFE15:
 428              		.align	2
 429 01fc E20000FF 		.global	io_spi0_disable
 431 0200 E3A02001 	io_spi0_disable:
 432 0204 E1833012 	.LFB16:
 433              		.loc 1 262 0
 434              		@ args = 0, pretend = 0, frame = 0
 435              		@ frame_needed = 0, uses_anonymous_args = 0
 436 0208 E5013CF7 		@ link register save eliminated.
 254:../lib/io_driver.c **** 
 255:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 256:../lib/io_driver.c **** }
 437              		r0, r0, #255
 438 020c E12FFF1E 		.loc 1 266 0
 439              		mov	r2, #1
 440              		mov	r2, r2, asl r0
 441              		mvn	r1, #61440
 442              		ldr	r3, [r1, #-3319]
 443              		mvn	r2, r2
 444              		and	r3, r3, r2
 445              		.loc 1 262 0
 257:../lib/io_driver.c **** 
 258:../lib/io_driver.c **** // ******************************************************************************
 259:../lib/io_driver.c **** // Controls the CS of SPI0, disables a connected CS (turns it HIGH)
 260:../lib/io_driver.c ****    void io_spi0_disable(unsigned char device)
 261:../lib/io_driver.c **** // ******************************************************************************
 262:../lib/io_driver.c **** {
 446              	ded for prologue
 447              		.loc 1 266 0
 448              		str	r3, [r1, #-3319]
 449              		.loc 1 269 0
 450              		bx	lr
 451 0210 E20000FF 	.LFE16:
 263:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 264:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 265:../lib/io_driver.c **** 
 266:../lib/io_driver.c **** 		SPI0_SCSR = SPI0_SCSR & ~(1<<device);
 452              		io_spi0_disable, .-io_spi0_disable
 453 0214 E3A02001 		.align	2
 454 0218 E1A02012 		.global	io_i2c0_speed
 456 0220 E5113CF7 	io_i2c0_speed:
 457 0224 E1E02002 	.LFB17:
 458 0228 E0033002 		.loc 1 282 0
 459              		@ args = 0, pretend = 0, frame = 0
 460              		@ frame_needed = 0, uses_anonymous_args = 0
 461              		@ link register save eliminated.
 462 022c E5013CF7 	.LVL34:
 267:../lib/io_driver.c **** 
 268:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 269:../lib/io_driver.c **** }
 463              	 0
 464 0230 E12FFF1E 		mvn	r2, #61440
 465              		ldr	r3, [r2, #-3047]
 466              		.loc 1 287 0
 467              		mov	r1, r0, lsr #8
 468              		.loc 1 285 0
 469              		bic	r3, r3, #128
 470              		str	r3, [r2, #-3047]
 471              		.loc 1 286 0
 270:../lib/io_driver.c **** 
 271:../lib/io_driver.c **** 
 272:../lib/io_driver.c **** 
 273:../lib/io_driver.c **** 
 274:../lib/io_driver.c **** // ################################################################################################
 275:../lib/io_driver.c **** // Inter Intergrated Circuit Interface (I²C_CONTROLLER_0)
 276:../lib/io_driver.c **** // ################################################################################################
 277:../lib/io_driver.c **** 
 278:../lib/io_driver.c **** // ******************************************************************************
 279:../lib/io_driver.c **** // Configure SPI 0 CLK frequency -> (sys_clk/(5*i2c_clock)-1
 280:../lib/io_driver.c ****    void io_i2c0_speed(unsigned long clk_divider)
 281:../lib/io_driver.c **** // ******************************************************************************
 282:../lib/io_driver.c **** {
 472              	[r2, #-3055]
 473              		.loc 1 287 0
 474              		str	r1, [r2, #-3051]
 475              		.loc 1 288 0
 476              		ldr	r3, [r2, #-3047]
 283:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 284:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 285:../lib/io_driver.c **** 		I2C0_CTRL = I2C0_CTRL & ~(1<<I2C_EN); // disable i2c core
 477              	r3, r3, #128
 478 0234 E3E02A0F 		.loc 1 282 0
 479 0238 E5123BE7 		@ lr needed for prologue
 286:../lib/io_driver.c **** 		I2C0_PRLO = clk_divider;
 287:../lib/io_driver.c **** 		I2C0_PRHI = clk_divider >> 8;
 480              	oc 1 288 0
 481 023c E1A01420 		str	r3, [r2, #-3047]
 482              		.loc 1 290 0
 483 0240 E3C33080 		bx	lr
 484 0244 E5023BE7 	.LFE17:
 486 0248 E5020BEF 		.align	2
 487              		.global	io_i2c0_byte_transfer
 288:../lib/io_driver.c **** 		I2C0_CTRL = I2C0_CTRL | (1<<I2C_EN); // enable i2c core
 489              	yte_transfer:
 490 0250 E5123BE7 	.LFB18:
 491 0254 E3833080 		.loc 1 300 0
 492              		@ args = 4, pretend = 0, frame = 0
 493              		@ frame_needed = 0, uses_anonymous_args = 0
 494              	.LVL35:
 495 0258 E5023BE7 		stmfd	sp!, {r4, r5, lr}
 289:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 290:../lib/io_driver.c **** }
 496              	
 497 025c E12FFF1E 		.loc 1 306 0
 498              		mov	ip, #144
 499              		.loc 1 305 0
 500              		and	r4, r1, #254
 501              		mvn	lr, #61440
 502              	.LVL36:
 503              		.loc 1 300 0
 504              		ldrb	r5, [sp, #15]	@ zero_extendqisi2
 291:../lib/io_driver.c **** 
 292:../lib/io_driver.c **** // ******************************************************************************
 293:../lib/io_driver.c **** // Read/write byte from/to I²C slave, max 2 address bytes
 294:../lib/io_driver.c ****    int io_i2c0_byte_transfer(unsigned char rw,        // 'r' read / 'w' write cycle
 295:../lib/io_driver.c ****                              unsigned char id,        // device ID
 296:../lib/io_driver.c **** 							 unsigned long data_adr,  // data address
 297:../lib/io_driver.c **** 							 unsigned char adr_bytes, // number of adr bytes
 298:../lib/io_driver.c **** 							 unsigned char data)      // data byte
 299:../lib/io_driver.c **** // ******************************************************************************
 300:../lib/io_driver.c **** {
 505              	 r0, #255
 506              		.loc 1 305 0
 507              		str	r4, [lr, #-3043]
 508              		.loc 1 300 0
 509 0260 E92D4030 		and	r1, r1, #255
 510              		.loc 1 306 0
 301:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 302:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 303:../lib/io_driver.c **** 
 304:../lib/io_driver.c **** 	// transfer slave identification address
 305:../lib/io_driver.c **** 	I2C0_DATA = id & 0xFE;                  // device id and write
 306:../lib/io_driver.c **** 	I2C0_CMD = (1<<I2C_STA) | (1<<I2C_WR);  // start condition and write cycle
 511              	p, [lr, #-3071]
 512 0264 E3A0C090 		.loc 1 300 0
 513              		mov	r4, r2
 514 0268 E20140FE 		and	ip, r3, #255
 515 026c E3E0EA0F 	.LVL37:
 516              	.L69:
 517              		.loc 1 307 0
 518 0270 E5DD500F 		ldr	r3, [lr, #-3071]
 519 0274 E20000FF 		tst	r3, #2
 520              		bne	.L69
 521 0278 E50E4BE3 		.loc 1 308 0
 522              		ldr	r3, [lr, #-3071]
 523 027c E20110FF 		tst	r3, #128
 524              		mvnne	r0, #0
 525 0280 E50ECBFF 	.LVL38:
 526              		ldmnefd	sp!, {r4, r5, pc}
 527 0284 E1A04002 	.L80:
 528 0288 E203C0FF 		.loc 1 314 0
 529              		cmp	ip, #0
 530              		beq	.L109
 307:../lib/io_driver.c **** 	while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
 531              	3, ip, #1
 532 028c E51E3BFF 		and	ip, r3, #255
 533 0290 E3130002 		.loc 1 316 0
 534 0294 1AFFFFFC 		cmp	ip, #1
 308:../lib/io_driver.c **** 	if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
 535              	c 1 317 0
 536 0298 E51E3BFF 		moveq	r2, r4, lsr #8
 537 029c E3130080 		mvneq	r3, #61440
 538 02a0 13E00000 		.loc 1 319 0
 539              		mvnne	r3, #61440
 540 02a4 18BD8030 		.loc 1 317 0
 541              		streq	r2, [r3, #-3043]
 309:../lib/io_driver.c **** //		set_cmsr(_cmsr);
 310:../lib/io_driver.c **** 		return -1;
 311:../lib/io_driver.c **** 	}
 312:../lib/io_driver.c **** 
 313:../lib/io_driver.c **** 	// transfer data address
 314:../lib/io_driver.c **** 	while(adr_bytes != 0){
 542              	 319 0
 543 02a8 E35C0000 		strne	r4, [r3, #-3043]
 544 02ac 0A000012 		.loc 1 320 0
 315:../lib/io_driver.c **** 		adr_bytes--;
 545              	n	r2, #61440
 546 02b0 E24C3001 		mov	r3, #16
 547 02b4 E203C0FF 		str	r3, [r2, #-3071]
 316:../lib/io_driver.c **** 		if(adr_bytes == 1)
 548              	8:
 549 02b8 E35C0001 		.loc 1 321 0
 317:../lib/io_driver.c **** 			I2C0_DATA = data_adr >> 8;          // high byte
 550              	dr	r3, [r2, #-3071]
 551 02bc 01A02424 		tst	r3, #2
 552 02c0 03E03A0F 		bne	.L78
 318:../lib/io_driver.c **** 		else
 319:../lib/io_driver.c **** 			I2C0_DATA = data_adr;               // low byte
 553              	oc 1 322 0
 554 02c4 13E03A0F 		ldr	r3, [r2, #-3071]
 555              		tst	r3, #128
 556 02c8 05032BE3 		beq	.L80
 557              		mvn	r0, #1
 558 02cc 15034BE3 		ldmfd	sp!, {r4, r5, pc}
 320:../lib/io_driver.c **** 		I2C0_CMD = (1<<I2C_WR);                 // write cycle
 559              	:
 560 02d0 E3E02A0F 	.L109:
 561 02d4 E3A03010 	.LVL40:
 562 02d8 E5023BFF 		.loc 1 328 0
 563              		cmp	r0, #119
 321:../lib/io_driver.c **** 		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
 564              	.L83
 565 02dc E5123BFF 		.loc 1 330 0
 566 02e0 E3130002 		mvn	r3, #61440
 567 02e4 1AFFFFFC 		.loc 1 331 0
 322:../lib/io_driver.c **** 		if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
 568              		r2, #80
 569 02e8 E5123BFF 		.loc 1 330 0
 570 02ec E3130080 		str	r5, [r3, #-3043]
 571 02f0 0AFFFFEC 		.loc 1 331 0
 572 02f4 E3E00001 		str	r2, [r3, #-3071]
 573 02f8 E8BD8030 		mov	r2, r3
 574              	.L85:
 575              		.loc 1 332 0
 576              		ldr	r3, [r2, #-3071]
 323:../lib/io_driver.c **** //			set_cmsr(_cmsr);
 324:../lib/io_driver.c **** 			return -2;
 325:../lib/io_driver.c **** 		}
 326:../lib/io_driver.c **** 	}
 327:../lib/io_driver.c **** 
 328:../lib/io_driver.c **** 	if(rw == 'w'){
 577              	#2
 578 02fc E3500077 		bne	.L85
 579 0300 1A00000C 		.loc 1 333 0
 329:../lib/io_driver.c **** 		// write adressed byte
 330:../lib/io_driver.c **** 		I2C0_DATA = data;                       // send data
 580              	r	r3, [r2, #-3071]
 581 0304 E3E03A0F 		ands	r0, r3, #128
 331:../lib/io_driver.c **** 		I2C0_CMD = (1<<I2C_STO) | (1<<I2C_WR);  // stop condition and write cycle
 582              	VL41:
 583 0308 E3A02050 		ldmeqfd	sp!, {r4, r5, pc}
 584              	.L87:
 585 030c E5035BE3 		.loc 1 355 0
 586              		mvn	r0, #2
 587 0310 E5032BFF 		.loc 1 360 0
 588 0314 E1A02003 		ldmfd	sp!, {r4, r5, pc}
 589              	.LVL42:
 332:../lib/io_driver.c **** 		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
 590              	loc 1 343 0
 591 0318 E5123BFF 		cmp	r0, #114
 592 031c E3130002 		mvnne	r0, #3
 593 0320 1AFFFFFC 	.LVL43:
 333:../lib/io_driver.c **** 		if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
 594              	nefd	sp!, {r4, r5, pc}
 595 0324 E5123BFF 		.loc 1 345 0
 596 0328 E2130080 		orr	r3, r1, #1
 597              		mvn	r2, #61440
 598 032c 08BD8030 		.loc 1 346 0
 599              		mov	r1, #144
 334:../lib/io_driver.c **** //			set_cmsr(_cmsr);
 335:../lib/io_driver.c **** 			return -3;
 336:../lib/io_driver.c **** 		}
 337:../lib/io_driver.c **** 		else{
 338:../lib/io_driver.c **** //			set_cmsr(_cmsr);
 339:../lib/io_driver.c **** 			return 0;
 340:../lib/io_driver.c **** 		}
 341:../lib/io_driver.c **** 	}
 342:../lib/io_driver.c **** 
 343:../lib/io_driver.c **** 	if(rw == 'r'){
 344:../lib/io_driver.c **** 		// re-send control byte - this time with read-bit
 345:../lib/io_driver.c **** 		I2C0_DATA = id | 0x01;                  // device id and READ
 346:../lib/io_driver.c **** 		I2C0_CMD = (1<<I2C_STA) | (1<<I2C_WR);  // start condition and write cycle
 347:../lib/io_driver.c **** 		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
 348:../lib/io_driver.c **** 		if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
 349:../lib/io_driver.c **** //			set_cmsr(_cmsr);
 350:../lib/io_driver.c **** 			return -3;
 351:../lib/io_driver.c **** 		}
 352:../lib/io_driver.c **** 		// read adressed byte
 353:../lib/io_driver.c **** 		I2C0_CMD = (1<<I2C_STO) | (1<<I2C_RD) | (1<<I2C_ACK);
 354:../lib/io_driver.c **** 		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
 355:../lib/io_driver.c **** 		return I2C0_DATA;
 600              	:
 601 0330 E3E00002 		.loc 1 345 0
 356:../lib/io_driver.c **** 	}
 357:../lib/io_driver.c **** 
 358:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 359:../lib/io_driver.c **** 	return -4;
 360:../lib/io_driver.c **** }
 602              	tr	r3, [r2, #-3043]
 603 0334 E8BD8030 		.loc 1 346 0
 604              		str	r1, [r2, #-3071]
 605              	.L91:
 606              		.loc 1 347 0
 607 0338 E3500072 		ldr	r3, [r2, #-3071]
 608 033c 13E00003 		tst	r3, #2
 609              		bne	.L91
 610 0340 18BD8030 		.loc 1 348 0
 611              		ldr	r3, [r2, #-3071]
 612 0344 E3813001 		tst	r3, #128
 613 0348 E3E02A0F 		bne	.L87
 614              		.loc 1 353 0
 615 034c E3A01090 		mov	r3, #104
 616              		str	r3, [r2, #-3071]
 617              		mvn	r0, #61440
 618 0350 E5023BE3 	.L94:
 619              		.loc 1 354 0
 620 0354 E5021BFF 		ldr	r3, [r0, #-3071]
 621              		tst	r3, #2
 622              		bne	.L94
 623 0358 E5123BFF 		.loc 1 355 0
 624 035c E3130002 		ldr	r0, [r0, #-3043]
 625 0360 1AFFFFFC 		ldmfd	sp!, {r4, r5, pc}
 626              	.LFE18:
 628 0368 E3130080 		.align	2
 629 036c 1AFFFFEF 		.global	get_syscpreg
 631 0370 E3A03068 	get_syscpreg:
 632 0374 E5023BFF 	.LFB19:
 633 0378 E3E00A0F 		.loc 1 373 0
 634              		@ args = 0, pretend = 0, frame = 0
 635              		@ frame_needed = 0, uses_anonymous_args = 0
 636 037c E5103BFF 		@ link register save eliminated.
 637 0380 E3130002 	.LVL45:
 638 0384 1AFFFFFC 		and	r0, r0, #255
 639              		@ lr needed for prologue
 640 0388 E5100BE3 		.loc 1 375 0
 641 038c E8BD8030 		cmp	r0, #15
 642              		ldrls	pc, [pc, r0, asl #2]
 643              		b	.L111
 644              		.p2align 2
 645              	.L128:
 646              		.word	.L112
 647              		.word	.L113
 648              		.word	.L114
 361:../lib/io_driver.c **** 
 362:../lib/io_driver.c **** 
 363:../lib/io_driver.c **** 
 364:../lib/io_driver.c **** 
 365:../lib/io_driver.c **** // ################################################################################################
 366:../lib/io_driver.c **** // System
 367:../lib/io_driver.c **** // ################################################################################################
 368:../lib/io_driver.c **** 
 369:../lib/io_driver.c **** // ******************************************************************************
 370:../lib/io_driver.c **** // read system coprocessor register x
 371:../lib/io_driver.c ****    unsigned long get_syscpreg(unsigned char index)
 372:../lib/io_driver.c **** // ******************************************************************************
 373:../lib/io_driver.c **** {
 649              	L118
 650              		.word	.L119
 651              		.word	.L120
 652              		.word	.L121
 653              		.word	.L122
 654 0390 E20000FF 		.word	.L123
 655              		.word	.L124
 374:../lib/io_driver.c **** 	unsigned long _cp_val;
 375:../lib/io_driver.c **** 	switch(index){
 656              	.L125
 657 0394 E350000F 		.word	.L126
 658 0398 979FF100 		.word	.L127
 659 039c EA00000F 	.L111:
 660              		mov	r0, #0
 661              	.LVL46:
 662 03a0 00000460 		bx	lr
 663 03a4 00000458 	.LVL47:
 664 03a8 00000450 	.L127:
 665 03ac 00000448 		.loc 1 391 0
 666 03b0 00000440 		mrc p15,0,r0,c15,c15
 667 03b4 00000438 	.LVL48:
 668 03b8 00000430 	.LVL49:
 669 03bc 00000428 		.loc 1 395 0
 670 03c0 00000420 		bx	lr
 671 03c4 00000418 	.LVL50:
 672 03c8 00000410 	.L126:
 673 03cc 00000408 		.loc 1 390 0
 674 03d0 00000400 		mrc p15,0,r0,c14,c14
 675 03d4 000003F8 	.LVL51:
 676 03d8 000003F0 		bx	lr
 677 03dc 000003E8 	.LVL52:
 678              	.L125:
 679 03e0 E3A00000 		.loc 1 389 0
 680              		mrc p15,0,r0,c13,c13
 681 03e4 E12FFF1E 	.LVL53:
 682              		bx	lr
 683              	.LVL54:
 376:../lib/io_driver.c **** 		case ID_REG_0:   asm volatile ("mrc p15,0,%0, c0, c0" : "=r" (_cp_val) : /* no inputs */  ); brea
 377:../lib/io_driver.c **** 		case ID_REG_1:   asm volatile ("mrc p15,0,%0, c1, c1" : "=r" (_cp_val) : /* no inputs */  ); brea
 378:../lib/io_driver.c **** 		case ID_REG_2:   asm volatile ("mrc p15,0,%0, c2, c2" : "=r" (_cp_val) : /* no inputs */  ); brea
 379:../lib/io_driver.c **** 		case 3:          asm volatile ("mrc p15,0,%0, c3, c3" : "=r" (_cp_val) : /* no inputs */  ); brea
 380:../lib/io_driver.c **** 		case 4:          asm volatile ("mrc p15,0,%0, c4, c4" : "=r" (_cp_val) : /* no inputs */  ); brea
 381:../lib/io_driver.c **** 		case 5:          asm volatile ("mrc p15,0,%0, c5, c5" : "=r" (_cp_val) : /* no inputs */  ); brea
 382:../lib/io_driver.c **** 		case SYS_CTRL_0: asm volatile ("mrc p15,0,%0, c6, c6" : "=r" (_cp_val) : /* no inputs */  ); brea
 383:../lib/io_driver.c **** 		case 7:          asm volatile ("mrc p15,0,%0, c7, c7" : "=r" (_cp_val) : /* no inputs */  ); brea
 384:../lib/io_driver.c **** 		case CSTAT:      asm volatile ("mrc p15,0,%0, c8, c8" : "=r" (_cp_val) : /* no inputs */  ); brea
 385:../lib/io_driver.c **** 		case ADR_FB:     asm volatile ("mrc p15,0,%0, c9, c9" : "=r" (_cp_val) : /* no inputs */  ); brea
 386:../lib/io_driver.c **** 		case 10:         asm volatile ("mrc p15,0,%0,c10,c10" : "=r" (_cp_val) : /* no inputs */  ); brea
 387:../lib/io_driver.c **** 		case LFSR_POLY:  asm volatile ("mrc p15,0,%0,c11,c11" : "=r" (_cp_val) : /* no inputs */  ); brea
 388:../lib/io_driver.c **** 		case LFSR_DATA:  asm volatile ("mrc p15,0,%0,c12,c12" : "=r" (_cp_val) : /* no inputs */  ); brea
 389:../lib/io_driver.c **** 		case SYS_IO:     asm volatile ("mrc p15,0,%0,c13,c13" : "=r" (_cp_val) : /* no inputs */  ); brea
 390:../lib/io_driver.c **** 		case 14:         asm volatile ("mrc p15,0,%0,c14,c14" : "=r" (_cp_val) : /* no inputs */  ); brea
 391:../lib/io_driver.c **** 		case 15:         asm volatile ("mrc p15,0,%0,c15,c15" : "=r" (_cp_val) : /* no inputs */  ); brea
 684              	5,0,r0,c12,c12
 685 03e8 EE1F0F1F 	.LVL55:
 686              		bx	lr
 687              	.LVL56:
 392:../lib/io_driver.c **** 		default:         _cp_val = 0; break;
 393:../lib/io_driver.c **** 	}
 394:../lib/io_driver.c **** 	return _cp_val;
 395:../lib/io_driver.c **** }
 688              	3:
 689 03ec E12FFF1E 		.loc 1 387 0
 690              		mrc p15,0,r0,c11,c11
 691              	.LVL57:
 692              		bx	lr
 693 03f0 EE1E0F1E 	.LVL58:
 694              	.L122:
 695 03f4 E12FFF1E 		.loc 1 386 0
 696              		mrc p15,0,r0,c10,c10
 697              	.LVL59:
 698              		bx	lr
 699 03f8 EE1D0F1D 	.LVL60:
 700              	.L121:
 701 03fc E12FFF1E 		.loc 1 385 0
 702              		mrc p15,0,r0, c9, c9
 703              	.LVL61:
 704              		bx	lr
 705 0400 EE1C0F1C 	.LVL62:
 706              	.L120:
 707 0404 E12FFF1E 		.loc 1 384 0
 708              		mrc p15,0,r0, c8, c8
 709              	.LVL63:
 710              		bx	lr
 711 0408 EE1B0F1B 	.LVL64:
 712              	.L119:
 713 040c E12FFF1E 		.loc 1 383 0
 714              		mrc p15,0,r0, c7, c7
 715              	.LVL65:
 716              		bx	lr
 717 0410 EE1A0F1A 	.LVL66:
 718              	.L118:
 719 0414 E12FFF1E 		.loc 1 382 0
 720              		mrc p15,0,r0, c6, c6
 721              	.LVL67:
 722              		bx	lr
 723 0418 EE190F19 	.LVL68:
 724              	.L117:
 725 041c E12FFF1E 		.loc 1 381 0
 726              		mrc p15,0,r0, c5, c5
 727              	.LVL69:
 728              		bx	lr
 729 0420 EE180F18 	.LVL70:
 730              	.L116:
 731 0424 E12FFF1E 		.loc 1 380 0
 732              		mrc p15,0,r0, c4, c4
 733              	.LVL71:
 734              		bx	lr
 735 0428 EE170F17 	.LVL72:
 736              	.L115:
 737 042c E12FFF1E 		.loc 1 379 0
 738              		mrc p15,0,r0, c3, c3
 739              	.LVL73:
 740              		bx	lr
 741 0430 EE160F16 	.LVL74:
 742              	.L114:
 743 0434 E12FFF1E 		.loc 1 378 0
 744              		mrc p15,0,r0, c2, c2
 745              	.LVL75:
 746              		bx	lr
 747 0438 EE150F15 	.LVL76:
 748              	.L113:
 749 043c E12FFF1E 		.loc 1 377 0
 750              		mrc p15,0,r0, c1, c1
 751              	.LVL77:
 752              		bx	lr
 753 0440 EE140F14 	.LVL78:
 754              	.L112:
 755 0444 E12FFF1E 		.loc 1 376 0
 756              		mrc p15,0,r0, c0, c0
 757              	.LVL79:
 758              		bx	lr
 759 0448 EE130F13 	.LFE19:
 761 044c E12FFF1E 		.align	2
 762              		.global	set_syscpreg
 764              	set_syscpreg:
 765 0450 EE120F12 	.LFB20:
 766              		.loc 1 401 0
 767 0454 E12FFF1E 		@ args = 0, pretend = 0, frame = 0
 768              		@ frame_needed = 0, uses_anonymous_args = 0
 769              		@ link register save eliminated.
 770              	.LVL80:
 771 0458 EE110F11 		and	r1, r1, #255
 772              		.loc 1 402 0
 773 045c E12FFF1E 		sub	r1, r1, #6
 774              	.LVL81:
 775              		.loc 1 401 0
 776              		@ lr needed for prologue
 777 0460 EE100F10 		.loc 1 402 0
 778              		cmp	r1, #7
 779 0464 E12FFF1E 		ldrls	pc, [pc, r1, asl #2]
 780              		b	.L138
 781              		.p2align 2
 782              	.L137:
 783              		.word	.L133
 784              		.word	.L138
 785              		.word	.L138
 786              		.word	.L138
 396:../lib/io_driver.c **** 
 397:../lib/io_driver.c **** // ******************************************************************************
 398:../lib/io_driver.c **** // write system coprocessor register x
 399:../lib/io_driver.c ****    void set_syscpreg(unsigned long _cp_val, unsigned char index)
 400:../lib/io_driver.c **** // ******************************************************************************
 401:../lib/io_driver.c **** {
 787              	138:
 788              		bx	lr
 789              	.L133:
 790              		.loc 1 409 0
 791              		mcr p15,0,r0, c6, c6,0
 792 0468 E20110FF 		bx	lr
 402:../lib/io_driver.c **** 	switch(index){
 793              	
 794 046c E2411006 		.loc 1 414 0
 795              		mcr p15,0,r0,c11,c11,0
 796              		bx	lr
 797              	.L135:
 798              		.loc 1 415 0
 799 0470 E3510007 		mcr p15,0,r0,c12,c12,0
 800 0474 979FF101 		bx	lr
 801 0478 EA000008 	.LFE20:
 803              		.align	2
 804 047c 000004A4 		.global	uart0_printf
 806 0484 000004A0 	uart0_printf:
 807 0488 000004A0 	.LFB25:
 808 048c 000004A0 		.file 2 "../lib/uart.c"
 809 0490 000004AC 		.loc 2 7 0
 810 0494 000004B4 		@ args = 0, pretend = 0, frame = 0
 811 0498 0000049C 		@ frame_needed = 0, uses_anonymous_args = 0
 812              	.LVL82:
 403:../lib/io_driver.c **** //		case ID_REG_0:   asm volatile ("mcr p15,0,%0, c0, c0,0" : /* no outputs */ : "r" (_cp_val)); br
 404:../lib/io_driver.c **** //		case ID_REG_1:   asm volatile ("mcr p15,0,%0, c1, c1,0" : /* no outputs */ : "r" (_cp_val)); br
 405:../lib/io_driver.c **** //		case ID_REG_2:   asm volatile ("mcr p15,0,%0, c2, c2,0" : /* no outputs */ : "r" (_cp_val)); br
 406:../lib/io_driver.c **** //		case 3:          asm volatile ("mcr p15,0,%0, c3, c3,0" : /* no outputs */ : "r" (_cp_val)); br
 407:../lib/io_driver.c **** //		case 4:          asm volatile ("mcr p15,0,%0, c4, c4,0" : /* no outputs */ : "r" (_cp_val)); br
 408:../lib/io_driver.c **** //		case 5:          asm volatile ("mcr p15,0,%0, c5, c5,0" : /* no outputs */ : "r" (_cp_val)); br
 409:../lib/io_driver.c **** 		case SYS_CTRL_0: asm volatile ("mcr p15,0,%0, c6, c6,0" : /* no outputs */ : "r" (_cp_val)); brea
 410:../lib/io_driver.c **** //		case 7:          asm volatile ("mcr p15,0,%0, c7, c7,0" : /* no outputs */ : "r" (_cp_val)); br
 411:../lib/io_driver.c **** //		case CSTAT:      asm volatile ("mcr p15,0,%0, c8, c8,0" : /* no outputs */ : "r" (_cp_val)); br
 412:../lib/io_driver.c **** //		case ADR_FB:     asm volatile ("mcr p15,0,%0, c9, c9,0" : /* no outputs */ : "r" (_cp_val)); br
 413:../lib/io_driver.c **** //		case 10:         asm volatile ("mcr p15,0,%0,c10,c10,0" : /* no outputs */ : "r" (_cp_val)); br
 414:../lib/io_driver.c **** 		case LFSR_POLY:  asm volatile ("mcr p15,0,%0,c11,c11,0" : /* no outputs */ : "r" (_cp_val)); brea
 415:../lib/io_driver.c **** 		case LFSR_DATA:  asm volatile ("mcr p15,0,%0,c12,c12,0" : /* no outputs */ : "r" (_cp_val)); brea
 416:../lib/io_driver.c **** 		case SYS_IO:     asm volatile ("mcr p15,0,%0,c13,c13,0" : /* no outputs */ : "r" (_cp_val)); brea
 813              	}
 814 049c EE0D0F1D 	.LCFI2:
 815              		.loc 2 7 0
 816 04a0 E12FFF1E 		mov	r4, r0
 817              		.loc 2 10 0
 818              		ldrb	r0, [r0, #0]	@ zero_extendqisi2
 819 04a4 EE060F16 	.LVL83:
 820 04a8 E12FFF1E 		cmp	r0, #0
 821              		bne	.L144
 822              		b	.L140
 823 04ac EE0B0F1B 	.LVL84:
 824 04b0 E12FFF1E 	.L146:
 825              		ldrb	r0, [r4, #1]!	@ zero_extendqisi2
 826              	.LVL85:
 827 04b4 EE0C0F1C 		cmp	r0, #0
 828 04b8 E12FFF1E 		beq	.L140
 829              	.L144:
 830              		.loc 2 11 0
 831              		bl	io_uart0_send_byte
 832              	.LVL86:
 833              		cmp	r0, #0
 834              		bgt	.L146
 835              	.LVL87:
 836              	.L140:
   1:../lib/uart.c **** #include "uart.h"
   2:../lib/uart.c **** 
   3:../lib/uart.c **** // ############################################################################################
   4:../lib/uart.c **** // Print text string via UART 0
   5:../lib/uart.c ****    const char *uart0_printf(const char *string)
   6:../lib/uart.c **** // ############################################################################################
   7:../lib/uart.c **** {
 837              	
 838              	.LVL88:
 839              		ldmfd	sp!, {r4, pc}
 840              	.LFE25:
 842              		.section	.rodata
 843              		.align	2
 844 04c0 E1A04000 	.LC0:
   8:../lib/uart.c **** 	char ch;
   9:../lib/uart.c **** 
  10:../lib/uart.c **** 	while ((ch = *string)){
 845              		"\000\000"
 846 04c4 E5D00000 		.text
 847              		.align	2
 848 04c8 E3500000 		.global	uart0_scanf
 850 04d0 EA000005 	uart0_scanf:
 851              	.LFB26:
 852              		.loc 2 22 0
 853 04d4 E5F40001 		@ args = 0, pretend = 0, frame = 0
 854              		@ frame_needed = 0, uses_anonymous_args = 0
 855 04d8 E3500000 	.LVL89:
 856 04dc 0A000002 		stmfd	sp!, {r4, r5, r6, lr}
 857              	.LCFI3:
  11:../lib/uart.c **** 		if (io_uart0_send_byte(ch)<=0)
 858              		subs	r4, r1, #0
 859 04e0 EBFFFFFE 		.loc 2 22 0
 860              		mov	r5, r0
 861 04e4 E3500000 		and	r6, r2, #255
 862 04e8 CAFFFFF9 		.loc 2 25 0
 863              		ble	.L148
 864              	.LVL90:
  12:../lib/uart.c **** 			break;
  13:../lib/uart.c **** 		string++;
  14:../lib/uart.c **** 	}
  15:../lib/uart.c **** 	return string;
  16:../lib/uart.c **** }
 865              		.loc 2 26 0
 866 04ec E1A00004 		bl	io_uart0_read_byte
 867              	.LVL91:
 868 04f0 E8BD8010 	.LVL92:
 869              		.loc 2 27 0
 870              		cmn	r0, #1
 871              		.loc 2 28 0
 872              		and	r3, r0, #255
 873              	.LVL93:
 874 0000 0000     		.loc 2 27 0
 875 0002 0000     		beq	.L150
 876              		.loc 2 30 0
 877              		cmp	r6, #1
 878              	.LVL94:
 879              		.loc 2 29 0
 880              		strb	r3, [r5, #0]
  17:../lib/uart.c **** 
  18:../lib/uart.c **** // ############################################################################################
  19:../lib/uart.c **** // Read text string via UART 0
  20:../lib/uart.c ****    void uart0_scanf(unsigned char *buffer, int length, unsigned char en_echo)
  21:../lib/uart.c **** // ############################################################################################
  22:../lib/uart.c **** {
 881              	31 0
 882              		mov	r0, r3
 883              	.LVL96:
 884              		.loc 2 29 0
 885 04f4 E92D4070 		add	r5, r5, #1
 886              		.loc 2 30 0
  23:../lib/uart.c **** 	int temp = 0;
  24:../lib/uart.c **** 
  25:../lib/uart.c **** 	while(length > 0){
 887              	L157
 888 04f8 E2514000 	.LVL97:
 889              	.L152:
 890 04fc E1A05000 		.loc 2 32 0
 891 0500 E20260FF 		sub	r4, r4, #1
 892              	.LVL98:
 893 0504 DA00000B 	.L150:
 894              		.loc 2 25 0
 895              		cmp	r4, #0
  26:../lib/uart.c **** 		temp = io_uart0_read_byte();
 896              	5
 897 0508 EBFFFFFE 	.LVL99:
 898              	.L148:
 899              		.loc 2 35 0
  27:../lib/uart.c **** 		if(temp != -1){
 900              		r3, .L158
 901 050c E3700001 	.LVL100:
  28:../lib/uart.c **** 			temp = (unsigned char)(temp & 0x000000FF);
 902              	trb	r3, [r5, #0]
 903 0510 E20030FF 		.loc 2 36 0
 904              		ldmfd	sp!, {r4, r5, r6, pc}
 905              	.LVL101:
 906 0514 0A000005 	.L157:
  29:../lib/uart.c **** 			*buffer++ = temp;
  30:../lib/uart.c **** 			if(en_echo == 1)
 907              	 2 31 0
 908 0518 E3560001 		bl	io_uart0_send_byte
 909              	.LVL102:
 910              		b	.L152
 911 051c E5C53000 	.L159:
 912              		.align	2
  31:../lib/uart.c **** 				io_uart0_send_byte(temp); // echo
 913              	
 914 0520 E1A00003 		.word	.LC0
 915              	.LFE26:
 917 0524 E2855001 		.align	2
 918              		.global	uart0_print_buffer
 920              	uart0_print_buffer:
 921              	.LFB27:
  32:../lib/uart.c **** 			length--;
 922              	42 0
 923 052c E2444001 		@ args = 0, pretend = 0, frame = 0
 924              		@ frame_needed = 0, uses_anonymous_args = 0
 925              	.LVL103:
 926              		stmfd	sp!, {r4, r5, lr}
 927 0530 E3540000 	.LCFI4:
 928 0534 CAFFFFF3 		.loc 2 44 0
 929              		subs	r4, r1, #0
 930              		.loc 2 42 0
  33:../lib/uart.c **** 		}
  34:../lib/uart.c **** 	}
  35:../lib/uart.c **** 	*buffer="\0";
 931              	r0
 932 0538 E59F300C 		.loc 2 44 0
 933              		ldmlefd	sp!, {r4, r5, pc}
 934 053c E5C53000 	.LVL104:
  36:../lib/uart.c **** }
 935              	4:
 936 0540 E8BD8070 		.loc 2 46 0
 937              		ldrb	r0, [r5], #1	@ zero_extendqisi2
 938              	.LVL105:
 939              		bl	io_uart0_send_byte
 940 0544 EBFFFFFE 	.LVL106:
 941              		.loc 2 44 0
 942 0548 EAFFFFF7 		subs	r4, r4, #1
 943              		bne	.L164
 944              		ldmfd	sp!, {r4, r5, pc}
 945              	.LFE27:
 947              		.align	2
 948              		.global	memTestDataBus
 950              	memTestDataBus:
 951              	.LFB28:
 952              		.file 3 "memtest.c"
 953              		.loc 3 38 0
  37:../lib/uart.c **** 
  38:../lib/uart.c **** // ############################################################################################
  39:../lib/uart.c **** // Print character buffer via UART 0
  40:../lib/uart.c ****    void uart0_print_buffer(unsigned char *buffer, int size)
  41:../lib/uart.c **** // ############################################################################################
  42:../lib/uart.c **** {
 954              	d = 0, frame = 0
 955              		@ frame_needed = 0, uses_anonymous_args = 0
 956              		@ link register save eliminated.
 957              	.LVL107:
 958 0550 E92D4030 		mov	r2, r0
 959              		@ lr needed for prologue
  43:../lib/uart.c **** 	unsigned char char_buffer = 0;
  44:../lib/uart.c **** 	while(size > 0){
 960              	3 38 0
 961 0554 E2514000 		mov	r0, #1
 962              	.LVL108:
 963 0558 E1A05000 	.L167:
 964              		.loc 3 50 0
 965 055c D8BD8030 		str	r0, [r2, #0]
 966              		.loc 3 55 0
 967              		ldr	r3, [r2, #0]
  45:../lib/uart.c **** 		char_buffer = *buffer++;
  46:../lib/uart.c **** 		io_uart0_send_byte((int)char_buffer);
 968              	 r0
 969 0560 E4D50001 		bxne	lr
 970              		.loc 3 45 0
 971 0564 EBFFFFFE 		movs	r0, r0, asl #1
 972              		bne	.L167
 973              	.LVL109:
 974 0568 E2544001 		.loc 3 63 0
 975 056c 1AFFFFFB 		bx	lr
 976 0570 E8BD8030 	.LFE28:
 978              		.align	2
 979              		.global	memTestAddressBus
 981              	memTestAddressBus:
 982              	.LFB29:
 983              		.loc 3 93 0
 984              		@ args = 0, pretend = 0, frame = 0
   1:memtest.c     **** /**********************************************************************
   2:memtest.c     ****  *
   3:memtest.c     ****  * Filename:    memtest.c
   4:memtest.c     ****  * 
   5:memtest.c     ****  * Description: General-purpose memory testing functions.
   6:memtest.c     ****  *
   7:memtest.c     ****  * Notes:       This software can be easily ported to systems with
   8:memtest.c     ****  *              different data bus widths by redefining 'datum'.
   9:memtest.c     ****  *
  10:memtest.c     ****  * 
  11:memtest.c     ****  * Copyright (c) 1998 by Michael Barr.  This software is placed into
  12:memtest.c     ****  * the public domain and may be used for any purpose.  However, this
  13:memtest.c     ****  * notice must not be changed or removed and no warranty is either
  14:memtest.c     ****  * expressed or implied by its publication or distribution.
  15:memtest.c     ****  **********************************************************************/
  16:memtest.c     **** 
  17:memtest.c     **** 
  18:memtest.c     **** #include "memtest.h"
  19:memtest.c     **** 
  20:memtest.c     **** 
  21:memtest.c     **** /**********************************************************************
  22:memtest.c     ****  *
  23:memtest.c     ****  * Function:    memTestDataBus()
  24:memtest.c     ****  *
  25:memtest.c     ****  * Description: Test the data bus wiring in a memory region by
  26:memtest.c     ****  *              performing a walking 1's test at a fixed address
  27:memtest.c     ****  *              within that region.  The address (and hence the
  28:memtest.c     ****  *              memory region) is selected by the caller.
  29:memtest.c     ****  *
  30:memtest.c     ****  * Notes:       
  31:memtest.c     ****  *
  32:memtest.c     ****  * Returns:     0 if the test succeeds.  
  33:memtest.c     ****  *              A non-zero result is the first pattern that failed.
  34:memtest.c     ****  *
  35:memtest.c     ****  **********************************************************************/
  36:memtest.c     **** datum
  37:memtest.c     **** memTestDataBus(volatile datum * address)
  38:memtest.c     **** {
 985              	 0, uses_anonymous_args = 0
 986              	.LVL110:
 987              		.loc 3 94 0
 988              		mov	r1, r1, lsr #2
 989              	.LVL111:
 990 0574 E1A02000 		.loc 3 93 0
 991              		stmfd	sp!, {r4, r5, r6, lr}
 992              	.LCFI5:
 993 0578 E3A00001 		.loc 3 94 0
 994              		sub	lr, r1, #1
 995              	.LVL112:
  39:memtest.c     ****     datum pattern;
  40:memtest.c     **** 
  41:memtest.c     **** 
  42:memtest.c     ****     /*
  43:memtest.c     ****      * Perform a walking 1's test at the given address.
  44:memtest.c     ****      */
  45:memtest.c     ****     for (pattern = 1; pattern != 0; pattern <<= 1)
  46:memtest.c     ****     {
  47:memtest.c     ****         /*
  48:memtest.c     ****          * Write the test pattern.
  49:memtest.c     ****          */
  50:memtest.c     ****         *address = pattern;
 996              	 0
 997 057c E5820000 		ands	r1, lr, #1
  51:memtest.c     **** 
  52:memtest.c     ****         /*
  53:memtest.c     ****          * Read it back (immediately is okay for this test).
  54:memtest.c     ****          */
  55:memtest.c     ****         if (*address != pattern) 
 998              	loc 3 93 0
 999 0580 E5923000 		mov	r6, r2
 1000 0584 E1530000 		.loc 3 105 0
 1001 0588 112FFF1E 		beq	.L173
 1002              	.LVL113:
 1003 058c E1B00080 		mov	r1, #43520
 1004 0590 1AFFFFF9 		add	r1, r1, #170
 1005              		orr	r1, r1, r1, asl #16
  56:memtest.c     ****         {
  57:memtest.c     ****             return (pattern);
  58:memtest.c     ****         }
  59:memtest.c     ****     }
  60:memtest.c     **** 
  61:memtest.c     ****     return (0);
  62:memtest.c     **** 
  63:memtest.c     **** }   /* memTestDataBus() */
 1006              	 #1
 1007 0594 E12FFF1E 	.LVL114:
 1008              	.L175:
 1009              		.loc 3 107 0
 1010              		mov	r3, r2, asl #2
 1011              		.loc 3 105 0
 1012              		mov	r2, r2, asl #1
 1013              		tst	lr, r2
 1014              		.loc 3 107 0
  64:memtest.c     **** 
  65:memtest.c     **** 
  66:memtest.c     **** /**********************************************************************
  67:memtest.c     ****  *
  68:memtest.c     ****  * Function:    memTestAddressBus()
  69:memtest.c     ****  *
  70:memtest.c     ****  * Description: Test the address bus wiring in a memory region by
  71:memtest.c     ****  *              performing a walking 1's test on the relevant bits
  72:memtest.c     ****  *              of the address and checking for aliasing. This test
  73:memtest.c     ****  *              will find single-bit address failures such as stuck
  74:memtest.c     ****  *              -high, stuck-low, and shorted pins.  The base address
  75:memtest.c     ****  *              and size of the region are selected by the caller.
  76:memtest.c     ****  *
  77:memtest.c     ****  * Notes:       For best results, the selected base address should
  78:memtest.c     ****  *              have enough LSB 0's to guarantee single address bit
  79:memtest.c     ****  *              changes.  For example, to test a 64-Kbyte region, 
  80:memtest.c     ****  *              select a base address on a 64-Kbyte boundary.  Also, 
  81:memtest.c     ****  *              select the region size as a power-of-two--if at all 
  82:memtest.c     ****  *              possible.
  83:memtest.c     ****  *
  84:memtest.c     ****  * Returns:     NULL if the test succeeds.  
  85:memtest.c     ****  *              A non-zero result is the first address at which an
  86:memtest.c     ****  *              aliasing problem was uncovered.  By examining the
  87:memtest.c     ****  *              contents of memory, it may be possible to gather
  88:memtest.c     ****  *              additional information about the problem.
  89:memtest.c     ****  *
  90:memtest.c     ****  **********************************************************************/
  91:memtest.c     **** datum * 
  92:memtest.c     **** memTestAddressBus(volatile datum * baseAddress, unsigned long nBytes, int *Step)
  93:memtest.c     **** {
 1015              	[r0, r3]
 1016              		.loc 3 105 0
 1017              		bne	.L175
 1018              		.loc 3 114 0
  94:memtest.c     ****     unsigned long addressMask = (nBytes/sizeof(datum) - 1);
 1019              		r3, #21760
 1020 0598 E1A01121 		add	r3, r3, #85
 1021              		mov	r5, r0
 1022              		orr	r3, r3, r3, asl #16
 1023 059c E92D4070 		str	r3, [r5], #4
 1024              		.loc 3 118 0
 1025              		ldr	r2, [r0, #4]
 1026 05a0 E241E001 	.LVL115:
 1027              		cmp	r2, r1
  95:memtest.c     ****     unsigned long offset;
  96:memtest.c     ****     unsigned long testOffset;
  97:memtest.c     **** 
  98:memtest.c     ****     datum pattern     = (datum) 0xAAAAAAAA;
  99:memtest.c     ****     datum antipattern = (datum) 0x55555555;
 100:memtest.c     **** 
 101:memtest.c     **** 
 102:memtest.c     ****     /*
 103:memtest.c     ****      * Write the default pattern at each of the power-of-two offsets.
 104:memtest.c     ****      */
 105:memtest.c     ****     for (offset = 1; (offset & addressMask) != 0; offset <<= 1)
 1028              	, r5
 1029 05a4 E21E1001 		bne	.L179
 1030              		.loc 3 121 0
 1031 05a8 E1A06002 		mov	r1, #1
 1032              	.LVL116:
 1033 05ac 0A000052 		b	.L181
 1034              	.L180:
 1035 05b0 E3A01CAA 		.loc 3 118 0
 1036 05b4 E28110AA 		ldr	r3, [r0, r3]
 1037 05b8 E1811801 		cmp	r3, r2
 1038 05bc E3A02001 		bne	.L179
 1039              	.L181:
 1040              		.loc 3 116 0
 106:memtest.c     ****     {
 107:memtest.c     ****         baseAddress[offset] = pattern;
 1041              	asl #1
 1042 05c0 E1A03102 		.loc 3 118 0
 1043              		mov	r2, #43520
 1044 05c4 E1A02082 		add	r2, r2, #170
 1045 05c8 E11E0002 		mov	r3, r1, asl #2
 1046              		.loc 3 116 0
 1047 05cc E7801003 		tst	lr, r1
 1048              		.loc 3 118 0
 1049 05d0 1AFFFFFA 		orr	r2, r2, r2, asl #16
 108:memtest.c     ****     }
 109:memtest.c     **** 
 110:memtest.c     ****     /* 
 111:memtest.c     ****      * Check for address bits stuck high.
 112:memtest.c     ****      */
 113:memtest.c     ****     testOffset = 0;
 114:memtest.c     ****     baseAddress[testOffset] = antipattern;
 1050              	r0, r3
 1051 05d4 E3A03C55 		.loc 3 116 0
 1052 05d8 E2833055 		bne	.L180
 1053 05dc E1A05000 		.loc 3 126 0
 1054 05e0 E1833803 		mov	r3, #43520
 1055 05e4 E4853004 		.loc 3 133 0
 115:memtest.c     **** 
 116:memtest.c     ****     for (offset = 1; (offset & addressMask) != 0; offset <<= 1)
 117:memtest.c     ****     {
 118:memtest.c     ****         if (baseAddress[offset] != pattern)
 1056              	2, #21760
 1057 05e8 E5902004 		.loc 3 126 0
 1058              		add	r3, r3, #170
 1059 05ec E1520001 		.loc 3 133 0
 1060 05f0 11A0C005 		add	r2, r2, #85
 1061 05f4 1A000036 		.loc 3 126 0
 119:memtest.c     ****         {
 120:memtest.c     ****             *Step = 1;
 121:memtest.c     **** 			return ((datum *) &baseAddress[offset]);
 1062              	3, r3, r3, asl #16
 1063 05f8 E3A01001 		.loc 3 133 0
 1064              		orr	r2, r2, r2, asl #16
 1065 05fc EA000002 		.loc 3 126 0
 1066              		str	r3, [r0, #0]
 1067              		.loc 3 133 0
 1068 0600 E7903003 		str	r2, [r5, #0]
 1069 0604 E1530002 		.loc 3 135 0
 1070 0608 1A000031 		ldr	r1, [r0, #0]
 1071              	.LVL117:
 1072              		cmp	r1, r3
 1073 060c E1A01081 		moveq	r4, #1
 1074              	.LVL118:
 1075 0610 E3A02CAA 		bne	.L185
 1076 0614 E28220AA 	.L186:
 1077 0618 E1A03101 		mov	r1, #1
 1078              	.LVL119:
 1079 061c E11E0001 	.L187:
 1080              		.loc 3 143 0
 1081 0620 E1822802 		mov	r3, r1, asl #2
 1082 0624 E080C003 		mov	ip, #43520
 1083              		ldr	r2, [r0, r3]
 1084 0628 1AFFFFF4 		add	ip, ip, #170
 122:memtest.c     **** 			
 123:memtest.c     ****         }
 124:memtest.c     ****     }
 125:memtest.c     **** 
 126:memtest.c     ****     baseAddress[testOffset] = pattern;
 1085              	6
 1086 062c E3A03CAA 		cmp	r2, ip
 127:memtest.c     **** 
 128:memtest.c     ****     /*
 129:memtest.c     ****      * Check for address bits stuck low or shorted.
 130:memtest.c     ****      */
 131:memtest.c     ****     for (testOffset = 1; (testOffset & addressMask) != 0; testOffset <<= 1)
 132:memtest.c     ****     {
 133:memtest.c     ****         baseAddress[testOffset] = antipattern;
 1087              	eq	.L188
 1088 0630 E3A02C55 		cmp	r1, r4
 1089              		bne	.L195
 1090 0634 E28330AA 	.L188:
 1091              		.loc 3 141 0
 1092 0638 E2822055 		mov	r1, r1, asl #1
 1093              		tst	lr, r1
 1094 063c E1833803 		bne	.L187
 1095              		.loc 3 131 0
 1096 0640 E1822802 		mov	r4, r4, asl #1
 1097              		ands	r2, lr, r4
 1098 0644 E5803000 		.loc 3 150 0
 1099              		str	ip, [r5, #0]
 1100 0648 E5852000 		.loc 3 131 0
 134:memtest.c     **** 
 135:memtest.c     **** 		if (baseAddress[0] != pattern)
 1101              	oc 3 133 0
 1102 064c E5901000 		mov	r3, #21760
 1103              		add	r3, r3, #85
 1104 0650 E1510003 		mov	r1, r4, asl #2
 1105 0654 03A04001 	.LVL120:
 1106              		orr	r3, r3, r3, asl #16
 1107 0658 1A000019 		str	r3, [r0, r1]
 1108              		.loc 3 135 0
 1109 065c E3A01001 		ldr	r2, [r0, #0]
 1110              		cmp	r2, ip
 1111              		.loc 3 133 0
 136:memtest.c     **** 		{
 137:memtest.c     ****             *Step = 2;
 138:memtest.c     **** 			return ((datum *) &baseAddress[testOffset]);
 139:memtest.c     **** 		}
 140:memtest.c     **** 
 141:memtest.c     ****         for (offset = 1; (offset & addressMask) != 0; offset <<= 1)
 142:memtest.c     ****         {
 143:memtest.c     ****             if ((baseAddress[offset] != pattern) && (offset != testOffset))
 1112              	, r1
 1113 0660 E1A03101 		.loc 3 135 0
 1114 0664 E3A0CCAA 		beq	.L186
 1115 0668 E7902003 	.L185:
 1116 066c E28CC0AA 		.loc 3 137 0
 1117 0670 E18CC80C 		mov	r3, #2
 1118 0674 E152000C 		.loc 3 138 0
 1119 0678 0A000001 		mov	r1, r5
 1120 067c E1510004 		.loc 3 137 0
 1121 0680 1A000018 		str	r3, [r6, #0]
 1122              		b	.L182
 1123              	.LVL121:
 1124 0684 E1A01081 	.L179:
 1125 0688 E11E0001 		.loc 3 120 0
 1126 068c 1AFFFFF3 		mov	r3, #1
 1127              		str	r3, [r6, #0]
 1128 0690 E1A04084 		.loc 3 121 0
 1129 0694 E01E2004 		mov	r1, ip
 144:memtest.c     ****             {
 145:memtest.c     **** 				*Step = 3;
 146:memtest.c     ****                return ((datum *) &baseAddress[testOffset]);
 147:memtest.c     ****             }
 148:memtest.c     ****         }
 149:memtest.c     **** 
 150:memtest.c     ****         baseAddress[testOffset] = pattern;
 1130              	.L182:
 1131 0698 E585C000 		.loc 3 155 0
 1132              		mov	r0, r1
 1133 069c 0A000020 	.LVL124:
 1134              		ldmfd	sp!, {r4, r5, r6, pc}
 1135 06a0 E3A03C55 	.LVL125:
 1136 06a4 E2833055 	.L195:
 1137 06a8 E1A01104 		.loc 3 146 0
 1138              		mov	r1, r5
 1139 06ac E1833803 	.LVL126:
 1140 06b0 E7803001 		.loc 3 145 0
 1141              		mov	r3, #3
 1142 06b4 E5902000 		.loc 3 155 0
 1143 06b8 E152000C 		mov	r0, r1
 1144              	.LVL127:
 1145 06bc E0805001 		.loc 3 145 0
 1146              		str	r3, [r6, #0]
 1147 06c0 0AFFFFE5 		.loc 3 155 0
 1148              		ldmfd	sp!, {r4, r5, r6, pc}
 1149              	.LVL128:
 1150 06c4 E3A03002 	.L173:
 1151              		.loc 3 114 0
 1152 06c8 E1A01005 		mov	r3, #21760
 1153              		.loc 3 126 0
 1154 06cc E5863000 		mov	r2, #43520
 1155 06d0 EA000002 		.loc 3 114 0
 1156              		add	r3, r3, #85
 1157              		.loc 3 126 0
 1158              		add	r2, r2, #170
 1159 06d4 E3A03001 		.loc 3 114 0
 1160 06d8 E5863000 		orr	r3, r3, r3, asl #16
 1161              		.loc 3 126 0
 1162 06dc E1A0100C 		orr	r2, r2, r2, asl #16
 1163              		.loc 3 114 0
 1164              		str	r3, [r0, #0]
 1165              		.loc 3 126 0
 151:memtest.c     ****     }
 152:memtest.c     **** 
 153:memtest.c     ****     return (NULL);
 154:memtest.c     **** 
 155:memtest.c     **** }   /* memTestAddressBus() */
 1166              		r0, r1
 1167 06e0 E1A00001 	.LVL129:
 1168              		ldmfd	sp!, {r4, r5, r6, pc}
 1169 06e4 E8BD8070 	.LVL130:
 1170              	.L202:
 1171              		.loc 3 131 0
 1172              		mov	r1, r2
 1173 06e8 E1A01005 	.LVL131:
 1174              		b	.L182
 1175              	.LFE29:
 1177              		.align	2
 1178 06f0 E1A00001 		.global	memTestDevice1
 1180              	memTestDevice1:
 1181 06f4 E5863000 	.LFB30:
 1182              		.loc 3 181 0
 1183 06f8 E8BD8070 		@ args = 0, pretend = 0, frame = 0
 1184              		@ frame_needed = 0, uses_anonymous_args = 0
 1185              		@ link register save eliminated.
 1186              	.LVL132:
 1187 06fc E3A03C55 		.loc 3 192 0
 1188              		movs	r1, r1, lsr #2
 1189 0700 E3A02CAA 	.LVL133:
 1190              		.loc 3 181 0
 1191 0704 E2833055 		@ lr needed for prologue
 1192              		.loc 3 192 0
 1193 0708 E28220AA 		beq	.L204
 1194              		mov	r3, #1
 1195 070c E1833803 	.LVL134:
 1196              		mov	r2, r0
 1197 0710 E1822802 	.LVL135:
 1198              		add	ip, r1, r3
 1199 0714 E5803000 	.L206:
 1200              	.LVL136:
 1201 0718 E5802000 		.loc 3 194 0
 1202              		str	r3, [r2], #4
 1203 071c E1A00001 		.loc 3 192 0
 1204              		add	r3, r3, #1
 1205 0720 E8BD8070 		cmp	ip, r3
 1206              		bne	.L206
 1207              		.loc 3 202 0
 1208              		ldr	r3, [r0, #0]
 1209 0724 E1A01002 	.LVL137:
 1210              		cmp	r3, #1
 1211 0728 EAFFFFEC 		bxne	lr
 1212              		.loc 3 204 0
 1213              		add	r2, r0, #4
 1214              		mov	ip, r3
 1215              	.LVL138:
 1216              		b	.L211
 1217              	.L210:
 1218              		.loc 3 202 0
 156:memtest.c     **** 
 157:memtest.c     **** 
 158:memtest.c     **** /**********************************************************************
 159:memtest.c     ****  *
 160:memtest.c     ****  * Function:    memTestDevice()
 161:memtest.c     ****  *
 162:memtest.c     ****  * Description: Test the integrity of a physical memory device by
 163:memtest.c     ****  *              performing an increment/decrement test over the
 164:memtest.c     ****  *              entire region.  In the process every storage bit 
 165:memtest.c     ****  *              in the device is tested as a zero and a one.  The
 166:memtest.c     ****  *              base address and the size of the region are
 167:memtest.c     ****  *              selected by the caller.
 168:memtest.c     ****  *
 169:memtest.c     ****  * Notes:       
 170:memtest.c     ****  *
 171:memtest.c     ****  * Returns:     NULL if the test succeeds.
 172:memtest.c     ****  *
 173:memtest.c     ****  *              A non-zero result is the first address at which an
 174:memtest.c     ****  *              incorrect value was read back.  By examining the
 175:memtest.c     ****  *              contents of memory, it may be possible to gather
 176:memtest.c     ****  *              additional information about the problem.
 177:memtest.c     ****  *
 178:memtest.c     ****  **********************************************************************/
 179:memtest.c     **** datum * 
 180:memtest.c     **** memTestDevice1(volatile datum * baseAddress, unsigned long nBytes)	
 181:memtest.c     **** {
 1219              	 3 200 0
 1220              		cmp	r1, ip
 1221              		mov	r0, r2
 1222              		add	ip, ip, #1
 1223              		bne	.L210
 182:memtest.c     ****     unsigned long offset;
 183:memtest.c     ****     unsigned long nWords = nBytes / sizeof(datum);
 184:memtest.c     **** 
 185:memtest.c     ****     datum pattern;
 186:memtest.c     ****     datum antipattern;
 187:memtest.c     **** 
 188:memtest.c     **** 
 189:memtest.c     ****     /*
 190:memtest.c     ****      * Fill memory with a known pattern.
 191:memtest.c     ****      */
 192:memtest.c     ****     for (pattern = 1, offset = 0; offset < nWords; pattern++, offset++)
 1224              	:
 1225 072c E1B01121 		mov	r0, #0
 1226              	.LVL139:
 1227              		.loc 3 210 0
 1228              		bx	lr
 1229              	.LVL140:
 1230 0730 0A000013 	.L218:
 1231 0734 E3A03001 		bx	lr
 1232              	.LFE30:
 1234              		.align	2
 1235 073c E081C003 		.global	memTestDevice2
 1237              	memTestDevice2:
 193:memtest.c     ****     {
 194:memtest.c     ****         baseAddress[offset] = pattern;
 1238              	3 213 0
 1239 0740 E4823004 		@ args = 0, pretend = 0, frame = 0
 1240              		@ frame_needed = 0, uses_anonymous_args = 0
 1241 0744 E2833001 	.LVL141:
 1242 0748 E15C0003 		.loc 3 223 0
 1243 074c 1AFFFFFB 		movs	r1, r1, lsr #2
 195:memtest.c     ****     }
 196:memtest.c     **** 
 197:memtest.c     ****     /*
 198:memtest.c     ****      * Check each location and invert it for the second pass.
 199:memtest.c     ****      */
 200:memtest.c     ****     for (pattern = 1, offset = 0; offset < nWords; pattern++, offset++)
 201:memtest.c     ****     {
 202:memtest.c     ****         if (baseAddress[offset] != pattern)
 1244              	2:
 1245 0750 E5903000 		.loc 3 213 0
 1246              		str	lr, [sp, #-4]!
 1247 0754 E3530001 	.LCFI6:
 1248 0758 112FFF1E 		.loc 3 223 0
 203:memtest.c     ****         {
 204:memtest.c     ****             return ((datum *) &baseAddress[offset]);
 1249              	.L220
 1250 075c E2802004 		mov	r2, #1
 1251 0760 E1A0C003 	.LVL143:
 1252              		mov	ip, r0
 1253 0764 EA000002 	.LVL144:
 1254              		add	lr, r1, r2
 1255              	.L222:
 1256 0768 E4923004 	.LVL145:
 1257 076c E153000C 		.loc 3 225 0
 1258 0770 1A000005 		mvn	r3, r2
 1259              	.LVL146:
 1260              		.loc 3 223 0
 1261 0774 E151000C 		add	r2, r2, #1
 1262 0778 E1A00002 		cmp	lr, r2
 1263 077c E28CC001 		.loc 3 226 0
 1264 0780 1AFFFFF8 		str	r3, [ip], #4
 1265              		.loc 3 223 0
 1266 0784 E3A00000 		bne	.L222
 1267              		.loc 3 235 0
 205:memtest.c     ****         }
 206:memtest.c     ****  
 207:memtest.c     ****     }
 208:memtest.c     ****     return (NULL);
 209:memtest.c     **** 
 210:memtest.c     **** }   /* memTestDevice1() */
 1268              	LVL147:
 1269 0788 E12FFF1E 		cmn	r3, #2
 1270              		ldrne	pc, [sp], #4
 1271              		.loc 3 237 0
 1272 078c E12FFF1E 		add	r2, r0, #4
 1273              	.LVL148:
 1274              		mov	lr, #1
 1275              	.LVL149:
 1276              		b	.L227
 1277              	.L226:
 1278              		.loc 3 235 0
 1279              		ldr	r3, [r2], #4
 211:memtest.c     **** datum * 
 212:memtest.c     **** memTestDevice2(volatile datum * baseAddress, unsigned long nBytes)	
 213:memtest.c     **** {
 1280              		bne	.L234
 1281              	.L227:
 1282              		.loc 3 232 0
 1283              		cmp	r1, lr
 214:memtest.c     ****     unsigned long offset;
 215:memtest.c     ****     unsigned long nWords = nBytes / sizeof(datum);
 216:memtest.c     **** 
 217:memtest.c     ****     datum pattern;
 218:memtest.c     ****     datum antipattern;
 219:memtest.c     **** 
 220:memtest.c     ****     /*
 221:memtest.c     ****      * Check each location and invert it for the second pass.
 222:memtest.c     ****      */
 223:memtest.c     ****     for (pattern = 1, offset = 0; offset < nWords; pattern++, offset++)
 1284              		lr, lr, #1
 1285 0790 E1B01121 		mov	r0, r2
 1286              		.loc 3 235 0
 1287              		mvn	ip, lr
 1288 0794 E52DE004 		.loc 3 232 0
 1289              		bne	.L226
 1290              	.L220:
 1291 0798 0A000015 		mov	r0, #0
 1292 079c E3A02001 	.LVL150:
 1293              		.loc 3 243 0
 1294 07a0 E1A0C000 		ldr	pc, [sp], #4
 1295              	.LVL151:
 1296 07a4 E081E002 	.L234:
 1297              		ldr	pc, [sp], #4
 1298              	.LFE31:
 224:memtest.c     ****     {
 225:memtest.c     ****         antipattern = ~pattern;
 1299              	evice2, .-memTestDevice2
 1300 07a8 E1E03002 		.align	2
 1301              		.global	long_to_hex_string
 1303 07ac E2822001 	long_to_hex_string:
 1304 07b0 E15E0002 	.LFB33:
 226:memtest.c     ****         baseAddress[offset] = antipattern;
 1305              	 4 "main.c"
 1306 07b4 E48C3004 		.loc 4 41 0
 1307              		@ args = 0, pretend = 0, frame = 0
 1308 07b8 1AFFFFFA 		@ frame_needed = 0, uses_anonymous_args = 0
 227:memtest.c     ****     }
 228:memtest.c     **** 
 229:memtest.c     ****     /*
 230:memtest.c     ****      * Check each location for the inverted pattern and zero it.
 231:memtest.c     ****      */
 232:memtest.c     ****     for (pattern = 1, offset = 0; offset < nWords; pattern++, offset++)
 233:memtest.c     ****     {
 234:memtest.c     ****         antipattern = ~pattern;
 235:memtest.c     ****         if (baseAddress[offset] != antipattern)
 1309              	152:
 1310 07bc E5903000 		stmfd	sp!, {r4, lr}
 1311              	.LCFI7:
 1312 07c0 E3730002 		.loc 4 41 0
 1313 07c4 149DF004 		and	r4, r2, #255
 236:memtest.c     ****         {
 237:memtest.c     ****             return ((datum *) &baseAddress[offset]);
 1314              	 4 46 0
 1315 07c8 E2802004 		cmp	r4, #8
 1316              		movhi	r4, #8
 1317 07cc E3A0E001 		bhi	.L238
 1318              	.LVL153:
 1319 07d0 EA000002 		.loc 4 48 0
 1320              		cmp	r4, #0
 1321              		.loc 4 71 0
 1322 07d4 E4923004 		moveq	r4, #1
 1323 07d8 E15C0003 	.L238:
 1324 07dc 1A000006 		mov	r2, r1
 1325              	.LVL154:
 1326              		mov	lr, r4
 1327 07e0 E151000E 	.LVL155:
 1328 07e4 E28EE001 	.L240:
 1329 07e8 E1A00002 		.loc 4 54 0
 1330              		mov	r3, lr, asl #2
 1331 07ec E1E0C00E 		.loc 4 53 0
 1332              		cmp	lr, #1
 1333 07f0 1AFFFFF7 		.loc 4 54 0
 1334              		sub	r3, r3, #4
 1335 07f4 E3A00000 		.loc 4 53 0
 1336              		mov	ip, r0
 238:memtest.c     ****         }
 239:memtest.c     ****     }
 240:memtest.c     **** 
 241:memtest.c     ****     return (NULL);
 242:memtest.c     **** 
 243:memtest.c     **** }   /* memTestDevice2() */
 1337              	movhi	ip, r0, lsr r3
 1338 07f8 E49DF004 		.loc 4 58 0
 1339              		sub	r3, lr, #1
 1340              		.loc 4 57 0
 1341 07fc E49DF004 		and	ip, ip, #15
 1342              	.LVL157:
 1343              		.loc 4 58 0
 1344              		and	lr, r3, #255
 1345              		.loc 4 61 0
 1346              		cmp	ip, #9
 1347              		.loc 4 62 0
 1348              		add	r3, ip, #48
 1349              	.LVL158:
   1:main.c        **** /**********************************************************************
   2:main.c        ****  *
   3:main.c        ****  * Function:    memTest()
   4:main.c        ****  *
   5:main.c        ****  * Description: Test a  chunk of SRAM.
   6:main.c        **** 				Set BASE_ADDRESS below to the starting address (in hex) of the memory
   7:main.c        **** 				Set NUM_BYTES below to the number to bytes (in dec) to test in memory 
   8:main.c        ****  *
   9:main.c        ****  * Notes:       
  10:main.c        ****  *
  11:main.c        ****  * Returns:     0 on success.
  12:main.c        ****  *              Otherwise -1 indicates failure.
  13:main.c        ****  *
  14:main.c        ****  **********************************************************************/
  15:main.c        **** #include "../lib/io_driver.h"
  16:main.c        **** #include "../lib/io_driver.c"
  17:main.c        **** #include "../lib/uart.h"
  18:main.c        **** #include "../lib/uart.c"
  19:main.c        **** #include "memtest.h"
  20:main.c        **** #include "memtest.c"
  21:main.c        **** #include "memtest_run.c"
  22:main.c        **** 
  23:main.c        **** 
  24:main.c        **** #define BASE_ADDRESS  (volatile datum *) 0x04000000 //beginning of SDRAM memory
  25:main.c        **** #define NUM_BYTES      32 * 1024 * 1024
  26:main.c        **** //#define NUM_BYTES     ( 32 * 1024 )
  27:main.c        **** 
  28:main.c        **** #define CYCLES	1
  29:main.c        **** 
  30:main.c        **** //#define CLEARMEM    //run clearing memory and write address to location
  31:main.c        **** #define MEMTESTRUN	//run memtest routines
  32:main.c        **** //#define MEMLOCWR    //repeatedly write single memory location 50x
  33:main.c        **** //#define MEMELOC	0x04000000	//location to write
  34:main.c        **** 
  35:main.c        **** // ############################################################################################
  36:main.c        **** // Convert 4/8/12/16/20/24/28/32 bit hexadecimal value to ASCII string
  37:main.c        ****    void long_to_hex_string(unsigned long data,    // max 32 bit data word
  38:main.c        ****                            unsigned char *buffer, // buffer to store the string
  39:main.c        **** 						   unsigned char numbers) // number of places, max 8
  40:main.c        **** // ############################################################################################
  41:main.c        **** {
 1350              		addhi	r3, ip, #55
 1351              		.loc 4 51 0
 1352              		cmp	lr, #0
 1353              		.loc 4 67 0
 1354 0800 E92D4010 		strb	r3, [r2], #1
 1355              		.loc 4 51 0
 1356              		bne	.L240
 1357 0804 E20240FF 		.loc 4 70 0
  42:main.c        **** 	unsigned char temp_char = 0;
  43:main.c        **** 	unsigned long temp_data = 0;
  44:main.c        **** 
  45:main.c        **** 	// fit into range
  46:main.c        **** 	if(numbers > 8)
 1358              	 r4, #1
 1359 0808 E3540008 	.LVL159:
 1360 080c 83A04008 		and	r3, r3, #255
 1361 0810 8A000001 		add	r3, r1, r3
 1362              		strb	lr, [r3, #1]
  47:main.c        **** 		numbers = 8;
  48:main.c        **** 	if(numbers < 1)
 1363              	 4 71 0
 1364 0814 E3540000 		ldmfd	sp!, {r4, pc}
  49:main.c        **** 		numbers = 1;
  50:main.c        **** 
  51:main.c        **** 	while(numbers > 0){
  52:main.c        **** 		// isolate one 4-bit value
  53:main.c        **** 		if(numbers > 1)
  54:main.c        **** 			temp_data = data >> ((numbers-1)*4);
  55:main.c        **** 		else
  56:main.c        **** 			temp_data = data;
  57:main.c        **** 		temp_data = temp_data & 0x0000000F;
  58:main.c        **** 		numbers--;
  59:main.c        **** 
  60:main.c        **** 		// convert 4-bit value temp_data to char temp_char
  61:main.c        **** 		if(temp_data < 10)
  62:main.c        **** 			temp_char = '0' + temp_data;
  63:main.c        **** 		else
  64:main.c        **** 			temp_char = 'A' + temp_data - 10;
  65:main.c        **** 
  66:main.c        **** 		// save character
  67:main.c        **** 		*buffer++ = temp_char;
  68:main.c        **** 	}
  69:main.c        **** 
  70:main.c        **** 	*buffer++ = 0; // terminate string
  71:main.c        **** }
 1365              	FE33:
 1367              		.section	.rodata.str1.4,"aMS",%progbits,1
 1368 081c E1A02001 		.align	2
 1369              	.LC1:
 1370 0820 E1A0E004 		.ascii	"memTestDevice1 FAILED \000"
 1371              		.align	2
 1372              	.LC2:
 1373              		.ascii	"\015\012\000"
 1374 0824 E1A0310E 		.align	2
 1375              	.LC3:
 1376 0828 E35E0001 		.ascii	"memTestDevice1 Passed\015\012\000"
 1377              		.align	2
 1378 082c E2433004 	.LC4:
 1379              		.ascii	"Mem test complete \015\012\000"
 1380 0830 E1A0C000 		.text
 1381              		.align	2
 1382              		.global	memtest_run
 1384              	memtest_run:
 1385 0838 E24E3001 	.LFB32:
 1386              		.file 5 "memtest_run.c"
 1387 083c E20CC00F 		.loc 5 16 0
 1388              		@ args = 0, pretend = 0, frame = 12
 1389              		@ frame_needed = 0, uses_anonymous_args = 0
 1390 0840 E203E0FF 		stmfd	sp!, {r4, r5, lr}
 1391              	.LCFI8:
 1392 0844 E35C0009 		.loc 5 18 0
 1393              		ldr	r3, .L256
 1394 0848 E28C3030 		ldrh	r3, [r3, #0]
 1395              		.loc 5 16 0
 1396              		sub	sp, sp, #12
 1397 084c 828C3037 	.LCFI9:
 1398              		.loc 5 18 0
 1399 0850 E35E0000 		strh	r3, [sp, #2]	@ movhi
 1400              		.loc 5 53 0
 1401 0854 E4C23001 		mov	r1, #33554432
 1402              		.loc 5 18 0
 1403 0858 1AFFFFF1 		mov	r3, #0	@ movhi
 1404              		.loc 5 53 0
 1405 085c E2443001 		mov	r0, #67108864
 1406              		.loc 5 18 0
 1407 0860 E20330FF 		strh	r3, [sp, #4]	@ movhi
 1408 0864 E0813003 		strh	r3, [sp, #6]	@ movhi
 1409 0868 E5C3E001 		strh	r3, [sp, #8]	@ movhi
 1410              		strh	r3, [sp, #10]	@ movhi
 1411 086c E8BD8010 		.loc 5 53 0
 1412              		bl	memTestDevice1
 1413              		.loc 5 54 0
 1414              		subs	r4, r0, #0
 1415              	.LVL160:
 1416              		.loc 5 57 0
 1417 0000 6D656D54 		add	r5, sp, #2
 1417      65737444 
 1417      65766963 
 1417      65312046 
 1417      41494C45 
 1418 0017 00       		.loc 5 56 0
 1419              		ldr	r0, .L256+4
 1420 0018 0D0A00   		.loc 5 54 0
 1421 001b 00       		beq	.L252
 1422              		.loc 5 56 0
 1423 001c 6D656D54 		bl	uart0_printf
 1423      65737444 
 1423      65766963 
 1423      65312050 
 1423      61737365 
 1424              		.loc 5 57 0
 1425              		mov	r1, r5
 1426 0034 4D656D20 		mov	r2, #8
 1426      74657374 
 1426      20636F6D 
 1426      706C6574 
 1426      65200D0A 
 1427              		mov	r0, r4
 1428              		bl	long_to_hex_string
 1429              		.loc 5 58 0
 1430              		mov	r0, r5
 1431              		bl	uart0_printf
 1432              		ldr	r0, .L256+8
 1433              		bl	uart0_printf
   1:memtest_run.c **** // #include "../lib/io_driver.h"
   2:memtest_run.c **** // #include "../lib/io_driver.c"
   3:memtest_run.c **** // #include "../lib/uart.h"
   4:memtest_run.c **** // #include "../lib/uart.c"
   5:memtest_run.c **** //#include "memtest.h"
   6:memtest_run.c **** //#include "memtest.c"
   7:memtest_run.c **** 
   8:memtest_run.c **** #define BASE_ADDRESS  (volatile datum *) 0x04000000 //beginning of SDRAM memory
   9:memtest_run.c **** #define NUM_BYTES      32 * 1024 * 1024
  10:memtest_run.c **** 
  11:memtest_run.c **** //#define DATABTEST
  12:memtest_run.c **** //#define ADDRBTEST
  13:memtest_run.c **** #define DEVICETEST1
  14:memtest_run.c **** //#define DEVICETEST2
  15:memtest_run.c **** 
  16:memtest_run.c **** void memtest_run () {
 1434              	add	sp, sp, #12
 1435              		ldmfd	sp!, {r4, r5, pc}
 1436              	.L252:
 1437 0870 E92D4030 		.loc 5 63 0
 1438              		ldr	r0, .L256+16
  17:memtest_run.c **** 	int Step, result = 0;
  18:memtest_run.c **** 	unsigned char str[10]="\0";
 1439              	art0_printf
 1440 0874 E59F3078 		b	.L254
 1441 0878 E1D330B0 	.L257:
 1442              		.align	2
 1443 087c E24DD00C 	.L256:
 1444              		.word	.LC0
 1445              		.word	.LC1
 1446 0880 E1CD30B2 		.word	.LC2
  19:memtest_run.c **** 	
  20:memtest_run.c **** 	datum *result_ptr=NULL;
  21:memtest_run.c **** #ifdef DATABTEST
  22:memtest_run.c **** 	result = memTestDataBus(BASE_ADDRESS);
  23:memtest_run.c ****     if ( result != 0)
  24:memtest_run.c ****     {
  25:memtest_run.c ****         uart0_printf("memTestDataBus FAILED\r\n");
  26:memtest_run.c **** 		//return (-1);
  27:memtest_run.c ****     }
  28:memtest_run.c ****     else
  29:memtest_run.c ****     {
  30:memtest_run.c ****         uart0_printf("memTestDataBus Passed\r\n");
  31:memtest_run.c **** 
  32:memtest_run.c ****     }
  33:memtest_run.c **** #endif
  34:memtest_run.c **** 
  35:memtest_run.c **** #ifdef ADDRBTEST
  36:memtest_run.c **** 	result_ptr = memTestAddressBus(BASE_ADDRESS, NUM_BYTES, &Step);
  37:memtest_run.c ****     if ( result_ptr != NULL)
  38:memtest_run.c ****     {
  39:memtest_run.c ****        uart0_printf("memTestAddressBus FAILED ");
  40:memtest_run.c **** 	   long_to_hex_string((unsigned long ) result_ptr, str, 8);
  41:memtest_run.c **** 		uart0_printf(str);uart0_printf("\r\nStep: ");
  42:memtest_run.c **** 	   long_to_hex_string((unsigned long ) Step, str, 8);
  43:memtest_run.c **** 		uart0_printf(str);uart0_printf("\r\n");
  44:memtest_run.c **** 		//return (-1);
  45:memtest_run.c ****     }
  46:memtest_run.c ****     else
  47:memtest_run.c ****     {
  48:memtest_run.c ****         uart0_printf("memTestAddressBus Passed\r\n");
  49:memtest_run.c ****     }
  50:memtest_run.c **** #endif
  51:memtest_run.c **** 
  52:memtest_run.c **** #ifdef DEVICETEST1
  53:memtest_run.c ****     result_ptr = memTestDevice1(BASE_ADDRESS, NUM_BYTES);
 1447              	LC4
 1448 0884 E3A01402 		.word	.LC3
 1449              	.LFE32:
 1451              		.section	.rodata.str1.4
 1452 088c E3A00301 		.align	2
 1453              	.LC5:
 1454 0890 E1CD30B4 		.ascii	"Starting MEMTEST tests\015\012\000"
 1455 0894 E1CD30B6 		.align	2
 1456 0898 E1CD30B8 	.LC6:
 1457 089c E1CD30BA 		.ascii	"BASE ADDRESS:  \000"
 1458              		.align	2
 1459 08a0 EBFFFFFE 	.LC7:
  54:memtest_run.c ****     if ( result_ptr != NULL)
 1460              	er of Bytes to test:  \000"
 1461 08a4 E2504000 		.align	2
 1462              	.LC8:
  55:memtest_run.c ****     {
  56:memtest_run.c ****         uart0_printf("memTestDevice1 FAILED ");
  57:memtest_run.c **** 		long_to_hex_string((unsigned long ) result_ptr, str, 8);
 1463              	scii	"testing started \012\015\000"
 1464 08a8 E28D5002 		.align	2
 1465              	.LC9:
 1466 08ac E59F0044 		.ascii	"testing done \012\015\000"
 1467              		.text
 1468 08b0 0A00000C 		.align	2
 1469              		.global	main
 1471              	main:
 1472 08b8 E1A01005 	.LFB34:
 1473 08bc E3A02008 		.loc 4 75 0
 1474 08c0 E1A00004 		@ args = 0, pretend = 0, frame = 12
 1475 08c4 EBFFFFFE 		@ frame_needed = 0, uses_anonymous_args = 0
  58:memtest_run.c **** 		uart0_printf(str);uart0_printf("\r\n");
 1476              	r4, r5, r6, lr}
 1477 08c8 E1A00005 	.LCFI10:
 1478 08cc EBFFFFFE 		.loc 4 77 0
 1479 08d0 E59F0024 		ldr	r3, .L260
 1480 08d4 EBFFFFFE 		ldrh	r3, [r3, #0]
 1481              		.loc 4 75 0
  59:memtest_run.c **** 		//return (-1);
  60:memtest_run.c ****     }
  61:memtest_run.c ****     else
  62:memtest_run.c ****     {
  63:memtest_run.c ****         uart0_printf("memTestDevice1 Passed\r\n");
  64:memtest_run.c **** 		//return (0);
  65:memtest_run.c ****      }
  66:memtest_run.c **** #endif
  67:memtest_run.c **** 
  68:memtest_run.c **** #ifdef DEVICETEST2
  69:memtest_run.c ****     result_ptr = memTestDevice2(BASE_ADDRESS, NUM_BYTES);
  70:memtest_run.c ****     if ( result_ptr != NULL)
  71:memtest_run.c ****     {
  72:memtest_run.c ****         uart0_printf("memTestDevice2 FAILED ");
  73:memtest_run.c **** 		long_to_hex_string((unsigned long ) result_ptr, str, 8);
  74:memtest_run.c **** 		uart0_printf(str);uart0_printf("\r\n");
  75:memtest_run.c **** 		//return (-1);
  76:memtest_run.c ****     }
  77:memtest_run.c ****     else
  78:memtest_run.c ****     {
  79:memtest_run.c ****         uart0_printf("memTestDevice2 Passed\r\n");
  80:memtest_run.c **** 		//return (0);
  81:memtest_run.c ****      }
  82:memtest_run.c **** #endif
  83:memtest_run.c **** 	  uart0_printf("Mem test complete \r\n");
 1482              	p, sp, #12
 1483 08d8 E59F0020 	.LCFI11:
 1484 08dc EBFFFFFE 		.loc 4 77 0
  84:memtest_run.c **** 	return; 
  85:memtest_run.c **** } //memtest_run()
 1485              	v	r5, #0
 1486 08e0 E28DD00C 		.loc 4 83 0
 1487 08e4 E8BD8030 		ldr	r0, .L260+4
 1488              		.loc 4 77 0
 1489              		strh	r3, [sp, #2]	@ movhi
 1490 08e8 E59F0014 		.loc 4 85 0
 1491 08ec EBFFFFFE 		add	r4, sp, #2
 1492 08f0 EAFFFFF8 		.loc 4 77 0
 1493              		strh	r5, [sp, #4]	@ movhi
 1494              		strh	r5, [sp, #6]	@ movhi
 1495              		strh	r5, [sp, #8]	@ movhi
 1496 08f4 00000000 		strh	r5, [sp, #10]	@ movhi
 1497 08f8 00000000 		.loc 4 83 0
 1498 08fc 00000018 		bl	uart0_printf
 1499 0900 00000034 		.loc 4 84 0
 1500 0904 0000001C 		ldr	r0, .L260+8
 1501              		bl	uart0_printf
 1502              		.loc 4 86 0
 1503              		ldr	r6, .L260+12
 1504 0049 000000   		.loc 4 85 0
 1505              		mov	r1, r4
 1506 004c 53746172 		mov	r2, #8
 1506      74696E67 
 1506      204D454D 
 1506      54455354 
 1506      20746573 
 1507 0065 000000   		mov	r0, #67108864
 1508              		bl	long_to_hex_string
 1509 0068 42415345 		.loc 4 86 0
 1509      20414444 
 1509      52455353 
 1509      3A202000 
 1510              		mov	r0, r4
 1511              		bl	uart0_printf
 1512 0078 4E756D62 		mov	r0, r6
 1512      6572206F 
 1512      66204279 
 1512      74657320 
 1512      746F2074 
 1513 0093 00       		bl	uart0_printf
 1514              		.loc 4 87 0
 1515 0094 74657374 		ldr	r0, .L260+16
 1515      696E6720 
 1515      73746172 
 1515      74656420 
 1515      0A0D00
 1516 00a7 00       		bl	uart0_printf
 1517              		.loc 4 88 0
 1518 00a8 74657374 		mov	r1, r4
 1518      696E6720 
 1518      646F6E65 
 1518      200A0D00 
 1519              		mov	r2, #8
 1520              		mov	r0, #33554432
 1521              		bl	long_to_hex_string
 1522              		.loc 4 89 0
 1523              		mov	r0, r4
 1524              		bl	uart0_printf
  72:main.c        **** 
  73:main.c        **** int
  74:main.c        **** main(void)
  75:main.c        **** {
 1525              	 0
 1526              		ldr	r0, .L260+20
 1527              		bl	uart0_printf
 1528 0908 E92D4070 		.loc 4 124 0
 1529              		bl	memtest_run
  76:main.c        ****     int i, result = 0;
  77:main.c        **** 	unsigned char str[10]="\0";
 1530              	 4 128 0
 1531 090c E59F309C 		ldr	r0, .L260+24
 1532 0910 E1D330B0 		bl	uart0_printf
 1533              		.loc 4 130 0
 1534 0914 E24DD00C 		mov	r0, r5
 1535              		add	sp, sp, #12
 1536              		ldmfd	sp!, {r4, r5, r6, pc}
 1537 0918 E3A05000 	.L261:
  78:main.c        **** 	volatile datum * address;
  79:main.c        **** 	datum pattern;
  80:main.c        **** 	datum *result_ptr=NULL;
  81:main.c        **** 	
  82:main.c        **** 
  83:main.c        ****      uart0_printf("Starting MEMTEST tests\r\n");
 1538              	2
 1539 091c E59F0090 	.L260:
 1540              		.word	.LC0
 1541 0920 E1CD30B2 		.word	.LC5
  84:main.c        ****      uart0_printf("BASE ADDRESS:  ");
  85:main.c        ****      long_to_hex_string((unsigned long ) BASE_ADDRESS, str, 8);
 1542              	rd	.LC6
 1543 0924 E28D4002 		.word	.LC2
 1544              		.word	.LC7
 1545 0928 E1CD50B4 		.word	.LC8
 1546 092c E1CD50B6 		.word	.LC9
 1547 0930 E1CD50B8 	.LFE34:
 1549              		.align	2
 1550 0938 EBFFFFFE 		.global	io_enable_xint
 1552 093c E59F0074 	io_enable_xint:
 1553 0940 EBFFFFFE 	.LFB23:
  86:main.c        ****      uart0_printf(str);uart0_printf("\r\n");
 1554              	0
 1555 0944 E59F6070 		@ args = 0, pretend = 0, frame = 0
 1556              		@ frame_needed = 0, uses_anonymous_args = 0
 1557 0948 E1A01004 		@ link register save eliminated.
 1558 094c E3A02008 		@ lr needed for prologue
 1559 0950 E3A00301 	.LBB6:
 1560 0954 EBFFFFFE 	.LBB7:
 1561              		.loc 1 428 0
 1562 0958 E1A00004 		 mrs r3, cpsr
 1563 095c EBFFFFFE 	.LVL161:
 1564 0960 E1A00006 	.LBE7:
 1565 0964 EBFFFFFE 	.LBE6:
  87:main.c        ****      uart0_printf("Number of Bytes to test:  ");
 1566              	:
 1567 0968 E59F0050 		.loc 1 437 0
 1568 096c EBFFFFFE 		bic	r3, r3, #192
  88:main.c        ****      long_to_hex_string((unsigned long ) NUM_BYTES, str, 8);
 1569              	L162:
 1570 0970 E1A01004 		 msr cpsr, r3
 1571 0974 E3A02008 	.LBE9:
 1572 0978 E3A00402 	.LBE8:
 1573 097c EBFFFFFE 		.loc 1 448 0
  89:main.c        ****      uart0_printf(str);uart0_printf("\r\n");
 1574              	r
 1575 0980 E1A00004 	.LFE23:
 1577 0988 E1A00006 		.align	2
 1578 098c EBFFFFFE 		.global	io_disable_xint
  90:main.c        **** 
  91:main.c        **** #ifdef CLEARMEM	 
  92:main.c        **** 	 //write known pattern to memory
  93:main.c        **** 	 uart0_printf ("Start clearing memory \n\r");
  94:main.c        **** 	 address = 0x04000000;
  95:main.c        **** 	for (pattern = 0x04000000 ; pattern < (0x04000000+NUM_BYTES); pattern = pattern+4 )
  96:main.c        ****     {
  97:main.c        ****         /*
  98:main.c        ****          * Write the "address" pattern.
  99:main.c        ****          */
 100:main.c        ****         * address = pattern;
 101:main.c        **** 		address = address + 1;
 102:main.c        ****     }
 103:main.c        **** 	 uart0_printf ("Done clearing memory \n\r");
 104:main.c        **** #endif	
 105:main.c        **** 
 106:main.c        **** #ifdef MEMLOCWR
 107:main.c        **** 	address = MEMELOC;
 108:main.c        **** 	set_syscpreg(SYS_CTRL_0, DC_WTHRU);
 109:main.c        **** 	for (i=0; i<50; i++) {	
 110:main.c        **** 		* address = 0xaaaaaaaa;
 111:main.c        **** 		
 112:main.c        **** 		long_to_hex_string((unsigned long ) *address, str, 8);
 113:main.c        **** 		uart0_printf(str);uart0_printf("\r\n ");
 114:main.c        **** 		* address = 0x55555555;
 115:main.c        **** 		long_to_hex_string((unsigned long ) *address, str, 8);
 116:main.c        **** 		uart0_printf(str);uart0_printf("\r\n ");
 117:main.c        **** 		set_syscpreg(SYS_CTRL_0, DC_FLUSH);
 118:main.c        **** 	} //for
 119:main.c        **** #endif
 120:main.c        **** 
 121:main.c        **** 	uart0_printf ("testing started \n\r");
 1579              	e	io_disable_xint, %function
 1580 0990 E59F002C 	io_disable_xint:
 1581 0994 EBFFFFFE 	.LFB24:
 122:main.c        **** #ifdef MEMTESTRUN
 123:main.c        **** 	for (i=0; i<CYCLES; i++) {	
 124:main.c        **** 		memtest_run();
 1582              	oc 1 454 0
 1583 0998 EBFFFFFE 		@ args = 0, pretend = 0, frame = 0
 125:main.c        **** 	} //for
 126:main.c        **** #endif
 127:main.c        ****    
 128:main.c        ****    uart0_printf ("testing done \n\r");
 1584              	 frame_needed = 0, uses_anonymous_args = 0
 1585 099c E59F0024 		@ link register save eliminated.
 1586 09a0 EBFFFFFE 		@ lr needed for prologue
 129:main.c        **** //	asm volatile ("mov pc, #00010000");
 130:main.c        **** }   /* memTest() */
 1587              	B14:
 1588 09a4 E1A00005 	.LBB15:
 1589 09a8 E28DD00C 		.loc 1 428 0
 1590 09ac E8BD8070 		 mrs r3, cpsr
 1591              	.LVL163:
 1592              	.LBE15:
 1593              	.LBE14:
 1594 09b0 00000000 	.LBB16:
 1595 09b4 0000004C 	.LBB17:
 1596 09b8 00000068 		.loc 1 437 0
 1597 09bc 00000018 		orr	r3, r3, #192
 1598 09c0 00000078 	.LVL164:
 1599 09c4 00000094 		 msr cpsr, r3
 1600 09c8 000000A8 	.LBE17:
 1601              	.LBE16:
 1602              		.loc 1 458 0
 1603              		bx	lr
 1604              	.LFE24:
 1606              		.section	.debug_frame,"",%progbits
 1607              	.Lframe0:
 417:../lib/io_driver.c **** //		case 14:         asm volatile ("mcr p15,0,%0,c14,c14,0" : /* no outputs */ : "r" (_cp_val)); br
 418:../lib/io_driver.c **** //		case 15:         asm volatile ("mcr p15,0,%0,c15,c15,0" : /* no outputs */ : "r" (_cp_val)); br
 419:../lib/io_driver.c **** 		default:         break;
 420:../lib/io_driver.c **** 	}
 421:../lib/io_driver.c **** }
 422:../lib/io_driver.c **** // ******************************************************************************
 423:../lib/io_driver.c **** // read CMSR value
 424:../lib/io_driver.c ****    static inline unsigned long get_cmsr(void)
 425:../lib/io_driver.c **** // ******************************************************************************
 426:../lib/io_driver.c **** {
 427:../lib/io_driver.c **** 	unsigned long _cmsr;
 428:../lib/io_driver.c **** 	asm volatile (" mrs %0, cpsr" : "=r" (_cmsr) : /* no inputs */  );
 429:../lib/io_driver.c **** 	return _cmsr;
 430:../lib/io_driver.c **** }
 431:../lib/io_driver.c **** 
 432:../lib/io_driver.c **** // ******************************************************************************
 433:../lib/io_driver.c **** // write CMSR value
 434:../lib/io_driver.c ****    static inline void set_cmsr(unsigned long _cmsr)
 435:../lib/io_driver.c **** // ******************************************************************************
 436:../lib/io_driver.c **** {
 437:../lib/io_driver.c **** 	asm volatile (" msr cpsr, %0" : /* no outputs */ : "r" (_cmsr)  );
 438:../lib/io_driver.c **** }
 439:../lib/io_driver.c **** 
 440:../lib/io_driver.c **** // ******************************************************************************
 441:../lib/io_driver.c **** // Enable all external INTs
 442:../lib/io_driver.c ****    void io_enable_xint(void)
 443:../lib/io_driver.c **** // ******************************************************************************
 444:../lib/io_driver.c **** {
 1608              	E0
 1609              	.LSCIE0:
 1610              		.4byte	0xffffffff
 1611              		.byte	0x1
 1612              		.ascii	"\000"
 1613              		.uleb128 0x1
 1614              		.sleb128 -4
 1615              		.byte	0xe
 1616 09cc E10F3000 		.byte	0xc
 1617              		.uleb128 0xd
 1618              		.uleb128 0x0
 1619              		.align	2
 1620              	.LECIE0:
 1621              	.LSFDE0:
 1622              		.4byte	.LEFDE0-.LASFDE0
 1623 09d0 E3C330C0 	.LASFDE0:
 1624              		.4byte	.Lframe0
 1625 09d4 E129F003 		.4byte	.LFB2
 1626              		.4byte	.LFE2-.LFB2
 1627              		.align	2
 445:../lib/io_driver.c **** 	unsigned long _cmsr = get_cmsr();
 446:../lib/io_driver.c **** 	_cmsr = _cmsr & ~(1<<CMSR_FIQ) &~(1<<CMSR_IRQ);
 447:../lib/io_driver.c **** 	set_cmsr(_cmsr);
 448:../lib/io_driver.c **** }
 1628              	4byte	.LEFDE2-.LASFDE2
 1629 09d8 E12FFF1E 	.LASFDE2:
 1630              		.4byte	.Lframe0
 1631              		.4byte	.LFB3
 1632              		.4byte	.LFE3-.LFB3
 1633              		.align	2
 1634              	.LEFDE2:
 1635              	.LSFDE4:
 1636              		.4byte	.LEFDE4-.LASFDE4
 449:../lib/io_driver.c **** 
 450:../lib/io_driver.c **** // ******************************************************************************
 451:../lib/io_driver.c **** // Disable all global IBTs
 452:../lib/io_driver.c ****    void io_disable_xint(void)
 453:../lib/io_driver.c **** // ******************************************************************************
 454:../lib/io_driver.c **** {
 1637              	
 1638              		.4byte	.Lframe0
 1639              		.4byte	.LFB4
 1640              		.4byte	.LFE4-.LFB4
 1641              		.align	2
 1642              	.LEFDE4:
 1643              	.LSFDE6:
 1644              		.4byte	.LEFDE6-.LASFDE6
 1645 09dc E10F3000 	.LASFDE6:
 1646              		.4byte	.Lframe0
 1647              		.4byte	.LFB5
 1648              		.4byte	.LFE5-.LFB5
 1649              		.align	2
 1650              	.LEFDE6:
 1651              	.LSFDE8:
 1652 09e0 E38330C0 		.4byte	.LEFDE8-.LASFDE8
 1653              	.LASFDE8:
 1654 09e4 E129F003 		.4byte	.Lframe0
 1655              		.4byte	.LFB6
 1656              		.4byte	.LFE6-.LFB6
 455:../lib/io_driver.c **** 	unsigned long _cmsr = get_cmsr();
 456:../lib/io_driver.c **** 	_cmsr = _cmsr | (1<<CMSR_FIQ) | (1<<CMSR_IRQ);
 457:../lib/io_driver.c **** 	set_cmsr(_cmsr);
 458:../lib/io_driver.c **** }
 1657              	.LSFDE10:
 1658 09e8 E12FFF1E 		.4byte	.LEFDE10-.LASFDE10
 1659              	.LASFDE10:
 1660              		.4byte	.Lframe0
 2030              		.2byte	0x1
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:13     .text:00000000 io_read_gpio0_pin
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:22     .text:00000000 $a
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:39     .text:00000018 io_read_gpio0_port
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:59     .text:00000024 io_set_gpio0_pin
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:85     .text:00000040 io_clr_gpio0_pin
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:111    .text:00000064 io_toggle_gpio0_pin
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:137    .text:00000080 io_set_gpio0_port
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:157    .text:0000008c io_set_pwm
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:229    .text:00000108 io_get_pwm
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:282    .text:00000158 io_uart0_read_byte
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:306    .text:00000170 io_uart0_send_byte
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:331    .text:0000018c io_spi0_config
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:361    .text:000001b0 io_spi0_speed
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:381    .text:000001bc io_spi0_trans
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:418    .text:000001f4 io_spi0_enable
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:444    .text:00000210 io_spi0_disable
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:470    .text:00000234 io_i2c0_speed
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:503    .text:00000260 io_i2c0_byte_transfer
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:647    .text:00000390 get_syscpreg
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:662    .text:000003a0 $d
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:679    .text:000003e0 $a
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:785    .text:00000468 set_syscpreg
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:804    .text:0000047c $d
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:814    .text:0000049c $a
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:834    .text:000004bc uart0_printf
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:879    .text:000004f4 uart0_scanf
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:946    .text:0000054c $d
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:952    .text:00000550 uart0_print_buffer
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:958    .text:00000550 $a
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:982    .text:00000574 memTestDataBus
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:1013   .text:00000598 memTestAddressBus
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:1217   .text:0000072c memTestDevice1
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:1278   .text:00000790 memTestDevice2
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:1347   .text:00000800 long_to_hex_string
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:1431   .text:00000870 memtest_run
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:1496   .text:000008f4 $d
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:1523   .text:00000908 main
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:1528   .text:00000908 $a
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:1594   .text:000009b0 $d
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:1606   .text:000009cc io_enable_xint
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:1616   .text:000009cc $a
C:\Users\jh\AppData\Local\Temp/cccHbaaa.s:1635   .text:000009dc io_disable_xint

NO UNDEFINED SYMBOLS
