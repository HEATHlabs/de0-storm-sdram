   1              		.file	"main.c"
   9              	.Ltext0:
  10              		.align	2
  11              		.global	io_read_gpio0_pin
  13              	io_read_gpio0_pin:
  14              	.LFB2:
  15              		.file 1 "../lib/io_driver.c"
   1:../lib/io_driver.c **** #include "io_driver.h"
   2:../lib/io_driver.c **** #include "storm_core.h"
   3:../lib/io_driver.c **** #include "storm_soc_basic.h"
   4:../lib/io_driver.c **** 
   5:../lib/io_driver.c **** // ################################################################################################
   6:../lib/io_driver.c **** // General Purpose IO (GENERAL_PURPOSE_CONTROLLER_0)
   7:../lib/io_driver.c **** // ################################################################################################
   8:../lib/io_driver.c **** 
   9:../lib/io_driver.c **** // ******************************************************************************
  10:../lib/io_driver.c **** // Read general purpose IO pin
  11:../lib/io_driver.c ****    unsigned long io_read_gpio0_pin(unsigned char pin)
  12:../lib/io_driver.c **** // ******************************************************************************
  13:../lib/io_driver.c **** {
  16              	 args = 0, pretend = 0, frame = 0
  17              		@ frame_needed = 0, uses_anonymous_args = 0
  18              		@ link register save eliminated.
  19              	.LVL0:
  20              		.loc 1 17 0
  14:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
  15:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
  16:../lib/io_driver.c **** 
  17:../lib/io_driver.c **** 		unsigned long temp = GPIO0_IN & (1<<pin);
  21              	r3, #61440
  22 0000 E3E03A0F 		ldr	r1, [r3, #-4091]
  23 0004 E5131FFB 		.loc 1 13 0
  24              		and	r2, r0, #255
  25 0008 E20020FF 		.loc 1 21 0
  18:../lib/io_driver.c **** 	
  19:../lib/io_driver.c **** //	set_cmsr(_cmsr);
  20:../lib/io_driver.c **** 	return temp;
  21:../lib/io_driver.c **** }
  26              	r0, #1
  27 000c E3A00001 	.LVL1:
  28              		and	r0, r1, r0, asl r2
  29 0010 E0010210 		.loc 1 13 0
  30              		@ lr needed for prologue
  31              		.loc 1 21 0
  32              		bx	lr
  33 0014 E12FFF1E 	.LFE2:
  35              		.align	2
  36              		.global	io_read_gpio0_port
  38              	io_read_gpio0_port:
  39              	.LFB3:
  40              		.loc 1 27 0
  22:../lib/io_driver.c **** 
  23:../lib/io_driver.c **** // ******************************************************************************
  24:../lib/io_driver.c **** // Read general purpose IO port
  25:../lib/io_driver.c ****    unsigned long io_read_gpio0_port(void)
  26:../lib/io_driver.c **** // ******************************************************************************
  27:../lib/io_driver.c **** {
  41              	etend = 0, frame = 0
  42              		@ frame_needed = 0, uses_anonymous_args = 0
  43              		@ link register save eliminated.
  44              		.loc 1 31 0
  28:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
  29:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
  30:../lib/io_driver.c **** 
  31:../lib/io_driver.c **** 		unsigned long temp = GPIO0_IN;
  45              		r3, #61440
  46 0018 E3E03A0F 		ldr	r0, [r3, #-4091]
  47 001c E5130FFB 	.LVL2:
  48              		.loc 1 27 0
  49              		@ lr needed for prologue
  50              	.LVL3:
  51              		.loc 1 35 0
  32:../lib/io_driver.c **** 
  33:../lib/io_driver.c **** //	set_cmsr(_cmsr);
  34:../lib/io_driver.c **** 	return temp;
  35:../lib/io_driver.c **** }
  52              	.LFE3:
  54              		.align	2
  55              		.global	io_set_gpio0_pin
  57              	io_set_gpio0_pin:
  58              	.LFB4:
  59              		.loc 1 41 0
  60              		@ args = 0, pretend = 0, frame = 0
  36:../lib/io_driver.c **** 
  37:../lib/io_driver.c **** // ******************************************************************************
  38:../lib/io_driver.c **** // Set general purpose IO port
  39:../lib/io_driver.c ****    void io_set_gpio0_pin(unsigned char pin)
  40:../lib/io_driver.c **** // ******************************************************************************
  41:../lib/io_driver.c **** {
  61              	needed = 0, uses_anonymous_args = 0
  62              		@ link register save eliminated.
  63              	.LVL4:
  64              		.loc 1 45 0
  65              		mvn	r1, #61440
  42:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
  43:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
  44:../lib/io_driver.c **** 
  45:../lib/io_driver.c **** 		GPIO0_OUT = GPIO0_OUT | (1<<pin);
  66              	r3, [r1, #-4095]
  67 0024 E3E01A0F 		.loc 1 41 0
  68 0028 E5113FFF 		and	r0, r0, #255
  69              		.loc 1 45 0
  70 002c E20000FF 		mov	r2, #1
  71              		orr	r3, r3, r2, asl r0
  72 0030 E3A02001 		.loc 1 41 0
  73 0034 E1833012 		@ lr needed for prologue
  74              		.loc 1 45 0
  75              		str	r3, [r1, #-4095]
  76              		.loc 1 48 0
  77 0038 E5013FFF 		bx	lr
  46:../lib/io_driver.c **** 
  47:../lib/io_driver.c **** //	set_cmsr(_cmsr);
  48:../lib/io_driver.c **** }
  78              	e	io_set_gpio0_pin, .-io_set_gpio0_pin
  79 003c E12FFF1E 		.align	2
  80              		.global	io_clr_gpio0_pin
  82              	io_clr_gpio0_pin:
  83              	.LFB5:
  84              		.loc 1 54 0
  85              		@ args = 0, pretend = 0, frame = 0
  86              		@ frame_needed = 0, uses_anonymous_args = 0
  49:../lib/io_driver.c **** 
  50:../lib/io_driver.c **** // ******************************************************************************
  51:../lib/io_driver.c **** // Clear general purpose IO port
  52:../lib/io_driver.c ****    void io_clr_gpio0_pin(unsigned char pin)
  53:../lib/io_driver.c **** // ******************************************************************************
  54:../lib/io_driver.c **** {
  87              	egister save eliminated.
  88              	.LVL5:
  89              		and	r0, r0, #255
  90              		.loc 1 58 0
  91              		mov	r2, #1
  92 0040 E20000FF 		mov	r2, r2, asl r0
  55:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
  56:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
  57:../lib/io_driver.c **** 
  58:../lib/io_driver.c **** 		GPIO0_OUT = GPIO0_OUT & ~(1<<pin);
  93              	1, #61440
  94 0044 E3A02001 		ldr	r3, [r1, #-4095]
  95 0048 E1A02012 		mvn	r2, r2
  96 004c E3E01A0F 		and	r3, r3, r2
  97 0050 E5113FFF 		.loc 1 54 0
  98 0054 E1E02002 		@ lr needed for prologue
  99 0058 E0033002 		.loc 1 58 0
 100              		str	r3, [r1, #-4095]
 101              		.loc 1 61 0
 102              		bx	lr
 103 005c E5013FFF 	.LFE5:
  59:../lib/io_driver.c **** 
  60:../lib/io_driver.c **** //	set_cmsr(_cmsr);
  61:../lib/io_driver.c **** }
 104              	lr_gpio0_pin, .-io_clr_gpio0_pin
 105 0060 E12FFF1E 		.align	2
 106              		.global	io_toggle_gpio0_pin
 108              	io_toggle_gpio0_pin:
 109              	.LFB6:
 110              		.loc 1 66 0
 111              		@ args = 0, pretend = 0, frame = 0
 112              		@ frame_needed = 0, uses_anonymous_args = 0
  62:../lib/io_driver.c **** // ******************************************************************************
  63:../lib/io_driver.c **** // Set general purpose IO port
  64:../lib/io_driver.c ****    void io_toggle_gpio0_pin(unsigned char pin)
  65:../lib/io_driver.c **** // ******************************************************************************
  66:../lib/io_driver.c **** {
 113              	egister save eliminated.
 114              	.LVL6:
 115              		.loc 1 70 0
 116              		mvn	r1, #61440
 117              		ldr	r3, [r1, #-4095]
  67:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
  68:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
  69:../lib/io_driver.c **** 
  70:../lib/io_driver.c **** 		GPIO0_OUT = GPIO0_OUT ^ (1<<pin);
 118              	 1 66 0
 119 0064 E3E01A0F 		and	r0, r0, #255
 120 0068 E5113FFF 		.loc 1 70 0
 121              		mov	r2, #1
 122 006c E20000FF 		eor	r3, r3, r2, asl r0
 123              		.loc 1 66 0
 124 0070 E3A02001 		@ lr needed for prologue
 125 0074 E0233012 		.loc 1 70 0
 126              		str	r3, [r1, #-4095]
 127              		.loc 1 73 0
 128              		bx	lr
 129 0078 E5013FFF 	.LFE6:
  71:../lib/io_driver.c **** 
  72:../lib/io_driver.c **** //	set_cmsr(_cmsr);
  73:../lib/io_driver.c **** }
 130              	ggle_gpio0_pin, .-io_toggle_gpio0_pin
 131 007c E12FFF1E 		.align	2
 132              		.global	io_set_gpio0_port
 134              	io_set_gpio0_port:
 135              	.LFB7:
 136              		.loc 1 79 0
 137              		@ args = 0, pretend = 0, frame = 0
 138              		@ frame_needed = 0, uses_anonymous_args = 0
  74:../lib/io_driver.c **** 
  75:../lib/io_driver.c **** // ******************************************************************************
  76:../lib/io_driver.c **** // Clear general purpose IO port
  77:../lib/io_driver.c ****    void io_set_gpio0_port(unsigned long value)
  78:../lib/io_driver.c **** // ******************************************************************************
  79:../lib/io_driver.c **** {
 139              	egister save eliminated.
 140              	.LVL7:
 141              		.loc 1 83 0
 142              		mvn	r3, #61440
 143              		.loc 1 79 0
  80:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
  81:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
  82:../lib/io_driver.c **** 
  83:../lib/io_driver.c **** 		GPIO0_OUT = value;
 144              	 needed for prologue
 145 0080 E3E03A0F 		.loc 1 83 0
 146              		str	r0, [r3, #-4095]
 147              		.loc 1 86 0
 148              		bx	lr
 149 0084 E5030FFF 	.LFE7:
  84:../lib/io_driver.c **** 
  85:../lib/io_driver.c **** //	set_cmsr(_cmsr);
  86:../lib/io_driver.c **** }
 150              		io_set_gpio0_port, .-io_set_gpio0_port
 151 0088 E12FFF1E 		.align	2
 152              		.global	io_set_pwm
 154              	io_set_pwm:
 155              	.LFB8:
 156              		.loc 1 98 0
 157              		@ args = 0, pretend = 0, frame = 0
 158              		@ frame_needed = 0, uses_anonymous_args = 0
  87:../lib/io_driver.c **** 
  88:../lib/io_driver.c **** 
  89:../lib/io_driver.c **** 
  90:../lib/io_driver.c **** // ################################################################################################
  91:../lib/io_driver.c **** // Pulse-Width-Modulation Controller
  92:../lib/io_driver.c **** // ################################################################################################
  93:../lib/io_driver.c **** 
  94:../lib/io_driver.c **** // ******************************************************************************
  95:../lib/io_driver.c **** // Set pwm value
  96:../lib/io_driver.c ****    void io_set_pwm(unsigned char port, unsigned char data)
  97:../lib/io_driver.c **** // ******************************************************************************
  98:../lib/io_driver.c **** {
 159              	nd	r0, r0, #255
 160              		.loc 1 105 0
 161              		cmp	r0, #7
 162              		.loc 1 98 0
 163 008c E20000FF 		stmfd	sp!, {r4, lr}
  99:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 100:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 101:../lib/io_driver.c **** 
 102:../lib/io_driver.c **** 	unsigned long temp = 0;
 103:../lib/io_driver.c **** 
 104:../lib/io_driver.c **** 	// value adjustment
 105:../lib/io_driver.c **** 	if(port > 7)
 164              	0:
 165 0090 E3500007 		.loc 1 105 0
 166              		mov	ip, #0
 167 0094 E92D4010 		mvn	lr, #255
 168              		.loc 1 98 0
 169              		and	r1, r1, #255
 170 0098 E3A0C000 		.loc 1 105 0
 171 009c E3E0E0FF 		bhi	.L16
 172              		.loc 1 117 0
 173 00a0 E20110FF 		sub	r3, r0, #4
 174              		and	r3, r3, #255
 175 00a4 8A000011 		.loc 1 108 0
 106:../lib/io_driver.c **** 		port = 0;
 107:../lib/io_driver.c **** 
 108:../lib/io_driver.c **** 	if(port < 4){
 109:../lib/io_driver.c **** 		temp = PWM0_CONF0; // get working copy
 110:../lib/io_driver.c **** 		temp = temp & ~(0xFF << (port*8)); // clear old value
 111:../lib/io_driver.c **** 		temp = temp | (unsigned long)(data << (port*8)); // insert new value
 112:../lib/io_driver.c **** 		PWM0_CONF0 = temp;
 113:../lib/io_driver.c **** 	}
 114:../lib/io_driver.c **** 	else{
 115:../lib/io_driver.c **** 		port = port-4;
 116:../lib/io_driver.c **** 		temp = PWM0_CONF1; // get working copy
 117:../lib/io_driver.c **** 		temp = temp & ~(0xFF << (port*8)); // clear old value
 176              		.loc 1 117 0
 177 00a8 E2403004 		mov	lr, r3, asl #3
 178 00ac E20330FF 		.loc 1 116 0
 179              		mvn	r4, #61440
 180 00b0 E3500003 		.loc 1 108 0
 181              		mov	ip, r0, asl #3
 182 00b4 E1A0E183 		bls	.L22
 183              		.loc 1 117 0
 184 00b8 E3E04A0F 		mov	r3, #255
 185              		mov	r3, r3, asl lr
 186 00bc E1A0C180 		.loc 1 116 0
 187 00c0 9A000007 		ldr	r2, [r4, #-3979]
 188              	.LVL9:
 189 00c4 E3A030FF 		.loc 1 117 0
 190 00c8 E1A03E13 		mvn	r3, r3
 191              		and	r2, r2, r3
 192 00cc E5142F8B 	.LVL10:
 193              		.loc 1 118 0
 194              		orr	r2, r2, r1, asl lr
 195 00d0 E1E03003 	.LVL11:
 196 00d4 E0022003 		.loc 1 119 0
 197              		str	r2, [r4, #-3979]
 118:../lib/io_driver.c **** 		temp = temp | (unsigned long)(data << (port*8)); // insert new value
 198              	LVL12:
 199 00d8 E1822E11 	.L22:
 200              		.loc 1 108 0
 119:../lib/io_driver.c **** 		PWM0_CONF1 = temp;
 201              	v	r3, #255
 202 00dc E5042F8B 		mov	r3, r3, asl ip
 203 00e0 E8BD8010 		mvn	lr, r3
 204              	.L16:
 205              		.loc 1 109 0
 206              		mvn	r2, #61440
 207 00e4 E3A030FF 		ldr	r3, [r2, #-3983]
 208 00e8 E1A03C13 	.LVL13:
 209 00ec E1E0E003 		.loc 1 110 0
 210              		and	r3, r3, lr
 211              	.LVL14:
 212 00f0 E3E02A0F 		.loc 1 111 0
 213 00f4 E5123F8F 		orr	r3, r3, r1, asl ip
 214              	.LVL15:
 215              		.loc 1 112 0
 216 00f8 E003300E 		str	r3, [r2, #-3983]
 217              		ldmfd	sp!, {r4, pc}
 218              	.LFE8:
 220              		.align	2
 221              		.global	io_get_pwm
 223 0104 E8BD8010 	io_get_pwm:
 224              	.LFB9:
 225              		.loc 1 128 0
 226              		@ args = 0, pretend = 0, frame = 0
 227              		@ frame_needed = 0, uses_anonymous_args = 0
 228              		@ link register save eliminated.
 229              	.LVL16:
 230              		and	r0, r0, #255
 120:../lib/io_driver.c **** 	}
 121:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 122:../lib/io_driver.c **** }
 123:../lib/io_driver.c **** 
 124:../lib/io_driver.c **** // ******************************************************************************
 125:../lib/io_driver.c **** // Set pwm value
 126:../lib/io_driver.c ****    unsigned char io_get_pwm(unsigned char port)
 127:../lib/io_driver.c **** // ******************************************************************************
 128:../lib/io_driver.c **** {
 231              	c 1 128 0
 232              		@ lr needed for prologue
 233              		.loc 1 135 0
 234              		mov	r2, #0
 235              		bhi	.L26
 236 0108 E20000FF 		.loc 1 142 0
 129:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 130:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 131:../lib/io_driver.c **** 
 132:../lib/io_driver.c **** 	unsigned long temp = 0;
 133:../lib/io_driver.c **** 
 134:../lib/io_driver.c **** 	// value adjustment
 135:../lib/io_driver.c **** 	if(port > 7)
 237              	3, r0, #4
 238 010c E3500007 		.loc 1 138 0
 239              		cmp	r0, #3
 240              		.loc 1 142 0
 241              		and	r2, r3, #255
 242 0110 E3A02000 		.loc 1 138 0
 243 0114 8A00000A 		bls	.L31
 136:../lib/io_driver.c **** 		port = 0;
 137:../lib/io_driver.c **** 
 138:../lib/io_driver.c **** 	if(port < 4)
 139:../lib/io_driver.c **** 		temp = PWM0_CONF0; // get config register
 140:../lib/io_driver.c **** 	else{
 141:../lib/io_driver.c **** 		port = port-4;
 142:../lib/io_driver.c **** 		temp = PWM0_CONF1; // get config register
 244              	 142 0
 245 0118 E2403004 		mvn	r3, #61440
 246              		ldr	r0, [r3, #-3979]
 247 011c E3500003 	.LVL17:
 248              		mov	r2, r2, asl #3
 249 0120 E20320FF 		mov	r0, r0, lsr r2
 250              	.LVL18:
 251 0124 9A000005 		and	r0, r0, #255
 252              		.loc 1 149 0
 253 0128 E3E03A0F 		bx	lr
 254 012c E5130F8B 	.LVL19:
 255              	.L31:
 256 0130 E1A02182 		.loc 1 138 0
 257 0134 E1A00230 		mov	r2, r0, asl #3
 258              	.L26:
 259 0138 E20000FF 		.loc 1 139 0
 143:../lib/io_driver.c **** 	}
 144:../lib/io_driver.c **** 
 145:../lib/io_driver.c **** 	temp = temp >> (port*8); // only keep designated byte
 146:../lib/io_driver.c **** 
 147:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 148:../lib/io_driver.c **** 	return (unsigned char)temp;
 149:../lib/io_driver.c **** }
 260              		ldr	r0, [r3, #-3983]
 261 013c E12FFF1E 	.LVL20:
 262              		.loc 1 142 0
 263              		mov	r0, r0, lsr r2
 264              	.LVL21:
 265 0140 E1A02180 		and	r0, r0, #255
 266              		.loc 1 149 0
 267              		bx	lr
 268 0144 E3E03A0F 	.LFE9:
 270              		.align	2
 271              		.global	io_uart0_read_byte
 273              	io_uart0_read_byte:
 274 0150 E20000FF 	.LFB10:
 275              		.loc 1 161 0
 276 0154 E12FFF1E 		@ args = 0, pretend = 0, frame = 0
 277              		@ frame_needed = 0, uses_anonymous_args = 0
 278              		@ link register save eliminated.
 279              		.loc 1 166 0
 280              		mvn	r2, #61440
 281              		ldr	r3, [r2, #-3835]
 282              		tst	r3, #2
 283              		mvn	r0, #0
 150:../lib/io_driver.c **** 
 151:../lib/io_driver.c **** 
 152:../lib/io_driver.c **** 
 153:../lib/io_driver.c **** // ################################################################################################
 154:../lib/io_driver.c **** // General Purpose UART "miniUART" (UART_0)
 155:../lib/io_driver.c **** // ################################################################################################
 156:../lib/io_driver.c **** 
 157:../lib/io_driver.c **** // ******************************************************************************
 158:../lib/io_driver.c **** // Read one byte via UART 0
 159:../lib/io_driver.c ****    int io_uart0_read_byte(void)
 160:../lib/io_driver.c **** // ******************************************************************************
 161:../lib/io_driver.c **** {
 284              	drne	r0, [r2, #-3839]
 285              		.loc 1 161 0
 286              		@ lr needed for prologue
 287              	.LVL23:
 162:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 163:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 164:../lib/io_driver.c **** 
 165:../lib/io_driver.c **** 	int temp;
 166:../lib/io_driver.c **** 	if ((UART0_SREG & (1<<CUART_RXD)) != 0) // byte available?
 288              	c 1 173 0
 289 0158 E3E02A0F 		bx	lr
 290 015c E5123EFB 	.LFE10:
 292 0164 E3E00000 		.align	2
 293              		.global	io_uart0_send_byte
 167:../lib/io_driver.c **** 		temp = UART0_DATA;
 294              		io_uart0_send_byte, %function
 295 0168 15120EFF 	io_uart0_send_byte:
 296              	.LFB11:
 297              		.loc 1 179 0
 298              		@ args = 0, pretend = 0, frame = 0
 168:../lib/io_driver.c **** 	else
 169:../lib/io_driver.c **** 		temp = -1;
 170:../lib/io_driver.c **** 
 171:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 172:../lib/io_driver.c **** 	return temp;
 173:../lib/io_driver.c **** }
 299              	ame_needed = 0, uses_anonymous_args = 0
 300 016c E12FFF1E 		@ link register save eliminated.
 301              	.LVL24:
 302              		@ lr needed for prologue
 303              		mvn	r2, #61440
 304              	.L39:
 305              		.loc 1 183 0
 306              		ldr	r3, [r2, #-3835]
 307              		tst	r3, #1
 174:../lib/io_driver.c **** 
 175:../lib/io_driver.c **** // ******************************************************************************
 176:../lib/io_driver.c **** // Write one byte via UART 0
 177:../lib/io_driver.c ****    int io_uart0_send_byte(int ch)
 178:../lib/io_driver.c **** // ******************************************************************************
 179:../lib/io_driver.c **** {
 308              	
 309              		.loc 1 184 0
 310              		and	r3, r0, #255
 311              		str	r3, [r2, #-3839]
 312              	.LVL25:
 313              		.loc 1 188 0
 314 0170 E3E02A0F 		bx	lr
 315              	.LFE11:
 180:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 181:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 182:../lib/io_driver.c **** 
 183:../lib/io_driver.c **** 	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 316              	io_uart0_send_byte, .-io_uart0_send_byte
 317 0174 E5123EFB 		.align	2
 318 0178 E3130001 		.global	io_spi0_config
 184:../lib/io_driver.c **** 	UART0_DATA = (ch & 0x000000FF);
 320              	pi0_config:
 321 0180 E20030FF 	.LFB12:
 322 0184 E5023EFF 		.loc 1 200 0
 323              		@ args = 0, pretend = 0, frame = 0
 185:../lib/io_driver.c **** 
 186:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 187:../lib/io_driver.c **** 	return ch;
 188:../lib/io_driver.c **** }
 324              	rame_needed = 0, uses_anonymous_args = 0
 325 0188 E12FFF1E 		@ link register save eliminated.
 326              	.LVL26:
 327              		and	r0, r0, #255
 328              		.loc 1 206 0
 329              		cmp	r0, #1
 330              		.loc 1 209 0
 331              		orr	r2, r1, #1024
 332              		.loc 1 207 0
 189:../lib/io_driver.c **** 
 190:../lib/io_driver.c **** 
 191:../lib/io_driver.c **** 
 192:../lib/io_driver.c **** // ################################################################################################
 193:../lib/io_driver.c **** // Serial Peripherial Interface (SPI_CONTROLLER_0)
 194:../lib/io_driver.c **** // ################################################################################################
 195:../lib/io_driver.c **** 
 196:../lib/io_driver.c **** // ******************************************************************************
 197:../lib/io_driver.c **** // Configure SPI 0
 198:../lib/io_driver.c ****    void io_spi0_config(unsigned char auto_cs, unsigned long data_size)
 199:../lib/io_driver.c **** // ******************************************************************************
 200:../lib/io_driver.c **** {
 333              	, #61440
 334              		orr	r1, r1, #9216
 335              	.LVL27:
 336              		.loc 1 209 0
 337              		mvnne	r3, #61440
 338 018c E20000FF 		.loc 1 200 0
 201:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 202:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 203:../lib/io_driver.c **** 	// devices update their serial input on a rising edge of sclk,
 204:../lib/io_driver.c **** 	// so we need to update the mosi output of the core before
 205:../lib/io_driver.c **** 	// -> at the falling edge of sclk = set SPI_TX_NEG
 206:../lib/io_driver.c **** 	if(auto_cs == 1)
 339              	needed for prologue
 340 0190 E3500001 		.loc 1 207 0
 207:../lib/io_driver.c **** 		SPI0_CONF = (1<<SPI_ACS) | (1<<SPI_TX_NEG) | data_size; // auto assert cs
 208:../lib/io_driver.c **** 	else
 209:../lib/io_driver.c **** 		SPI0_CONF = (0<<SPI_ACS) | (1<<SPI_TX_NEG) | data_size; // manual assert cs
 341              	treq	r1, [r3, #-3327]
 342 0194 E3812B01 		.loc 1 209 0
 343              		strne	r2, [r3, #-3327]
 344 0198 03E03A0F 		bx	lr
 345 019c E3811B09 	.LFE12:
 347              		.align	2
 348 01a0 13E03A0F 		.global	io_spi0_speed
 350              	io_spi0_speed:
 351              	.LFB13:
 352 01a4 05031CFF 		.loc 1 217 0
 353              		@ args = 0, pretend = 0, frame = 0
 354 01a8 15032CFF 		@ frame_needed = 0, uses_anonymous_args = 0
 355 01ac E12FFF1E 		@ link register save eliminated.
 356              	.LVL28:
 357              		.loc 1 221 0
 358              		mvn	r3, #61440
 359              		.loc 1 217 0
 360              		@ lr needed for prologue
 361              		.loc 1 221 0
 362              		str	r0, [r3, #-3323]
 210:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 211:../lib/io_driver.c **** }
 212:../lib/io_driver.c **** 
 213:../lib/io_driver.c **** // ******************************************************************************
 214:../lib/io_driver.c **** // Configure SPI 0 CLK frequency -> (sys_clk/(spi_clk*2))-1
 215:../lib/io_driver.c ****    void io_spi0_speed(unsigned long clk_divider)
 216:../lib/io_driver.c **** // ******************************************************************************
 217:../lib/io_driver.c **** {
 363              	LFE13:
 365              		.align	2
 366              		.global	io_spi0_trans
 218:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 219:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 220:../lib/io_driver.c **** 
 221:../lib/io_driver.c **** 		SPI0_PRSC = clk_divider; // (sys_clk/(spi_clk*2))-1;
 368              	i0_trans:
 369 01b0 E3E03A0F 	.LFB14:
 370              		.loc 1 230 0
 371              		@ args = 0, pretend = 0, frame = 0
 372              		@ frame_needed = 0, uses_anonymous_args = 0
 373 01b4 E5030CFB 		@ link register save eliminated.
 222:../lib/io_driver.c **** 
 223:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 224:../lib/io_driver.c **** }
 374              	:
 375 01b8 E12FFF1E 		@ lr needed for prologue
 376              		mvn	r2, #61440
 377              	.L53:
 378              		.loc 1 235 0
 379              		ldr	r3, [r2, #-3327]
 380              		tst	r3, #256
 381              		bne	.L53
 382              		.loc 1 236 0
 225:../lib/io_driver.c **** 
 226:../lib/io_driver.c **** // ******************************************************************************
 227:../lib/io_driver.c **** // Sends/receives max 32 bits via SPI, CS and config must be done outside
 228:../lib/io_driver.c ****    unsigned long io_spi0_trans(unsigned long data)
 229:../lib/io_driver.c **** // ******************************************************************************
 230:../lib/io_driver.c **** {
 383              	[r2, #-3311]
 384              		.loc 1 237 0
 385              		ldr	r3, [r2, #-3327]
 386              		orr	r3, r3, #256
 387              		str	r3, [r2, #-3327]
 388              		mvn	r2, #61440
 389 01bc E3E02A0F 	.L55:
 390              		.loc 1 238 0
 231:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 232:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 233:../lib/io_driver.c **** 
 234:../lib/io_driver.c **** 	// spi transmission
 235:../lib/io_driver.c **** 	while((SPI0_CONF & (1<<SPI_BUSY)) != 0); // wait for prev tx to finish
 391              	 [r2, #-3327]
 392 01c0 E5123CFF 		tst	r3, #256
 393 01c4 E3130C01 		bne	.L55
 394 01c8 1AFFFFFC 		.loc 1 239 0
 236:../lib/io_driver.c **** 	SPI0_DAT0 = data;
 395              		r0, [r2, #-3311]
 396 01cc E5020CEF 	.LVL30:
 237:../lib/io_driver.c **** 	SPI0_CONF = SPI0_CONF | (1<<SPI_BUSY); // start transmitter
 397              	VL31:
 398 01d0 E5123CFF 		.loc 1 243 0
 399 01d4 E3833C01 		bx	lr
 400 01d8 E5023CFF 	.LFE14:
 402              		.align	2
 238:../lib/io_driver.c **** 	while((SPI0_CONF & (1<<SPI_BUSY)) != 0); // wait for rx to finish
 403              	al	io_spi0_enable
 405 01e4 E3130C01 	io_spi0_enable:
 406 01e8 1AFFFFFC 	.LFB15:
 239:../lib/io_driver.c **** 	unsigned long temp = SPI0_DAT0;
 407              	c 1 249 0
 408 01ec E5120CEF 		@ args = 0, pretend = 0, frame = 0
 409              		@ frame_needed = 0, uses_anonymous_args = 0
 410              		@ link register save eliminated.
 240:../lib/io_driver.c **** 
 241:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 242:../lib/io_driver.c **** 	return temp;
 243:../lib/io_driver.c **** }
 411              	32:
 412 01f0 E12FFF1E 		.loc 1 253 0
 413              		mvn	r1, #61440
 414              		ldr	r3, [r1, #-3319]
 415              		.loc 1 249 0
 416              		and	r0, r0, #255
 417              		.loc 1 253 0
 418              		mov	r2, #1
 419              		orr	r3, r3, r2, asl r0
 244:../lib/io_driver.c **** 
 245:../lib/io_driver.c **** // ******************************************************************************
 246:../lib/io_driver.c **** // Controls the CS of SPI0, enables a connected CS (turns it LOW)
 247:../lib/io_driver.c ****    void io_spi0_enable(unsigned char device)
 248:../lib/io_driver.c **** // ******************************************************************************
 249:../lib/io_driver.c **** {
 420              	49 0
 421              		@ lr needed for prologue
 422              		.loc 1 253 0
 423              		str	r3, [r1, #-3319]
 424              		.loc 1 256 0
 250:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 251:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 252:../lib/io_driver.c **** 
 253:../lib/io_driver.c **** 		SPI0_SCSR = SPI0_SCSR | (1<<device);
 425              	r
 426 01f4 E3E01A0F 	.LFE15:
 428              		.align	2
 429 01fc E20000FF 		.global	io_spi0_disable
 431 0200 E3A02001 	io_spi0_disable:
 432 0204 E1833012 	.LFB16:
 433              		.loc 1 262 0
 434              		@ args = 0, pretend = 0, frame = 0
 435              		@ frame_needed = 0, uses_anonymous_args = 0
 436 0208 E5013CF7 		@ link register save eliminated.
 254:../lib/io_driver.c **** 
 255:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 256:../lib/io_driver.c **** }
 437              		r0, r0, #255
 438 020c E12FFF1E 		.loc 1 266 0
 439              		mov	r2, #1
 440              		mov	r2, r2, asl r0
 441              		mvn	r1, #61440
 442              		ldr	r3, [r1, #-3319]
 443              		mvn	r2, r2
 444              		and	r3, r3, r2
 445              		.loc 1 262 0
 257:../lib/io_driver.c **** 
 258:../lib/io_driver.c **** // ******************************************************************************
 259:../lib/io_driver.c **** // Controls the CS of SPI0, disables a connected CS (turns it HIGH)
 260:../lib/io_driver.c ****    void io_spi0_disable(unsigned char device)
 261:../lib/io_driver.c **** // ******************************************************************************
 262:../lib/io_driver.c **** {
 446              	ded for prologue
 447              		.loc 1 266 0
 448              		str	r3, [r1, #-3319]
 449              		.loc 1 269 0
 450              		bx	lr
 451 0210 E20000FF 	.LFE16:
 263:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 264:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 265:../lib/io_driver.c **** 
 266:../lib/io_driver.c **** 		SPI0_SCSR = SPI0_SCSR & ~(1<<device);
 452              		io_spi0_disable, .-io_spi0_disable
 453 0214 E3A02001 		.align	2
 454 0218 E1A02012 		.global	io_i2c0_speed
 456 0220 E5113CF7 	io_i2c0_speed:
 457 0224 E1E02002 	.LFB17:
 458 0228 E0033002 		.loc 1 282 0
 459              		@ args = 0, pretend = 0, frame = 0
 460              		@ frame_needed = 0, uses_anonymous_args = 0
 461              		@ link register save eliminated.
 462 022c E5013CF7 	.LVL34:
 267:../lib/io_driver.c **** 
 268:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 269:../lib/io_driver.c **** }
 463              	 0
 464 0230 E12FFF1E 		mvn	r2, #61440
 465              		ldr	r3, [r2, #-3047]
 466              		.loc 1 287 0
 467              		mov	r1, r0, lsr #8
 468              		.loc 1 285 0
 469              		bic	r3, r3, #128
 470              		str	r3, [r2, #-3047]
 471              		.loc 1 286 0
 270:../lib/io_driver.c **** 
 271:../lib/io_driver.c **** 
 272:../lib/io_driver.c **** 
 273:../lib/io_driver.c **** 
 274:../lib/io_driver.c **** // ################################################################################################
 275:../lib/io_driver.c **** // Inter Intergrated Circuit Interface (I²C_CONTROLLER_0)
 276:../lib/io_driver.c **** // ################################################################################################
 277:../lib/io_driver.c **** 
 278:../lib/io_driver.c **** // ******************************************************************************
 279:../lib/io_driver.c **** // Configure SPI 0 CLK frequency -> (sys_clk/(5*i2c_clock)-1
 280:../lib/io_driver.c ****    void io_i2c0_speed(unsigned long clk_divider)
 281:../lib/io_driver.c **** // ******************************************************************************
 282:../lib/io_driver.c **** {
 472              	[r2, #-3055]
 473              		.loc 1 287 0
 474              		str	r1, [r2, #-3051]
 475              		.loc 1 288 0
 476              		ldr	r3, [r2, #-3047]
 283:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 284:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 285:../lib/io_driver.c **** 		I2C0_CTRL = I2C0_CTRL & ~(1<<I2C_EN); // disable i2c core
 477              	r3, r3, #128
 478 0234 E3E02A0F 		.loc 1 282 0
 479 0238 E5123BE7 		@ lr needed for prologue
 286:../lib/io_driver.c **** 		I2C0_PRLO = clk_divider;
 287:../lib/io_driver.c **** 		I2C0_PRHI = clk_divider >> 8;
 480              	oc 1 288 0
 481 023c E1A01420 		str	r3, [r2, #-3047]
 482              		.loc 1 290 0
 483 0240 E3C33080 		bx	lr
 484 0244 E5023BE7 	.LFE17:
 486 0248 E5020BEF 		.align	2
 487              		.global	io_i2c0_byte_transfer
 288:../lib/io_driver.c **** 		I2C0_CTRL = I2C0_CTRL | (1<<I2C_EN); // enable i2c core
 489              	yte_transfer:
 490 0250 E5123BE7 	.LFB18:
 491 0254 E3833080 		.loc 1 300 0
 492              		@ args = 4, pretend = 0, frame = 0
 493              		@ frame_needed = 0, uses_anonymous_args = 0
 494              	.LVL35:
 495 0258 E5023BE7 		stmfd	sp!, {r4, r5, lr}
 289:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 290:../lib/io_driver.c **** }
 496              	
 497 025c E12FFF1E 		.loc 1 306 0
 498              		mov	ip, #144
 499              		.loc 1 305 0
 500              		and	r4, r1, #254
 501              		mvn	lr, #61440
 502              	.LVL36:
 503              		.loc 1 300 0
 504              		ldrb	r5, [sp, #15]	@ zero_extendqisi2
 291:../lib/io_driver.c **** 
 292:../lib/io_driver.c **** // ******************************************************************************
 293:../lib/io_driver.c **** // Read/write byte from/to I²C slave, max 2 address bytes
 294:../lib/io_driver.c ****    int io_i2c0_byte_transfer(unsigned char rw,        // 'r' read / 'w' write cycle
 295:../lib/io_driver.c ****                              unsigned char id,        // device ID
 296:../lib/io_driver.c **** 							 unsigned long data_adr,  // data address
 297:../lib/io_driver.c **** 							 unsigned char adr_bytes, // number of adr bytes
 298:../lib/io_driver.c **** 							 unsigned char data)      // data byte
 299:../lib/io_driver.c **** // ******************************************************************************
 300:../lib/io_driver.c **** {
 505              	 r0, #255
 506              		.loc 1 305 0
 507              		str	r4, [lr, #-3043]
 508              		.loc 1 300 0
 509 0260 E92D4030 		and	r1, r1, #255
 510              		.loc 1 306 0
 301:../lib/io_driver.c **** //	unsigned long _cmsr = get_cmsr();
 302:../lib/io_driver.c **** //	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
 303:../lib/io_driver.c **** 
 304:../lib/io_driver.c **** 	// transfer slave identification address
 305:../lib/io_driver.c **** 	I2C0_DATA = id & 0xFE;                  // device id and write
 306:../lib/io_driver.c **** 	I2C0_CMD = (1<<I2C_STA) | (1<<I2C_WR);  // start condition and write cycle
 511              	p, [lr, #-3071]
 512 0264 E3A0C090 		.loc 1 300 0
 513              		mov	r4, r2
 514 0268 E20140FE 		and	ip, r3, #255
 515 026c E3E0EA0F 	.LVL37:
 516              	.L69:
 517              		.loc 1 307 0
 518 0270 E5DD500F 		ldr	r3, [lr, #-3071]
 519 0274 E20000FF 		tst	r3, #2
 520              		bne	.L69
 521 0278 E50E4BE3 		.loc 1 308 0
 522              		ldr	r3, [lr, #-3071]
 523 027c E20110FF 		tst	r3, #128
 524              		mvnne	r0, #0
 525 0280 E50ECBFF 	.LVL38:
 526              		ldmnefd	sp!, {r4, r5, pc}
 527 0284 E1A04002 	.L80:
 528 0288 E203C0FF 		.loc 1 314 0
 529              		cmp	ip, #0
 530              		beq	.L109
 307:../lib/io_driver.c **** 	while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
 531              	3, ip, #1
 532 028c E51E3BFF 		and	ip, r3, #255
 533 0290 E3130002 		.loc 1 316 0
 534 0294 1AFFFFFC 		cmp	ip, #1
 308:../lib/io_driver.c **** 	if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
 535              	c 1 317 0
 536 0298 E51E3BFF 		moveq	r2, r4, lsr #8
 537 029c E3130080 		mvneq	r3, #61440
 538 02a0 13E00000 		.loc 1 319 0
 539              		mvnne	r3, #61440
 540 02a4 18BD8030 		.loc 1 317 0
 541              		streq	r2, [r3, #-3043]
 309:../lib/io_driver.c **** //		set_cmsr(_cmsr);
 310:../lib/io_driver.c **** 		return -1;
 311:../lib/io_driver.c **** 	}
 312:../lib/io_driver.c **** 
 313:../lib/io_driver.c **** 	// transfer data address
 314:../lib/io_driver.c **** 	while(adr_bytes != 0){
 542              	 319 0
 543 02a8 E35C0000 		strne	r4, [r3, #-3043]
 544 02ac 0A000012 		.loc 1 320 0
 315:../lib/io_driver.c **** 		adr_bytes--;
 545              	n	r2, #61440
 546 02b0 E24C3001 		mov	r3, #16
 547 02b4 E203C0FF 		str	r3, [r2, #-3071]
 316:../lib/io_driver.c **** 		if(adr_bytes == 1)
 548              	8:
 549 02b8 E35C0001 		.loc 1 321 0
 317:../lib/io_driver.c **** 			I2C0_DATA = data_adr >> 8;          // high byte
 550              	dr	r3, [r2, #-3071]
 551 02bc 01A02424 		tst	r3, #2
 552 02c0 03E03A0F 		bne	.L78
 318:../lib/io_driver.c **** 		else
 319:../lib/io_driver.c **** 			I2C0_DATA = data_adr;               // low byte
 553              	oc 1 322 0
 554 02c4 13E03A0F 		ldr	r3, [r2, #-3071]
 555              		tst	r3, #128
 556 02c8 05032BE3 		beq	.L80
 557              		mvn	r0, #1
 558 02cc 15034BE3 		ldmfd	sp!, {r4, r5, pc}
 320:../lib/io_driver.c **** 		I2C0_CMD = (1<<I2C_WR);                 // write cycle
 559              	:
 560 02d0 E3E02A0F 	.L109:
 561 02d4 E3A03010 	.LVL40:
 562 02d8 E5023BFF 		.loc 1 328 0
 563              		cmp	r0, #119
 321:../lib/io_driver.c **** 		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
 564              	.L83
 565 02dc E5123BFF 		.loc 1 330 0
 566 02e0 E3130002 		mvn	r3, #61440
 567 02e4 1AFFFFFC 		.loc 1 331 0
 322:../lib/io_driver.c **** 		if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
 568              		r2, #80
 569 02e8 E5123BFF 		.loc 1 330 0
 570 02ec E3130080 		str	r5, [r3, #-3043]
 571 02f0 0AFFFFEC 		.loc 1 331 0
 572 02f4 E3E00001 		str	r2, [r3, #-3071]
 573 02f8 E8BD8030 		mov	r2, r3
 574              	.L85:
 575              		.loc 1 332 0
 576              		ldr	r3, [r2, #-3071]
 323:../lib/io_driver.c **** //			set_cmsr(_cmsr);
 324:../lib/io_driver.c **** 			return -2;
 325:../lib/io_driver.c **** 		}
 326:../lib/io_driver.c **** 	}
 327:../lib/io_driver.c **** 
 328:../lib/io_driver.c **** 	if(rw == 'w'){
 577              	#2
 578 02fc E3500077 		bne	.L85
 579 0300 1A00000C 		.loc 1 333 0
 329:../lib/io_driver.c **** 		// write adressed byte
 330:../lib/io_driver.c **** 		I2C0_DATA = data;                       // send data
 580              	r	r3, [r2, #-3071]
 581 0304 E3E03A0F 		ands	r0, r3, #128
 331:../lib/io_driver.c **** 		I2C0_CMD = (1<<I2C_STO) | (1<<I2C_WR);  // stop condition and write cycle
 582              	VL41:
 583 0308 E3A02050 		ldmeqfd	sp!, {r4, r5, pc}
 584              	.L87:
 585 030c E5035BE3 		.loc 1 355 0
 586              		mvn	r0, #2
 587 0310 E5032BFF 		.loc 1 360 0
 588 0314 E1A02003 		ldmfd	sp!, {r4, r5, pc}
 589              	.LVL42:
 332:../lib/io_driver.c **** 		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
 590              	loc 1 343 0
 591 0318 E5123BFF 		cmp	r0, #114
 592 031c E3130002 		mvnne	r0, #3
 593 0320 1AFFFFFC 	.LVL43:
 333:../lib/io_driver.c **** 		if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
 594              	nefd	sp!, {r4, r5, pc}
 595 0324 E5123BFF 		.loc 1 345 0
 596 0328 E2130080 		orr	r3, r1, #1
 597              		mvn	r2, #61440
 598 032c 08BD8030 		.loc 1 346 0
 599              		mov	r1, #144
 334:../lib/io_driver.c **** //			set_cmsr(_cmsr);
 335:../lib/io_driver.c **** 			return -3;
 336:../lib/io_driver.c **** 		}
 337:../lib/io_driver.c **** 		else{
 338:../lib/io_driver.c **** //			set_cmsr(_cmsr);
 339:../lib/io_driver.c **** 			return 0;
 340:../lib/io_driver.c **** 		}
 341:../lib/io_driver.c **** 	}
 342:../lib/io_driver.c **** 
 343:../lib/io_driver.c **** 	if(rw == 'r'){
 344:../lib/io_driver.c **** 		// re-send control byte - this time with read-bit
 345:../lib/io_driver.c **** 		I2C0_DATA = id | 0x01;                  // device id and READ
 346:../lib/io_driver.c **** 		I2C0_CMD = (1<<I2C_STA) | (1<<I2C_WR);  // start condition and write cycle
 347:../lib/io_driver.c **** 		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
 348:../lib/io_driver.c **** 		if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
 349:../lib/io_driver.c **** //			set_cmsr(_cmsr);
 350:../lib/io_driver.c **** 			return -3;
 351:../lib/io_driver.c **** 		}
 352:../lib/io_driver.c **** 		// read adressed byte
 353:../lib/io_driver.c **** 		I2C0_CMD = (1<<I2C_STO) | (1<<I2C_RD) | (1<<I2C_ACK);
 354:../lib/io_driver.c **** 		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
 355:../lib/io_driver.c **** 		return I2C0_DATA;
 600              	:
 601 0330 E3E00002 		.loc 1 345 0
 356:../lib/io_driver.c **** 	}
 357:../lib/io_driver.c **** 
 358:../lib/io_driver.c **** //	set_cmsr(_cmsr);
 359:../lib/io_driver.c **** 	return -4;
 360:../lib/io_driver.c **** }
 602              	tr	r3, [r2, #-3043]
 603 0334 E8BD8030 		.loc 1 346 0
 604              		str	r1, [r2, #-3071]
 605              	.L91:
 606              		.loc 1 347 0
 607 0338 E3500072 		ldr	r3, [r2, #-3071]
 608 033c 13E00003 		tst	r3, #2
 609              		bne	.L91
 610 0340 18BD8030 		.loc 1 348 0
 611              		ldr	r3, [r2, #-3071]
 612 0344 E3813001 		tst	r3, #128
 613 0348 E3E02A0F 		bne	.L87
 614              		.loc 1 353 0
 615 034c E3A01090 		mov	r3, #104
 616              		str	r3, [r2, #-3071]
 617              		mvn	r0, #61440
 618 0350 E5023BE3 	.L94:
 619              		.loc 1 354 0
 620 0354 E5021BFF 		ldr	r3, [r0, #-3071]
 621              		tst	r3, #2
 622              		bne	.L94
 623 0358 E5123BFF 		.loc 1 355 0
 624 035c E3130002 		ldr	r0, [r0, #-3043]
 625 0360 1AFFFFFC 		ldmfd	sp!, {r4, r5, pc}
 626              	.LFE18:
 628 0368 E3130080 		.align	2
 629 036c 1AFFFFEF 		.global	get_syscpreg
 631 0370 E3A03068 	get_syscpreg:
 632 0374 E5023BFF 	.LFB19:
 633 0378 E3E00A0F 		.loc 1 373 0
 634              		@ args = 0, pretend = 0, frame = 0
 635              		@ frame_needed = 0, uses_anonymous_args = 0
 636 037c E5103BFF 		@ link register save eliminated.
 637 0380 E3130002 	.LVL45:
 638 0384 1AFFFFFC 		and	r0, r0, #255
 639              		@ lr needed for prologue
 640 0388 E5100BE3 		.loc 1 375 0
 641 038c E8BD8030 		cmp	r0, #15
 642              		ldrls	pc, [pc, r0, asl #2]
 643              		b	.L111
 644              		.p2align 2
 645              	.L128:
 646              		.word	.L112
 647              		.word	.L113
 648              		.word	.L114
 361:../lib/io_driver.c **** 
 362:../lib/io_driver.c **** 
 363:../lib/io_driver.c **** 
 364:../lib/io_driver.c **** 
 365:../lib/io_driver.c **** // ################################################################################################
 366:../lib/io_driver.c **** // System
 367:../lib/io_driver.c **** // ################################################################################################
 368:../lib/io_driver.c **** 
 369:../lib/io_driver.c **** // ******************************************************************************
 370:../lib/io_driver.c **** // read system coprocessor register x
 371:../lib/io_driver.c ****    unsigned long get_syscpreg(unsigned char index)
 372:../lib/io_driver.c **** // ******************************************************************************
 373:../lib/io_driver.c **** {
 649              	L118
 650              		.word	.L119
 651              		.word	.L120
 652              		.word	.L121
 653              		.word	.L122
 654 0390 E20000FF 		.word	.L123
 655              		.word	.L124
 374:../lib/io_driver.c **** 	unsigned long _cp_val;
 375:../lib/io_driver.c **** 	switch(index){
 656              	.L125
 657 0394 E350000F 		.word	.L126
 658 0398 979FF100 		.word	.L127
 659 039c EA00000F 	.L111:
 660              		mov	r0, #0
 661              	.LVL46:
 662 03a0 00000460 		bx	lr
 663 03a4 00000458 	.LVL47:
 664 03a8 00000450 	.L127:
 665 03ac 00000448 		.loc 1 391 0
 666 03b0 00000440 		mrc p15,0,r0,c15,c15
 667 03b4 00000438 	.LVL48:
 668 03b8 00000430 	.LVL49:
 669 03bc 00000428 		.loc 1 395 0
 670 03c0 00000420 		bx	lr
 671 03c4 00000418 	.LVL50:
 672 03c8 00000410 	.L126:
 673 03cc 00000408 		.loc 1 390 0
 674 03d0 00000400 		mrc p15,0,r0,c14,c14
 675 03d4 000003F8 	.LVL51:
 676 03d8 000003F0 		bx	lr
 677 03dc 000003E8 	.LVL52:
 678              	.L125:
 679 03e0 E3A00000 		.loc 1 389 0
 680              		mrc p15,0,r0,c13,c13
 681 03e4 E12FFF1E 	.LVL53:
 682              		bx	lr
 683              	.LVL54:
 376:../lib/io_driver.c **** 		case ID_REG_0:   asm volatile ("mrc p15,0,%0, c0, c0" : "=r" (_cp_val) : /* no inputs */  ); brea
 377:../lib/io_driver.c **** 		case ID_REG_1:   asm volatile ("mrc p15,0,%0, c1, c1" : "=r" (_cp_val) : /* no inputs */  ); brea
 378:../lib/io_driver.c **** 		case ID_REG_2:   asm volatile ("mrc p15,0,%0, c2, c2" : "=r" (_cp_val) : /* no inputs */  ); brea
 379:../lib/io_driver.c **** 		case 3:          asm volatile ("mrc p15,0,%0, c3, c3" : "=r" (_cp_val) : /* no inputs */  ); brea
 380:../lib/io_driver.c **** 		case 4:          asm volatile ("mrc p15,0,%0, c4, c4" : "=r" (_cp_val) : /* no inputs */  ); brea
 381:../lib/io_driver.c **** 		case 5:          asm volatile ("mrc p15,0,%0, c5, c5" : "=r" (_cp_val) : /* no inputs */  ); brea
 382:../lib/io_driver.c **** 		case SYS_CTRL_0: asm volatile ("mrc p15,0,%0, c6, c6" : "=r" (_cp_val) : /* no inputs */  ); brea
 383:../lib/io_driver.c **** 		case 7:          asm volatile ("mrc p15,0,%0, c7, c7" : "=r" (_cp_val) : /* no inputs */  ); brea
 384:../lib/io_driver.c **** 		case CSTAT:      asm volatile ("mrc p15,0,%0, c8, c8" : "=r" (_cp_val) : /* no inputs */  ); brea
 385:../lib/io_driver.c **** 		case ADR_FB:     asm volatile ("mrc p15,0,%0, c9, c9" : "=r" (_cp_val) : /* no inputs */  ); brea
 386:../lib/io_driver.c **** 		case 10:         asm volatile ("mrc p15,0,%0,c10,c10" : "=r" (_cp_val) : /* no inputs */  ); brea
 387:../lib/io_driver.c **** 		case LFSR_POLY:  asm volatile ("mrc p15,0,%0,c11,c11" : "=r" (_cp_val) : /* no inputs */  ); brea
 388:../lib/io_driver.c **** 		case LFSR_DATA:  asm volatile ("mrc p15,0,%0,c12,c12" : "=r" (_cp_val) : /* no inputs */  ); brea
 389:../lib/io_driver.c **** 		case SYS_IO:     asm volatile ("mrc p15,0,%0,c13,c13" : "=r" (_cp_val) : /* no inputs */  ); brea
 390:../lib/io_driver.c **** 		case 14:         asm volatile ("mrc p15,0,%0,c14,c14" : "=r" (_cp_val) : /* no inputs */  ); brea
 391:../lib/io_driver.c **** 		case 15:         asm volatile ("mrc p15,0,%0,c15,c15" : "=r" (_cp_val) : /* no inputs */  ); brea
 684              	5,0,r0,c12,c12
 685 03e8 EE1F0F1F 	.LVL55:
 686              		bx	lr
 687              	.LVL56:
 392:../lib/io_driver.c **** 		default:         _cp_val = 0; break;
 393:../lib/io_driver.c **** 	}
 394:../lib/io_driver.c **** 	return _cp_val;
 395:../lib/io_driver.c **** }
 688              	3:
 689 03ec E12FFF1E 		.loc 1 387 0
 690              		mrc p15,0,r0,c11,c11
 691              	.LVL57:
 692              		bx	lr
 693 03f0 EE1E0F1E 	.LVL58:
 694              	.L122:
 695 03f4 E12FFF1E 		.loc 1 386 0
 696              		mrc p15,0,r0,c10,c10
 697              	.LVL59:
 698              		bx	lr
 699 03f8 EE1D0F1D 	.LVL60:
 700              	.L121:
 701 03fc E12FFF1E 		.loc 1 385 0
 702              		mrc p15,0,r0, c9, c9
 703              	.LVL61:
 704              		bx	lr
 705 0400 EE1C0F1C 	.LVL62:
 706              	.L120:
 707 0404 E12FFF1E 		.loc 1 384 0
 708              		mrc p15,0,r0, c8, c8
 709              	.LVL63:
 710              		bx	lr
 711 0408 EE1B0F1B 	.LVL64:
 712              	.L119:
 713 040c E12FFF1E 		.loc 1 383 0
 714              		mrc p15,0,r0, c7, c7
 715              	.LVL65:
 716              		bx	lr
 717 0410 EE1A0F1A 	.LVL66:
 718              	.L118:
 719 0414 E12FFF1E 		.loc 1 382 0
 720              		mrc p15,0,r0, c6, c6
 721              	.LVL67:
 722              		bx	lr
 723 0418 EE190F19 	.LVL68:
 724              	.L117:
 725 041c E12FFF1E 		.loc 1 381 0
 726              		mrc p15,0,r0, c5, c5
 727              	.LVL69:
 728              		bx	lr
 729 0420 EE180F18 	.LVL70:
 730              	.L116:
 731 0424 E12FFF1E 		.loc 1 380 0
 732              		mrc p15,0,r0, c4, c4
 733              	.LVL71:
 734              		bx	lr
 735 0428 EE170F17 	.LVL72:
 736              	.L115:
 737 042c E12FFF1E 		.loc 1 379 0
 738              		mrc p15,0,r0, c3, c3
 739              	.LVL73:
 740              		bx	lr
 741 0430 EE160F16 	.LVL74:
 742              	.L114:
 743 0434 E12FFF1E 		.loc 1 378 0
 744              		mrc p15,0,r0, c2, c2
 745              	.LVL75:
 746              		bx	lr
 747 0438 EE150F15 	.LVL76:
 748              	.L113:
 749 043c E12FFF1E 		.loc 1 377 0
 750              		mrc p15,0,r0, c1, c1
 751              	.LVL77:
 752              		bx	lr
 753 0440 EE140F14 	.LVL78:
 754              	.L112:
 755 0444 E12FFF1E 		.loc 1 376 0
 756              		mrc p15,0,r0, c0, c0
 757              	.LVL79:
 758              		bx	lr
 759 0448 EE130F13 	.LFE19:
 761 044c E12FFF1E 		.align	2
 762              		.global	set_syscpreg
 764              	set_syscpreg:
 765 0450 EE120F12 	.LFB20:
 766              		.loc 1 401 0
 767 0454 E12FFF1E 		@ args = 0, pretend = 0, frame = 0
 768              		@ frame_needed = 0, uses_anonymous_args = 0
 769              		@ link register save eliminated.
 770              	.LVL80:
 771 0458 EE110F11 		and	r1, r1, #255
 772              		.loc 1 402 0
 773 045c E12FFF1E 		sub	r1, r1, #6
 774              	.LVL81:
 775              		.loc 1 401 0
 776              		@ lr needed for prologue
 777 0460 EE100F10 		.loc 1 402 0
 778              		cmp	r1, #7
 779 0464 E12FFF1E 		ldrls	pc, [pc, r1, asl #2]
 780              		b	.L138
 781              		.p2align 2
 782              	.L137:
 783              		.word	.L133
 784              		.word	.L138
 785              		.word	.L138
 786              		.word	.L138
 396:../lib/io_driver.c **** 
 397:../lib/io_driver.c **** // ******************************************************************************
 398:../lib/io_driver.c **** // write system coprocessor register x
 399:../lib/io_driver.c ****    void set_syscpreg(unsigned long _cp_val, unsigned char index)
 400:../lib/io_driver.c **** // ******************************************************************************
 401:../lib/io_driver.c **** {
 787              	138:
 788              		bx	lr
 789              	.L133:
 790              		.loc 1 409 0
 791              		mcr p15,0,r0, c6, c6,0
 792 0468 E20110FF 		bx	lr
 402:../lib/io_driver.c **** 	switch(index){
 793              	
 794 046c E2411006 		.loc 1 414 0
 795              		mcr p15,0,r0,c11,c11,0
 796              		bx	lr
 797              	.L135:
 798              		.loc 1 415 0
 799 0470 E3510007 		mcr p15,0,r0,c12,c12,0
 800 0474 979FF101 		bx	lr
 801 0478 EA000008 	.LFE20:
 803              		.align	2
 804 047c 000004A4 		.global	uart0_printf
 806 0484 000004A0 	uart0_printf:
 807 0488 000004A0 	.LFB25:
 808 048c 000004A0 		.file 2 "../lib/uart.c"
 809 0490 000004AC 		.loc 2 7 0
 810 0494 000004B4 		@ args = 0, pretend = 0, frame = 0
 811 0498 0000049C 		@ frame_needed = 0, uses_anonymous_args = 0
 812              	.LVL82:
 403:../lib/io_driver.c **** //		case ID_REG_0:   asm volatile ("mcr p15,0,%0, c0, c0,0" : /* no outputs */ : "r" (_cp_val)); br
 404:../lib/io_driver.c **** //		case ID_REG_1:   asm volatile ("mcr p15,0,%0, c1, c1,0" : /* no outputs */ : "r" (_cp_val)); br
 405:../lib/io_driver.c **** //		case ID_REG_2:   asm volatile ("mcr p15,0,%0, c2, c2,0" : /* no outputs */ : "r" (_cp_val)); br
 406:../lib/io_driver.c **** //		case 3:          asm volatile ("mcr p15,0,%0, c3, c3,0" : /* no outputs */ : "r" (_cp_val)); br
 407:../lib/io_driver.c **** //		case 4:          asm volatile ("mcr p15,0,%0, c4, c4,0" : /* no outputs */ : "r" (_cp_val)); br
 408:../lib/io_driver.c **** //		case 5:          asm volatile ("mcr p15,0,%0, c5, c5,0" : /* no outputs */ : "r" (_cp_val)); br
 409:../lib/io_driver.c **** 		case SYS_CTRL_0: asm volatile ("mcr p15,0,%0, c6, c6,0" : /* no outputs */ : "r" (_cp_val)); brea
 410:../lib/io_driver.c **** //		case 7:          asm volatile ("mcr p15,0,%0, c7, c7,0" : /* no outputs */ : "r" (_cp_val)); br
 411:../lib/io_driver.c **** //		case CSTAT:      asm volatile ("mcr p15,0,%0, c8, c8,0" : /* no outputs */ : "r" (_cp_val)); br
 412:../lib/io_driver.c **** //		case ADR_FB:     asm volatile ("mcr p15,0,%0, c9, c9,0" : /* no outputs */ : "r" (_cp_val)); br
 413:../lib/io_driver.c **** //		case 10:         asm volatile ("mcr p15,0,%0,c10,c10,0" : /* no outputs */ : "r" (_cp_val)); br
 414:../lib/io_driver.c **** 		case LFSR_POLY:  asm volatile ("mcr p15,0,%0,c11,c11,0" : /* no outputs */ : "r" (_cp_val)); brea
 415:../lib/io_driver.c **** 		case LFSR_DATA:  asm volatile ("mcr p15,0,%0,c12,c12,0" : /* no outputs */ : "r" (_cp_val)); brea
 416:../lib/io_driver.c **** 		case SYS_IO:     asm volatile ("mcr p15,0,%0,c13,c13,0" : /* no outputs */ : "r" (_cp_val)); brea
 813              	}
 814 049c EE0D0F1D 	.LCFI2:
 815              		.loc 2 7 0
 816 04a0 E12FFF1E 		mov	r4, r0
 817              		.loc 2 10 0
 818              		ldrb	r0, [r0, #0]	@ zero_extendqisi2
 819 04a4 EE060F16 	.LVL83:
 820 04a8 E12FFF1E 		cmp	r0, #0
 821              		bne	.L144
 822              		b	.L140
 823 04ac EE0B0F1B 	.LVL84:
 824 04b0 E12FFF1E 	.L146:
 825              		ldrb	r0, [r4, #1]!	@ zero_extendqisi2
 826              	.LVL85:
 827 04b4 EE0C0F1C 		cmp	r0, #0
 828 04b8 E12FFF1E 		beq	.L140
 829              	.L144:
 830              		.loc 2 11 0
 831              		bl	io_uart0_send_byte
 832              	.LVL86:
 833              		cmp	r0, #0
 834              		bgt	.L146
 835              	.LVL87:
 836              	.L140:
   1:../lib/uart.c **** #include "uart.h"
   2:../lib/uart.c **** 
   3:../lib/uart.c **** // ############################################################################################
   4:../lib/uart.c **** // Print text string via UART 0
   5:../lib/uart.c ****    const char *uart0_printf(const char *string)
   6:../lib/uart.c **** // ############################################################################################
   7:../lib/uart.c **** {
 837              	
 838              	.LVL88:
 839              		ldmfd	sp!, {r4, pc}
 840              	.LFE25:
 842              		.section	.rodata
 843              		.align	2
 844 04c0 E1A04000 	.LC0:
   8:../lib/uart.c **** 	char ch;
   9:../lib/uart.c **** 
  10:../lib/uart.c **** 	while ((ch = *string)){
 845              		"\000\000"
 846 04c4 E5D00000 		.text
 847              		.align	2
 848 04c8 E3500000 		.global	uart0_scanf
 850 04d0 EA000005 	uart0_scanf:
 851              	.LFB26:
 852              		.loc 2 22 0
 853 04d4 E5F40001 		@ args = 0, pretend = 0, frame = 0
 854              		@ frame_needed = 0, uses_anonymous_args = 0
 855 04d8 E3500000 	.LVL89:
 856 04dc 0A000002 		stmfd	sp!, {r4, r5, r6, lr}
 857              	.LCFI3:
  11:../lib/uart.c **** 		if (io_uart0_send_byte(ch)<=0)
 858              		subs	r4, r1, #0
 859 04e0 EBFFFFFE 		.loc 2 22 0
 860              		mov	r5, r0
 861 04e4 E3500000 		and	r6, r2, #255
 862 04e8 CAFFFFF9 		.loc 2 25 0
 863              		ble	.L148
 864              	.LVL90:
  12:../lib/uart.c **** 			break;
  13:../lib/uart.c **** 		string++;
  14:../lib/uart.c **** 	}
  15:../lib/uart.c **** 	return string;
  16:../lib/uart.c **** }
 865              		.loc 2 26 0
 866 04ec E1A00004 		bl	io_uart0_read_byte
 867              	.LVL91:
 868 04f0 E8BD8010 	.LVL92:
 869              		.loc 2 27 0
 870              		cmn	r0, #1
 871              		.loc 2 28 0
 872              		and	r3, r0, #255
 873              	.LVL93:
 874 0000 0000     		.loc 2 27 0
 875 0002 0000     		beq	.L150
 876              		.loc 2 30 0
 877              		cmp	r6, #1
 878              	.LVL94:
 879              		.loc 2 29 0
 880              		strb	r3, [r5, #0]
  17:../lib/uart.c **** 
  18:../lib/uart.c **** // ############################################################################################
  19:../lib/uart.c **** // Read text string via UART 0
  20:../lib/uart.c ****    void uart0_scanf(unsigned char *buffer, int length, unsigned char en_echo)
  21:../lib/uart.c **** // ############################################################################################
  22:../lib/uart.c **** {
 881              	31 0
 882              		mov	r0, r3
 883              	.LVL96:
 884              		.loc 2 29 0
 885 04f4 E92D4070 		add	r5, r5, #1
 886              		.loc 2 30 0
  23:../lib/uart.c **** 	int temp = 0;
  24:../lib/uart.c **** 
  25:../lib/uart.c **** 	while(length > 0){
 887              	L157
 888 04f8 E2514000 	.LVL97:
 889              	.L152:
 890 04fc E1A05000 		.loc 2 32 0
 891 0500 E20260FF 		sub	r4, r4, #1
 892              	.LVL98:
 893 0504 DA00000B 	.L150:
 894              		.loc 2 25 0
 895              		cmp	r4, #0
  26:../lib/uart.c **** 		temp = io_uart0_read_byte();
 896              	5
 897 0508 EBFFFFFE 	.LVL99:
 898              	.L148:
 899              		.loc 2 35 0
  27:../lib/uart.c **** 		if(temp != -1){
 900              		r3, .L158
 901 050c E3700001 	.LVL100:
  28:../lib/uart.c **** 			temp = (unsigned char)(temp & 0x000000FF);
 902              	trb	r3, [r5, #0]
 903 0510 E20030FF 		.loc 2 36 0
 904              		ldmfd	sp!, {r4, r5, r6, pc}
 905              	.LVL101:
 906 0514 0A000005 	.L157:
  29:../lib/uart.c **** 			*buffer++ = temp;
  30:../lib/uart.c **** 			if(en_echo == 1)
 907              	 2 31 0
 908 0518 E3560001 		bl	io_uart0_send_byte
 909              	.LVL102:
 910              		b	.L152
 911 051c E5C53000 	.L159:
 912              		.align	2
  31:../lib/uart.c **** 				io_uart0_send_byte(temp); // echo
 913              	
 914 0520 E1A00003 		.word	.LC0
 915              	.LFE26:
 917 0524 E2855001 		.align	2
 918              		.global	uart0_print_buffer
 920              	uart0_print_buffer:
 921              	.LFB27:
  32:../lib/uart.c **** 			length--;
 922              	42 0
 923 052c E2444001 		@ args = 0, pretend = 0, frame = 0
 924              		@ frame_needed = 0, uses_anonymous_args = 0
 925              	.LVL103:
 926              		stmfd	sp!, {r4, r5, lr}
 927 0530 E3540000 	.LCFI4:
 928 0534 CAFFFFF3 		.loc 2 44 0
 929              		subs	r4, r1, #0
 930              		.loc 2 42 0
  33:../lib/uart.c **** 		}
  34:../lib/uart.c **** 	}
  35:../lib/uart.c **** 	*buffer="\0";
 931              	r0
 932 0538 E59F300C 		.loc 2 44 0
 933              		ldmlefd	sp!, {r4, r5, pc}
 934 053c E5C53000 	.LVL104:
  36:../lib/uart.c **** }
 935              	4:
 936 0540 E8BD8070 		.loc 2 46 0
 937              		ldrb	r0, [r5], #1	@ zero_extendqisi2
 938              	.LVL105:
 939              		bl	io_uart0_send_byte
 940 0544 EBFFFFFE 	.LVL106:
 941              		.loc 2 44 0
 942 0548 EAFFFFF7 		subs	r4, r4, #1
 943              		bne	.L164
 944              		ldmfd	sp!, {r4, r5, pc}
 945              	.LFE27:
 947              		.align	2
 948              		.global	memTestDataBus
 950              	memTestDataBus:
 951              	.LFB28:
 952              		.file 3 "memtest.c"
 953              		.loc 3 38 0
  37:../lib/uart.c **** 
  38:../lib/uart.c **** // ############################################################################################
  39:../lib/uart.c **** // Print character buffer via UART 0
  40:../lib/uart.c ****    void uart0_print_buffer(unsigned char *buffer, int size)
  41:../lib/uart.c **** // ############################################################################################
  42:../lib/uart.c **** {
 954              	d = 0, frame = 0
 955              		@ frame_needed = 0, uses_anonymous_args = 0
 956              		@ link register save eliminated.
 957              	.LVL107:
 958 0550 E92D4030 		mov	r2, r0
 959              		@ lr needed for prologue
  43:../lib/uart.c **** 	unsigned char char_buffer = 0;
  44:../lib/uart.c **** 	while(size > 0){
 960              	3 38 0
 961 0554 E2514000 		mov	r0, #1
 962              	.LVL108:
 963 0558 E1A05000 	.L167:
 964              		.loc 3 50 0
 965 055c D8BD8030 		str	r0, [r2, #0]
 966              		.loc 3 55 0
 967              		ldr	r3, [r2, #0]
  45:../lib/uart.c **** 		char_buffer = *buffer++;
  46:../lib/uart.c **** 		io_uart0_send_byte((int)char_buffer);
 968              	 r0
 969 0560 E4D50001 		bxne	lr
 970              		.loc 3 45 0
 971 0564 EBFFFFFE 		movs	r0, r0, asl #1
 972              		bne	.L167
 973              	.LVL109:
 974 0568 E2544001 		.loc 3 63 0
 975 056c 1AFFFFFB 		bx	lr
 976 0570 E8BD8030 	.LFE28:
 978              		.align	2
 979              		.global	memTestAddressBus
 981              	memTestAddressBus:
 982              	.LFB29:
 983              		.loc 3 93 0
 984              		@ args = 0, pretend = 0, frame = 0
   1:memtest.c     **** /**********************************************************************
   2:memtest.c     ****  *
   3:memtest.c     ****  * Filename:    memtest.c
   4:memtest.c     ****  * 
   5:memtest.c     ****  * Description: General-purpose memory testing functions.
   6:memtest.c     ****  *
   7:memtest.c     ****  * Notes:       This software can be easily ported to systems with
   8:memtest.c     ****  *              different data bus widths by redefining 'datum'.
   9:memtest.c     ****  *
  10:memtest.c     ****  * 
  11:memtest.c     ****  * Copyright (c) 1998 by Michael Barr.  This software is placed into
  12:memtest.c     ****  * the public domain and may be used for any purpose.  However, this
  13:memtest.c     ****  * notice must not be changed or removed and no warranty is either
  14:memtest.c     ****  * expressed or implied by its publication or distribution.
  15:memtest.c     ****  **********************************************************************/
  16:memtest.c     **** 
  17:memtest.c     **** 
  18:memtest.c     **** #include "memtest.h"
  19:memtest.c     **** 
  20:memtest.c     **** 
  21:memtest.c     **** /**********************************************************************
  22:memtest.c     ****  *
  23:memtest.c     ****  * Function:    memTestDataBus()
  24:memtest.c     ****  *
  25:memtest.c     ****  * Description: Test the data bus wiring in a memory region by
  26:memtest.c     ****  *              performing a walking 1's test at a fixed address
  27:memtest.c     ****  *              within that region.  The address (and hence the
  28:memtest.c     ****  *              memory region) is selected by the caller.
  29:memtest.c     ****  *
  30:memtest.c     ****  * Notes:       
  31:memtest.c     ****  *
  32:memtest.c     ****  * Returns:     0 if the test succeeds.  
  33:memtest.c     ****  *              A non-zero result is the first pattern that failed.
  34:memtest.c     ****  *
  35:memtest.c     ****  **********************************************************************/
  36:memtest.c     **** datum
  37:memtest.c     **** memTestDataBus(volatile datum * address)
  38:memtest.c     **** {
 985              	 0, uses_anonymous_args = 0
 986              	.LVL110:
 987              		.loc 3 94 0
 988              		mov	r1, r1, lsr #2
 989              	.LVL111:
 990 0574 E1A02000 		.loc 3 93 0
 991              		stmfd	sp!, {r4, r5, r6, lr}
 992              	.LCFI5:
 993 0578 E3A00001 		.loc 3 94 0
 994              		sub	lr, r1, #1
 995              	.LVL112:
  39:memtest.c     ****     datum pattern;
  40:memtest.c     **** 
  41:memtest.c     **** 
  42:memtest.c     ****     /*
  43:memtest.c     ****      * Perform a walking 1's test at the given address.
  44:memtest.c     ****      */
  45:memtest.c     ****     for (pattern = 1; pattern != 0; pattern <<= 1)
  46:memtest.c     ****     {
  47:memtest.c     ****         /*
  48:memtest.c     ****          * Write the test pattern.
  49:memtest.c     ****          */
  50:memtest.c     ****         *address = pattern;
 996              	 0
 997 057c E5820000 		ands	r1, lr, #1
  51:memtest.c     **** 
  52:memtest.c     ****         /*
  53:memtest.c     ****          * Read it back (immediately is okay for this test).
  54:memtest.c     ****          */
  55:memtest.c     ****         if (*address != pattern) 
 998              	loc 3 93 0
 999 0580 E5923000 		mov	r6, r2
 1000 0584 E1530000 		.loc 3 105 0
 1001 0588 112FFF1E 		beq	.L173
 1002              	.LVL113:
 1003 058c E1B00080 		mov	r1, #43520
 1004 0590 1AFFFFF9 		add	r1, r1, #170
 1005              		orr	r1, r1, r1, asl #16
  56:memtest.c     ****         {
  57:memtest.c     ****             return (pattern);
  58:memtest.c     ****         }
  59:memtest.c     ****     }
  60:memtest.c     **** 
  61:memtest.c     ****     return (0);
  62:memtest.c     **** 
  63:memtest.c     **** }   /* memTestDataBus() */
 1006              	 #1
 1007 0594 E12FFF1E 	.LVL114:
 1008              	.L175:
 1009              		.loc 3 107 0
 1010              		mov	r3, r2, asl #2
 1011              		.loc 3 105 0
 1012              		mov	r2, r2, asl #1
 1013              		tst	lr, r2
 1014              		.loc 3 107 0
  64:memtest.c     **** 
  65:memtest.c     **** 
  66:memtest.c     **** /**********************************************************************
  67:memtest.c     ****  *
  68:memtest.c     ****  * Function:    memTestAddressBus()
  69:memtest.c     ****  *
  70:memtest.c     ****  * Description: Test the address bus wiring in a memory region by
  71:memtest.c     ****  *              performing a walking 1's test on the relevant bits
  72:memtest.c     ****  *              of the address and checking for aliasing. This test
  73:memtest.c     ****  *              will find single-bit address failures such as stuck
  74:memtest.c     ****  *              -high, stuck-low, and shorted pins.  The base address
  75:memtest.c     ****  *              and size of the region are selected by the caller.
  76:memtest.c     ****  *
  77:memtest.c     ****  * Notes:       For best results, the selected base address should
  78:memtest.c     ****  *              have enough LSB 0's to guarantee single address bit
  79:memtest.c     ****  *              changes.  For example, to test a 64-Kbyte region, 
  80:memtest.c     ****  *              select a base address on a 64-Kbyte boundary.  Also, 
  81:memtest.c     ****  *              select the region size as a power-of-two--if at all 
  82:memtest.c     ****  *              possible.
  83:memtest.c     ****  *
  84:memtest.c     ****  * Returns:     NULL if the test succeeds.  
  85:memtest.c     ****  *              A non-zero result is the first address at which an
  86:memtest.c     ****  *              aliasing problem was uncovered.  By examining the
  87:memtest.c     ****  *              contents of memory, it may be possible to gather
  88:memtest.c     ****  *              additional information about the problem.
  89:memtest.c     ****  *
  90:memtest.c     ****  **********************************************************************/
  91:memtest.c     **** datum * 
  92:memtest.c     **** memTestAddressBus(volatile datum * baseAddress, unsigned long nBytes, int *Step)
  93:memtest.c     **** {
 1015              	[r0, r3]
 1016              		.loc 3 105 0
 1017              		bne	.L175
 1018              		.loc 3 114 0
  94:memtest.c     ****     unsigned long addressMask = (nBytes/sizeof(datum) - 1);
 1019              		r3, #21760
 1020 0598 E1A01121 		add	r3, r3, #85
 1021              		mov	r5, r0
 1022              		orr	r3, r3, r3, asl #16
 1023 059c E92D4070 		str	r3, [r5], #4
 1024              		.loc 3 118 0
 1025              		ldr	r2, [r0, #4]
 1026 05a0 E241E001 	.LVL115:
 1027              		cmp	r2, r1
  95:memtest.c     ****     unsigned long offset;
  96:memtest.c     ****     unsigned long testOffset;
  97:memtest.c     **** 
  98:memtest.c     ****     datum pattern     = (datum) 0xAAAAAAAA;
  99:memtest.c     ****     datum antipattern = (datum) 0x55555555;
 100:memtest.c     **** 
 101:memtest.c     **** 
 102:memtest.c     ****     /*
 103:memtest.c     ****      * Write the default pattern at each of the power-of-two offsets.
 104:memtest.c     ****      */
 105:memtest.c     ****     for (offset = 1; (offset & addressMask) != 0; offset <<= 1)
 1028              	, r5
 1029 05a4 E21E1001 		bne	.L179
 1030              		.loc 3 121 0
 1031 05a8 E1A06002 		mov	r1, #1
 1032              	.LVL116:
 1033 05ac 0A000052 		b	.L181
 1034              	.L180:
 1035 05b0 E3A01CAA 		.loc 3 118 0
 1036 05b4 E28110AA 		ldr	r3, [r0, r3]
 1037 05b8 E1811801 		cmp	r3, r2
 1038 05bc E3A02001 		bne	.L179
 1039              	.L181:
 1040              		.loc 3 116 0
 106:memtest.c     ****     {
 107:memtest.c     ****         baseAddress[offset] = pattern;
 1041              	asl #1
 1042 05c0 E1A03102 		.loc 3 118 0
 1043              		mov	r2, #43520
 1044 05c4 E1A02082 		add	r2, r2, #170
 1045 05c8 E11E0002 		mov	r3, r1, asl #2
 1046              		.loc 3 116 0
 1047 05cc E7801003 		tst	lr, r1
 1048              		.loc 3 118 0
 1049 05d0 1AFFFFFA 		orr	r2, r2, r2, asl #16
 108:memtest.c     ****     }
 109:memtest.c     **** 
 110:memtest.c     ****     /* 
 111:memtest.c     ****      * Check for address bits stuck high.
 112:memtest.c     ****      */
 113:memtest.c     ****     testOffset = 0;
 114:memtest.c     ****     baseAddress[testOffset] = antipattern;
 1050              	r0, r3
 1051 05d4 E3A03C55 		.loc 3 116 0
 1052 05d8 E2833055 		bne	.L180
 1053 05dc E1A05000 		.loc 3 126 0
 1054 05e0 E1833803 		mov	r3, #43520
 1055 05e4 E4853004 		.loc 3 133 0
 115:memtest.c     **** 
 116:memtest.c     ****     for (offset = 1; (offset & addressMask) != 0; offset <<= 1)
 117:memtest.c     ****     {
 118:memtest.c     ****         if (baseAddress[offset] != pattern)
 1056              	2, #21760
 1057 05e8 E5902004 		.loc 3 126 0
 1058              		add	r3, r3, #170
 1059 05ec E1520001 		.loc 3 133 0
 1060 05f0 11A0C005 		add	r2, r2, #85
 1061 05f4 1A000036 		.loc 3 126 0
 119:memtest.c     ****         {
 120:memtest.c     ****             *Step = 1;
 121:memtest.c     **** 			return ((datum *) &baseAddress[offset]);
 1062              	3, r3, r3, asl #16
 1063 05f8 E3A01001 		.loc 3 133 0
 1064              		orr	r2, r2, r2, asl #16
 1065 05fc EA000002 		.loc 3 126 0
 1066              		str	r3, [r0, #0]
 1067              		.loc 3 133 0
 1068 0600 E7903003 		str	r2, [r5, #0]
 1069 0604 E1530002 		.loc 3 135 0
 1070 0608 1A000031 		ldr	r1, [r0, #0]
 1071              	.LVL117:
 1072              		cmp	r1, r3
 1073 060c E1A01081 		moveq	r4, #1
 1074              	.LVL118:
 1075 0610 E3A02CAA 		bne	.L185
 1076 0614 E28220AA 	.L186:
 1077 0618 E1A03101 		mov	r1, #1
 1078              	.LVL119:
 1079 061c E11E0001 	.L187:
 1080              		.loc 3 143 0
 1081 0620 E1822802 		mov	r3, r1, asl #2
 1082 0624 E080C003 		mov	ip, #43520
 1083              		ldr	r2, [r0, r3]
 1084 0628 1AFFFFF4 		add	ip, ip, #170
 122:memtest.c     **** 			
 123:memtest.c     ****         }
 124:memtest.c     ****     }
 125:memtest.c     **** 
 126:memtest.c     ****     baseAddress[testOffset] = pattern;
 1085              	6
 1086 062c E3A03CAA 		cmp	r2, ip
 127:memtest.c     **** 
 128:memtest.c     ****     /*
 129:memtest.c     ****      * Check for address bits stuck low or shorted.
 130:memtest.c     ****      */
 131:memtest.c     ****     for (testOffset = 1; (testOffset & addressMask) != 0; testOffset <<= 1)
 132:memtest.c     ****     {
 133:memtest.c     ****         baseAddress[testOffset] = antipattern;
 1087              	eq	.L188
 1088 0630 E3A02C55 		cmp	r1, r4
 1089              		bne	.L195
 1090 0634 E28330AA 	.L188:
 1091              		.loc 3 141 0
 1092 0638 E2822055 		mov	r1, r1, asl #1
 1093              		tst	lr, r1
 1094 063c E1833803 		bne	.L187
 1095              		.loc 3 131 0
 1096 0640 E1822802 		mov	r4, r4, asl #1
 1097              		ands	r2, lr, r4
 1098 0644 E5803000 		.loc 3 150 0
 1099              		str	ip, [r5, #0]
 1100 0648 E5852000 		.loc 3 131 0
 134:memtest.c     **** 
 135:memtest.c     **** 		if (baseAddress[0] != pattern)
 1101              	oc 3 133 0
 1102 064c E5901000 		mov	r3, #21760
 1103              		add	r3, r3, #85
 1104 0650 E1510003 		mov	r1, r4, asl #2
 1105 0654 03A04001 	.LVL120:
 1106              		orr	r3, r3, r3, asl #16
 1107 0658 1A000019 		str	r3, [r0, r1]
 1108              		.loc 3 135 0
 1109 065c E3A01001 		ldr	r2, [r0, #0]
 1110              		cmp	r2, ip
 1111              		.loc 3 133 0
 136:memtest.c     **** 		{
 137:memtest.c     ****             *Step = 2;
 138:memtest.c     **** 			return ((datum *) &baseAddress[testOffset]);
 139:memtest.c     **** 		}
 140:memtest.c     **** 
 141:memtest.c     ****         for (offset = 1; (offset & addressMask) != 0; offset <<= 1)
 142:memtest.c     ****         {
 143:memtest.c     ****             if ((baseAddress[offset] != pattern) && (offset != testOffset))
 1112              	, r1
 1113 0660 E1A03101 		.loc 3 135 0
 1114 0664 E3A0CCAA 		beq	.L186
 1115 0668 E7902003 	.L185:
 1116 066c E28CC0AA 		.loc 3 137 0
 1117 0670 E18CC80C 		mov	r3, #2
 1118 0674 E152000C 		.loc 3 138 0
 1119 0678 0A000001 		mov	r1, r5
 1120 067c E1510004 		.loc 3 137 0
 1121 0680 1A000018 		str	r3, [r6, #0]
 1122              		b	.L182
 1123              	.LVL121:
 1124 0684 E1A01081 	.L179:
 1125 0688 E11E0001 		.loc 3 120 0
 1126 068c 1AFFFFF3 		mov	r3, #1
 1127              		str	r3, [r6, #0]
 1128 0690 E1A04084 		.loc 3 121 0
 1129 0694 E01E2004 		mov	r1, ip
 144:memtest.c     ****             {
 145:memtest.c     **** 				*Step = 3;
 146:memtest.c     ****                return ((datum *) &baseAddress[testOffset]);
 147:memtest.c     ****             }
 148:memtest.c     ****         }
 149:memtest.c     **** 
 150:memtest.c     ****         baseAddress[testOffset] = pattern;
 1130              	.L182:
 1131 0698 E585C000 		.loc 3 155 0
 1132              		mov	r0, r1
 1133 069c 0A000020 	.LVL124:
 1134              		ldmfd	sp!, {r4, r5, r6, pc}
 1135 06a0 E3A03C55 	.LVL125:
 1136 06a4 E2833055 	.L195:
 1137 06a8 E1A01104 		.loc 3 146 0
 1138              		mov	r1, r5
 1139 06ac E1833803 	.LVL126:
 1140 06b0 E7803001 		.loc 3 145 0
 1141              		mov	r3, #3
 1142 06b4 E5902000 		.loc 3 155 0
 1143 06b8 E152000C 		mov	r0, r1
 1144              	.LVL127:
 1145 06bc E0805001 		.loc 3 145 0
 1146              		str	r3, [r6, #0]
 1147 06c0 0AFFFFE5 		.loc 3 155 0
 1148              		ldmfd	sp!, {r4, r5, r6, pc}
 1149              	.LVL128:
 1150 06c4 E3A03002 	.L173:
 1151              		.loc 3 114 0
 1152 06c8 E1A01005 		mov	r3, #21760
 1153              		.loc 3 126 0
 1154 06cc E5863000 		mov	r2, #43520
 1155 06d0 EA000002 		.loc 3 114 0
 1156              		add	r3, r3, #85
 1157              		.loc 3 126 0
 1158              		add	r2, r2, #170
 1159 06d4 E3A03001 		.loc 3 114 0
 1160 06d8 E5863000 		orr	r3, r3, r3, asl #16
 1161              		.loc 3 126 0
 1162 06dc E1A0100C 		orr	r2, r2, r2, asl #16
 1163              		.loc 3 114 0
 1164              		str	r3, [r0, #0]
 1165              		.loc 3 126 0
 151:memtest.c     ****     }
 152:memtest.c     **** 
 153:memtest.c     ****     return (NULL);
 154:memtest.c     **** 
 155:memtest.c     **** }   /* memTestAddressBus() */
 1166              		r0, r1
 1167 06e0 E1A00001 	.LVL129:
 1168              		ldmfd	sp!, {r4, r5, r6, pc}
 1169 06e4 E8BD8070 	.LVL130:
 1170              	.L202:
 1171              		.loc 3 131 0
 1172              		mov	r1, r2
 1173 06e8 E1A01005 	.LVL131:
 1174              		b	.L182
 1175              	.LFE29:
 1177              		.align	2
 1178 06f0 E1A00001 		.global	memTestDevice1
 1180              	memTestDevice1:
 1181 06f4 E5863000 	.LFB30:
 1182              		.loc 3 181 0
 1183 06f8 E8BD8070 		@ args = 0, pretend = 0, frame = 0
 1184              		@ frame_needed = 0, uses_anonymous_args = 0
 1185              		@ link register save eliminated.
 1186              	.LVL132:
 1187 06fc E3A03C55 		.loc 3 192 0
 1188              		movs	r1, r1, lsr #2
 1189 0700 E3A02CAA 	.LVL133:
 1190              		.loc 3 181 0
 1191 0704 E2833055 		@ lr needed for prologue
 1192              		.loc 3 192 0
 1193 0708 E28220AA 		beq	.L204
 1194              		mov	r3, #1
 1195 070c E1833803 	.LVL134:
 1196              		mov	r2, r0
 1197 0710 E1822802 	.LVL135:
 1198              		add	ip, r1, r3
 1199 0714 E5803000 	.L206:
 1200              	.LVL136:
 1201 0718 E5802000 		.loc 3 194 0
 1202              		str	r3, [r2], #4
 1203 071c E1A00001 		.loc 3 192 0
 1204              		add	r3, r3, #1
 1205 0720 E8BD8070 		cmp	ip, r3
 1206              		bne	.L206
 1207              		.loc 3 202 0
 1208              		ldr	r3, [r0, #0]
 1209 0724 E1A01002 	.LVL137:
 1210              		cmp	r3, #1
 1211 0728 EAFFFFEC 		bxne	lr
 1212              		.loc 3 204 0
 1213              		add	r2, r0, #4
 1214              		mov	ip, r3
 1215              	.LVL138:
 1216              		b	.L211
 1217              	.L210:
 1218              		.loc 3 202 0
 156:memtest.c     **** 
 157:memtest.c     **** 
 158:memtest.c     **** /**********************************************************************
 159:memtest.c     ****  *
 160:memtest.c     ****  * Function:    memTestDevice()
 161:memtest.c     ****  *
 162:memtest.c     ****  * Description: Test the integrity of a physical memory device by
 163:memtest.c     ****  *              performing an increment/decrement test over the
 164:memtest.c     ****  *              entire region.  In the process every storage bit 
 165:memtest.c     ****  *              in the device is tested as a zero and a one.  The
 166:memtest.c     ****  *              base address and the size of the region are
 167:memtest.c     ****  *              selected by the caller.
 168:memtest.c     ****  *
 169:memtest.c     ****  * Notes:       
 170:memtest.c     ****  *
 171:memtest.c     ****  * Returns:     NULL if the test succeeds.
 172:memtest.c     ****  *
 173:memtest.c     ****  *              A non-zero result is the first address at which an
 174:memtest.c     ****  *              incorrect value was read back.  By examining the
 175:memtest.c     ****  *              contents of memory, it may be possible to gather
 176:memtest.c     ****  *              additional information about the problem.
 177:memtest.c     ****  *
 178:memtest.c     ****  **********************************************************************/
 179:memtest.c     **** datum * 
 180:memtest.c     **** memTestDevice1(volatile datum * baseAddress, unsigned long nBytes)	
 181:memtest.c     **** {
 1219              	 3 200 0
 1220              		cmp	r1, ip
 1221              		mov	r0, r2
 1222              		add	ip, ip, #1
 1223              		bne	.L210
 182:memtest.c     ****     unsigned long offset;
 183:memtest.c     ****     unsigned long nWords = nBytes / sizeof(datum);
 184:memtest.c     **** 
 185:memtest.c     ****     datum pattern;
 186:memtest.c     ****     datum antipattern;
 187:memtest.c     **** 
 188:memtest.c     **** 
 189:memtest.c     ****     /*
 190:memtest.c     ****      * Fill memory with a known pattern.
 191:memtest.c     ****      */
 192:memtest.c     ****     for (pattern = 1, offset = 0; offset < nWords; pattern++, offset++)
 1224              	:
 1225 072c E1B01121 		mov	r0, #0
 1226              	.LVL139:
 1227              		.loc 3 210 0
 1228              		bx	lr
 1229              	.LVL140:
 1230 0730 0A000013 	.L218:
 1231 0734 E3A03001 		bx	lr
 1232              	.LFE30:
 1234              		.align	2
 1235 073c E081C003 		.global	memTestDevice2
 1237              	memTestDevice2:
 193:memtest.c     ****     {
 194:memtest.c     ****         baseAddress[offset] = pattern;
 1238              	3 213 0
 1239 0740 E4823004 		@ args = 0, pretend = 0, frame = 0
 1240              		@ frame_needed = 0, uses_anonymous_args = 0
 1241 0744 E2833001 	.LVL141:
 1242 0748 E15C0003 		.loc 3 223 0
 1243 074c 1AFFFFFB 		movs	r1, r1, lsr #2
 195:memtest.c     ****     }
 196:memtest.c     **** 
 197:memtest.c     ****     /*
 198:memtest.c     ****      * Check each location and invert it for the second pass.
 199:memtest.c     ****      */
 200:memtest.c     ****     for (pattern = 1, offset = 0; offset < nWords; pattern++, offset++)
 201:memtest.c     ****     {
 202:memtest.c     ****         if (baseAddress[offset] != pattern)
 1244              	2:
 1245 0750 E5903000 		.loc 3 213 0
 1246              		str	lr, [sp, #-4]!
 1247 0754 E3530001 	.LCFI6:
 1248 0758 112FFF1E 		.loc 3 223 0
 203:memtest.c     ****         {
 204:memtest.c     ****             return ((datum *) &baseAddress[offset]);
 1249              	.L220
 1250 075c E2802004 		mov	r2, #1
 1251 0760 E1A0C003 	.LVL143:
 1252              		mov	ip, r0
 1253 0764 EA000002 	.LVL144:
 1254              		add	lr, r1, r2
 1255              	.L222:
 1256 0768 E4923004 	.LVL145:
 1257 076c E153000C 		.loc 3 225 0
 1258 0770 1A000005 		mvn	r3, r2
 1259              	.LVL146:
 1260              		.loc 3 223 0
 1261 0774 E151000C 		add	r2, r2, #1
 1262 0778 E1A00002 		cmp	lr, r2
 1263 077c E28CC001 		.loc 3 226 0
 1264 0780 1AFFFFF8 		str	r3, [ip], #4
 1265              		.loc 3 223 0
 1266 0784 E3A00000 		bne	.L222
 1267              		.loc 3 235 0
 205:memtest.c     ****         }
 206:memtest.c     ****  
 207:memtest.c     ****     }
 208:memtest.c     ****     return (NULL);
 209:memtest.c     **** 
 210:memtest.c     **** }   /* memTestDevice1() */
 1268              	LVL147:
 1269 0788 E12FFF1E 		cmn	r3, #2
 1270              		ldrne	pc, [sp], #4
 1271              		.loc 3 237 0
 1272 078c E12FFF1E 		add	r2, r0, #4
 1273              	.LVL148:
 1274              		mov	lr, #1
 1275              	.LVL149:
 1276              		b	.L227
 1277              	.L226:
 1278              		.loc 3 235 0
 1279              		ldr	r3, [r2], #4
 211:memtest.c     **** datum * 
 212:memtest.c     **** memTestDevice2(volatile datum * baseAddress, unsigned long nBytes)	
 213:memtest.c     **** {
 1280              		bne	.L234
 1281              	.L227:
 1282              		.loc 3 232 0
 1283              		cmp	r1, lr
 214:memtest.c     ****     unsigned long offset;
 215:memtest.c     ****     unsigned long nWords = nBytes / sizeof(datum);
 216:memtest.c     **** 
 217:memtest.c     ****     datum pattern;
 218:memtest.c     ****     datum antipattern;
 219:memtest.c     **** 
 220:memtest.c     ****     /*
 221:memtest.c     ****      * Check each location and invert it for the second pass.
 222:memtest.c     ****      */
 223:memtest.c     ****     for (pattern = 1, offset = 0; offset < nWords; pattern++, offset++)
 1284              		lr, lr, #1
 1285 0790 E1B01121 		mov	r0, r2
 1286              		.loc 3 235 0
 1287              		mvn	ip, lr
 1288 0794 E52DE004 		.loc 3 232 0
 1289              		bne	.L226
 1290              	.L220:
 1291 0798 0A000015 		mov	r0, #0
 1292 079c E3A02001 	.LVL150:
 1293              		.loc 3 243 0
 1294 07a0 E1A0C000 		ldr	pc, [sp], #4
 1295              	.LVL151:
 1296 07a4 E081E002 	.L234:
 1297              		ldr	pc, [sp], #4
 1298              	.LFE31:
 224:memtest.c     ****     {
 225:memtest.c     ****         antipattern = ~pattern;
 1299              	evice2, .-memTestDevice2
 1300 07a8 E1E03002 		.align	2
 1301              		.global	long_to_hex_string
 1303 07ac E2822001 	long_to_hex_string:
 1304 07b0 E15E0002 	.LFB33:
 226:memtest.c     ****         baseAddress[offset] = antipattern;
 1305              	 4 "main.c"
 1306 07b4 E48C3004 		.loc 4 41 0
 1307              		@ args = 0, pretend = 0, frame = 0
 1308 07b8 1AFFFFFA 		@ frame_needed = 0, uses_anonymous_args = 0
 227:memtest.c     ****     }
 228:memtest.c     **** 
 229:memtest.c     ****     /*
 230:memtest.c     ****      * Check each location for the inverted pattern and zero it.
 231:memtest.c     ****      */
 232:memtest.c     ****     for (pattern = 1, offset = 0; offset < nWords; pattern++, offset++)
 233:memtest.c     ****     {
 234:memtest.c     ****         antipattern = ~pattern;
 235:memtest.c     ****         if (baseAddress[offset] != antipattern)
 1309              	152:
 1310 07bc E5903000 		stmfd	sp!, {r4, lr}
 1311              	.LCFI7:
 1312 07c0 E3730002 		.loc 4 41 0
 1313 07c4 149DF004 		and	r4, r2, #255
 236:memtest.c     ****         {
 237:memtest.c     ****             return ((datum *) &baseAddress[offset]);
 1314              	 4 46 0
 1315 07c8 E2802004 		cmp	r4, #8
 1316              		movhi	r4, #8
 1317 07cc E3A0E001 		bhi	.L238
 1318              	.LVL153:
 1319 07d0 EA000002 		.loc 4 48 0
 1320              		cmp	r4, #0
 1321              		.loc 4 71 0
 1322 07d4 E4923004 		moveq	r4, #1
 1323 07d8 E15C0003 	.L238:
 1324 07dc 1A000006 		mov	r2, r1
 1325              	.LVL154:
 1326              		mov	lr, r4
 1327 07e0 E151000E 	.LVL155:
 1328 07e4 E28EE001 	.L240:
 1329 07e8 E1A00002 		.loc 4 54 0
 1330              		mov	r3, lr, asl #2
 1331 07ec E1E0C00E 		.loc 4 53 0
 1332              		cmp	lr, #1
 1333 07f0 1AFFFFF7 		.loc 4 54 0
 1334              		sub	r3, r3, #4
 1335 07f4 E3A00000 		.loc 4 53 0
 1336              		mov	ip, r0
 238:memtest.c     ****         }
 239:memtest.c     ****     }
 240:memtest.c     **** 
 241:memtest.c     ****     return (NULL);
 242:memtest.c     **** 
 243:memtest.c     **** }   /* memTestDevice2() */
 1337              	movhi	ip, r0, lsr r3
 1338 07f8 E49DF004 		.loc 4 58 0
 1339              		sub	r3, lr, #1
 1340              		.loc 4 57 0
 1341 07fc E49DF004 		and	ip, ip, #15
 1342              	.LVL157:
 1343              		.loc 4 58 0
 1344              		and	lr, r3, #255
 1345              		.loc 4 61 0
 1346              		cmp	ip, #9
 1347              		.loc 4 62 0
 1348              		add	r3, ip, #48
 1349              	.LVL158:
   1:main.c        **** /**********************************************************************
   2:main.c        ****  *
   3:main.c        ****  * Function:    memTest()
   4:main.c        ****  *
   5:main.c        ****  * Description: Test a  chunk of SRAM.
   6:main.c        **** 				Set BASE_ADDRESS below to the starting address (in hex) of the memory
   7:main.c        **** 				Set NUM_BYTES below to the number to bytes (in dec) to test in memory 
   8:main.c        ****  *
   9:main.c        ****  * Notes:       
  10:main.c        ****  *
  11:main.c        ****  * Returns:     0 on success.
  12:main.c        ****  *              Otherwise -1 indicates failure.
  13:main.c        ****  *
  14:main.c        ****  **********************************************************************/
  15:main.c        **** #include "../lib/io_driver.h"
  16:main.c        **** #include "../lib/io_driver.c"
  17:main.c        **** #include "../lib/uart.h"
  18:main.c        **** #include "../lib/uart.c"
  19:main.c        **** #include "memtest.h"
  20:main.c        **** #include "memtest.c"
  21:main.c        **** #include "memtest_run.c"
  22:main.c        **** 
  23:main.c        **** 
  24:main.c        **** #define BASE_ADDRESS  (volatile datum *) 0x04000000 //beginning of SDRAM memory
  25:main.c        **** #define NUM_BYTES      32 * 1024 * 1024
  26:main.c        **** //#define NUM_BYTES     ( 32 * 1024 )
  27:main.c        **** 
  28:main.c        **** #define CYCLES	10
  29:main.c        **** 
  30:main.c        **** //#define CLEARMEM    //run clearing memory and write address to location
  31:main.c        **** #define MEMTESTRUN	//run memtest routines
  32:main.c        **** //#define MEMLOCWR    //repeatedly write single memory location 50x
  33:main.c        **** //#define MEMELOC	0x04000000	//location to write
  34:main.c        **** 
  35:main.c        **** // ############################################################################################
  36:main.c        **** // Convert 4/8/12/16/20/24/28/32 bit hexadecimal value to ASCII string
  37:main.c        ****    void long_to_hex_string(unsigned long data,    // max 32 bit data word
  38:main.c        ****                            unsigned char *buffer, // buffer to store the string
  39:main.c        **** 						   unsigned char numbers) // number of places, max 8
  40:main.c        **** // ############################################################################################
  41:main.c        **** {
 1350              		addhi	r3, ip, #55
 1351              		.loc 4 51 0
 1352              		cmp	lr, #0
 1353              		.loc 4 67 0
 1354 0800 E92D4010 		strb	r3, [r2], #1
 1355              		.loc 4 51 0
 1356              		bne	.L240
 1357 0804 E20240FF 		.loc 4 70 0
  42:main.c        **** 	unsigned char temp_char = 0;
  43:main.c        **** 	unsigned long temp_data = 0;
  44:main.c        **** 
  45:main.c        **** 	// fit into range
  46:main.c        **** 	if(numbers > 8)
 1358              	 r4, #1
 1359 0808 E3540008 	.LVL159:
 1360 080c 83A04008 		and	r3, r3, #255
 1361 0810 8A000001 		add	r3, r1, r3
 1362              		strb	lr, [r3, #1]
  47:main.c        **** 		numbers = 8;
  48:main.c        **** 	if(numbers < 1)
 1363              	 4 71 0
 1364 0814 E3540000 		ldmfd	sp!, {r4, pc}
  49:main.c        **** 		numbers = 1;
  50:main.c        **** 
  51:main.c        **** 	while(numbers > 0){
  52:main.c        **** 		// isolate one 4-bit value
  53:main.c        **** 		if(numbers > 1)
  54:main.c        **** 			temp_data = data >> ((numbers-1)*4);
  55:main.c        **** 		else
  56:main.c        **** 			temp_data = data;
  57:main.c        **** 		temp_data = temp_data & 0x0000000F;
  58:main.c        **** 		numbers--;
  59:main.c        **** 
  60:main.c        **** 		// convert 4-bit value temp_data to char temp_char
  61:main.c        **** 		if(temp_data < 10)
  62:main.c        **** 			temp_char = '0' + temp_data;
  63:main.c        **** 		else
  64:main.c        **** 			temp_char = 'A' + temp_data - 10;
  65:main.c        **** 
  66:main.c        **** 		// save character
  67:main.c        **** 		*buffer++ = temp_char;
  68:main.c        **** 	}
  69:main.c        **** 
  70:main.c        **** 	*buffer++ = 0; // terminate string
  71:main.c        **** }
 1365              	FE33:
 1367              		.section	.rodata.str1.4,"aMS",%progbits,1
 1368 081c E1A02001 		.align	2
 1369              	.LC1:
 1370 0820 E1A0E004 		.ascii	"memTestDataBus FAILED\015\012\000"
 1371              		.align	2
 1372              	.LC2:
 1373              		.ascii	"memTestDataBus Passed\015\012\000"
 1374 0824 E1A0310E 		.align	2
 1375              	.LC3:
 1376 0828 E35E0001 		.ascii	"memTestAddressBus FAILED \000"
 1377              		.align	2
 1378 082c E2433004 	.LC4:
 1379              		.ascii	"\015\012Step: \000"
 1380 0830 E1A0C000 		.align	2
 1381              	.LC5:
 1382              		.ascii	"\015\012\000"
 1383 0834 81A0C330 		.align	2
 1384              	.LC6:
 1385 0838 E24E3001 		.ascii	"memTestAddressBus Passed\015\012\000"
 1386              		.align	2
 1387 083c E20CC00F 	.LC7:
 1388              		.ascii	"memTestDevice1 FAILED \000"
 1389              		.align	2
 1390 0840 E203E0FF 	.LC8:
 1391              		.ascii	"memTestDevice1 Passed\015\012\000"
 1392 0844 E35C0009 		.align	2
 1393              	.LC9:
 1394 0848 E28C3030 		.ascii	"memTestDevice2 FAILED \000"
 1395              		.align	2
 1396              	.LC10:
 1397 084c 828C3037 		.ascii	"memTestDevice2 Passed\015\012\000"
 1398              		.align	2
 1399 0850 E35E0000 	.LC11:
 1400              		.ascii	"Mem test complete \015\012\000"
 1401 0854 E4C23001 		.text
 1402              		.align	2
 1403 0858 1AFFFFF1 		.global	memtest_run
 1405 085c E2443001 	memtest_run:
 1406              	.LFB32:
 1407 0860 E20330FF 		.file 5 "memtest_run.c"
 1408 0864 E0813003 		.loc 5 16 0
 1409 0868 E5C3E001 		@ args = 0, pretend = 0, frame = 16
 1410              		@ frame_needed = 0, uses_anonymous_args = 0
 1411 086c E8BD8010 		stmfd	sp!, {r4, r5, lr}
 1412              	.LCFI8:
 1413              		.loc 5 18 0
 1414              		ldr	r3, .L268
 1415              		ldrh	r3, [r3, #0]
 1416              		.loc 5 16 0
 1417 0000 6D656D54 		sub	sp, sp, #16
 1417      65737444 
 1417      61746142 
 1417      75732046 
 1417      41494C45 
 1418              	.LCFI9:
 1419              		.loc 5 18 0
 1420 0018 6D656D54 		strh	r3, [sp, #2]	@ movhi
 1420      65737444 
 1420      61746142 
 1420      75732050 
 1420      61737365 
 1421              		.loc 5 22 0
 1422              		mov	r0, #67108864
 1423 0030 6D656D54 		.loc 5 18 0
 1423      65737441 
 1423      64647265 
 1423      73734275 
 1423      73204641 
 1424 004a 0000     		mov	r3, #0	@ movhi
 1425              		strh	r3, [sp, #4]	@ movhi
 1426 004c 0D0A5374 		strh	r3, [sp, #6]	@ movhi
 1426      65703A20 
 1426      00
 1427 0055 000000   		strh	r3, [sp, #8]	@ movhi
 1428              		strh	r3, [sp, #10]	@ movhi
 1429 0058 0D0A00   		.loc 5 22 0
 1430 005b 00       		bl	memTestDataBus
 1431              		.loc 5 23 0
 1432 005c 6D656D54 		cmp	r0, #0
 1432      65737441 
 1432      64647265 
 1432      73734275 
 1432      73205061 
 1433 0077 00       		beq	.L252
 1434              		.loc 5 25 0
 1435 0078 6D656D54 		ldr	r0, .L268+4
 1435      65737444 
 1435      65766963 
 1435      65312046 
 1435      41494C45 
 1436 008f 00       		bl	uart0_printf
 1437              		.loc 5 36 0
 1438 0090 6D656D54 		mov	r0, #67108864
 1438      65737444 
 1438      65766963 
 1438      65312050 
 1438      61737365 
 1439              		mov	r1, #33554432
 1440              		add	r2, sp, #12
 1441 00a8 6D656D54 		bl	memTestAddressBus
 1441      65737444 
 1441      65766963 
 1441      65322046 
 1441      41494C45 
 1442 00bf 00       		.loc 5 37 0
 1443              		subs	r5, r0, #0
 1444 00c0 6D656D54 	.LVL160:
 1444      65737444 
 1444      65766963 
 1444      65322050 
 1444      61737365 
 1445              		beq	.L255
 1446              	.L265:
 1447 00d8 4D656D20 		.loc 5 40 0
 1447      74657374 
 1447      20636F6D 
 1447      706C6574 
 1447      65200D0A 
 1448              		add	r4, sp, #2
 1449              		.loc 5 39 0
 1450              		ldr	r0, .L268+8
 1451              		bl	uart0_printf
 1452              		.loc 5 40 0
 1453              		mov	r1, r4
 1454              		mov	r2, #8
   1:memtest_run.c **** // #include "../lib/io_driver.h"
   2:memtest_run.c **** // #include "../lib/io_driver.c"
   3:memtest_run.c **** // #include "../lib/uart.h"
   4:memtest_run.c **** // #include "../lib/uart.c"
   5:memtest_run.c **** //#include "memtest.h"
   6:memtest_run.c **** //#include "memtest.c"
   7:memtest_run.c **** 
   8:memtest_run.c **** #define BASE_ADDRESS  (volatile datum *) 0x04000000 //beginning of SDRAM memory
   9:memtest_run.c **** #define NUM_BYTES      32 * 1024 * 1024
  10:memtest_run.c **** 
  11:memtest_run.c **** #define DATABTEST
  12:memtest_run.c **** #define ADDRBTEST
  13:memtest_run.c **** #define DEVICETEST1
  14:memtest_run.c **** #define DEVICETEST2
  15:memtest_run.c **** 
  16:memtest_run.c **** void memtest_run () {
 1455              	8+12
 1456              		bl	uart0_printf
 1457              		.loc 5 42 0
 1458 0870 E92D4030 		mov	r1, r4
 1459              		mov	r2, #8
  17:memtest_run.c **** 	int Step, result = 0;
  18:memtest_run.c **** 	unsigned char str[10]="\0";
 1460              	61:
 1461 0874 E59F318C 		ldr	r0, [sp, #12]
 1462 0878 E1D330B0 		bl	long_to_hex_string
 1463              		.loc 5 43 0
 1464 087c E24DD010 		mov	r0, r4
 1465              		bl	uart0_printf
 1466              		ldr	r0, .L268+16
 1467 0880 E1CD30B2 		bl	uart0_printf
  19:memtest_run.c **** 	
  20:memtest_run.c **** 	datum *result_ptr=NULL;
  21:memtest_run.c **** #ifdef DATABTEST
  22:memtest_run.c **** 	result = memTestDataBus(BASE_ADDRESS);
 1468              	53 0
 1469 0884 E3A00301 		mov	r0, #67108864
 1470              		mov	r1, #33554432
 1471 0888 E3A03000 		bl	memTestDevice1
 1472 088c E1CD30B4 		.loc 5 54 0
 1473 0890 E1CD30B6 		subs	r5, r0, #0
 1474 0894 E1CD30B8 	.LVL162:
 1475 0898 E1CD30BA 		beq	.L258
 1476              	.L266:
 1477 089c EBFFFFFE 		.loc 5 57 0
  23:memtest_run.c ****     if ( result != 0)
 1478              	p, #2
 1479 08a0 E3500000 		.loc 5 56 0
 1480 08a4 0A00003E 		ldr	r0, .L268+20
  24:memtest_run.c ****     {
  25:memtest_run.c ****         uart0_printf("memTestDataBus FAILED\r\n");
 1481              		uart0_printf
 1482 08a8 E59F015C 		.loc 5 57 0
 1483 08ac EBFFFFFE 		mov	r1, r4
  26:memtest_run.c **** 		//return (-1);
  27:memtest_run.c ****     }
  28:memtest_run.c ****     else
  29:memtest_run.c ****     {
  30:memtest_run.c ****         uart0_printf("memTestDataBus Passed\r\n");
  31:memtest_run.c **** 
  32:memtest_run.c ****     }
  33:memtest_run.c **** #endif
  34:memtest_run.c **** 
  35:memtest_run.c **** #ifdef ADDRBTEST
  36:memtest_run.c **** 	result_ptr = memTestAddressBus(BASE_ADDRESS, NUM_BYTES, &Step);
 1484              	v	r2, #8
 1485 08b0 E3A00301 		mov	r0, r5
 1486 08b4 E3A01402 		bl	long_to_hex_string
 1487 08b8 E28D200C 		.loc 5 58 0
 1488 08bc EBFFFFFE 		mov	r0, r4
  37:memtest_run.c ****     if ( result_ptr != NULL)
 1489              	art0_printf
 1490 08c0 E2505000 		ldr	r0, .L268+16
 1491              		bl	uart0_printf
 1492 08c4 0A00003E 		.loc 5 69 0
 1493              		mov	r0, #67108864
  38:memtest_run.c ****     {
  39:memtest_run.c ****        uart0_printf("memTestAddressBus FAILED ");
  40:memtest_run.c **** 	   long_to_hex_string((unsigned long ) result_ptr, str, 8);
 1494              	r1, #33554432
 1495 08c8 E28D4002 		bl	memTestDevice2
 1496              		.loc 5 70 0
 1497 08cc E59F013C 		subs	r5, r0, #0
 1498 08d0 EBFFFFFE 	.LVL163:
 1499              		beq	.L261
 1500 08d4 E1A01004 	.L267:
 1501 08d8 E3A02008 		.loc 5 73 0
 1502 08dc E1A00005 		add	r4, sp, #2
 1503 08e0 EBFFFFFE 		.loc 5 72 0
  41:memtest_run.c **** 		uart0_printf(str);uart0_printf("\r\nStep: ");
 1504              	L268+24
 1505 08e4 E1A00004 		bl	uart0_printf
 1506 08e8 EBFFFFFE 		.loc 5 73 0
 1507 08ec E59F0120 		mov	r1, r4
 1508 08f0 EBFFFFFE 		mov	r2, #8
  42:memtest_run.c **** 	   long_to_hex_string((unsigned long ) Step, str, 8);
 1509              	r0, r5
 1510 08f4 E1A01004 		bl	long_to_hex_string
 1511 08f8 E3A02008 		.loc 5 74 0
 1512              		mov	r0, r4
 1513 08fc E59D000C 		bl	uart0_printf
 1514 0900 EBFFFFFE 		ldr	r0, .L268+16
  43:memtest_run.c **** 		uart0_printf(str);uart0_printf("\r\n");
 1515              	rt0_printf
 1516 0904 E1A00004 	.L263:
 1517 0908 EBFFFFFE 		.loc 5 83 0
 1518 090c E59F0104 		ldr	r0, .L268+28
 1519 0910 EBFFFFFE 		bl	uart0_printf
  44:memtest_run.c **** 		//return (-1);
  45:memtest_run.c ****     }
  46:memtest_run.c ****     else
  47:memtest_run.c ****     {
  48:memtest_run.c ****         uart0_printf("memTestAddressBus Passed\r\n");
  49:memtest_run.c ****     }
  50:memtest_run.c **** #endif
  51:memtest_run.c **** 
  52:memtest_run.c **** #ifdef DEVICETEST1
  53:memtest_run.c ****     result_ptr = memTestDevice1(BASE_ADDRESS, NUM_BYTES);
 1520              	 5 85 0
 1521 0914 E3A00301 		add	sp, sp, #16
 1522 0918 E3A01402 		ldmfd	sp!, {r4, r5, pc}
 1523 091c EBFFFFFE 	.LVL164:
  54:memtest_run.c ****     if ( result_ptr != NULL)
 1524              	2:
 1525 0920 E2505000 		.loc 5 30 0
 1526              		ldr	r0, .L268+32
 1527 0924 0A00002D 		bl	uart0_printf
 1528              		.loc 5 36 0
  55:memtest_run.c ****     {
  56:memtest_run.c ****         uart0_printf("memTestDevice1 FAILED ");
  57:memtest_run.c **** 		long_to_hex_string((unsigned long ) result_ptr, str, 8);
 1529              	r0, #67108864
 1530 0928 E28D4002 		mov	r1, #33554432
 1531              		add	r2, sp, #12
 1532 092c E59F00E8 		bl	memTestAddressBus
 1533 0930 EBFFFFFE 		.loc 5 37 0
 1534              		subs	r5, r0, #0
 1535 0934 E1A01004 	.LVL165:
 1536 0938 E3A02008 		bne	.L265
 1537 093c E1A00005 	.L255:
 1538 0940 EBFFFFFE 		.loc 5 48 0
  58:memtest_run.c **** 		uart0_printf(str);uart0_printf("\r\n");
 1539              	L268+36
 1540 0944 E1A00004 		bl	uart0_printf
 1541 0948 EBFFFFFE 		.loc 5 53 0
 1542 094c E59F00C4 		mov	r0, #67108864
 1543 0950 EBFFFFFE 		mov	r1, #33554432
  59:memtest_run.c **** 		//return (-1);
  60:memtest_run.c ****     }
  61:memtest_run.c ****     else
  62:memtest_run.c ****     {
  63:memtest_run.c ****         uart0_printf("memTestDevice1 Passed\r\n");
  64:memtest_run.c **** 		//return (0);
  65:memtest_run.c ****      }
  66:memtest_run.c **** #endif
  67:memtest_run.c **** 
  68:memtest_run.c **** #ifdef DEVICETEST2
  69:memtest_run.c ****     result_ptr = memTestDevice2(BASE_ADDRESS, NUM_BYTES);
 1544              	emTestDevice1
 1545 0954 E3A00301 		.loc 5 54 0
 1546 0958 E3A01402 		subs	r5, r0, #0
 1547 095c EBFFFFFE 	.LVL166:
  70:memtest_run.c ****     if ( result_ptr != NULL)
 1548              		.L266
 1549 0960 E2505000 	.LVL167:
 1550              	.L258:
 1551 0964 0A000024 		.loc 5 63 0
 1552              		ldr	r0, .L268+40
  71:memtest_run.c ****     {
  72:memtest_run.c ****         uart0_printf("memTestDevice2 FAILED ");
  73:memtest_run.c **** 		long_to_hex_string((unsigned long ) result_ptr, str, 8);
 1553              	art0_printf
 1554 0968 E28D4002 		.loc 5 69 0
 1555              		mov	r0, #67108864
 1556 096c E59F00AC 		mov	r1, #33554432
 1557 0970 EBFFFFFE 		bl	memTestDevice2
 1558              		.loc 5 70 0
 1559 0974 E1A01004 		subs	r5, r0, #0
 1560 0978 E3A02008 	.LVL168:
 1561 097c E1A00005 		bne	.L267
 1562 0980 EBFFFFFE 	.L261:
  74:memtest_run.c **** 		uart0_printf(str);uart0_printf("\r\n");
 1563              	 0
 1564 0984 E1A00004 		ldr	r0, .L268+44
 1565 0988 EBFFFFFE 		bl	uart0_printf
 1566 098c E59F0084 		b	.L263
 1567 0990 EBFFFFFE 	.L269:
 1568              		.align	2
  75:memtest_run.c **** 		//return (-1);
  76:memtest_run.c ****     }
  77:memtest_run.c ****     else
  78:memtest_run.c ****     {
  79:memtest_run.c ****         uart0_printf("memTestDevice2 Passed\r\n");
  80:memtest_run.c **** 		//return (0);
  81:memtest_run.c ****      }
  82:memtest_run.c **** #endif
  83:memtest_run.c **** 	  uart0_printf("Mem test complete \r\n");
 1569              	
 1570 0994 E59F0088 		.word	.LC0
 1571 0998 EBFFFFFE 		.word	.LC1
  84:memtest_run.c **** 	//return; 
  85:memtest_run.c **** } //memtest_run()
 1572              	word	.LC3
 1573 099c E28DD010 		.word	.LC4
 1574 09a0 E8BD8030 		.word	.LC5
 1575              		.word	.LC7
 1576              		.word	.LC9
 1577              		.word	.LC11
 1578 09a4 E59F007C 		.word	.LC2
 1579 09a8 EBFFFFFE 		.word	.LC6
 1580              		.word	.LC8
 1581 09ac E3A00301 		.word	.LC10
 1582 09b0 E3A01402 	.LFE32:
 1584 09b8 EBFFFFFE 		.section	.rodata.str1.4
 1585              		.align	2
 1586 09bc E2505000 	.LC12:
 1587              		.ascii	"Starting MEMTEST tests\015\012\000"
 1588 09c0 1AFFFFC0 		.align	2
 1589              	.LC13:
 1590              		.ascii	"BASE ADDRESS:  \000"
 1591 09c4 E59F0060 		.align	2
 1592 09c8 EBFFFFFE 	.LC14:
 1593              		.ascii	"Number of Bytes to test:  \000"
 1594 09cc E3A00301 		.align	2
 1595 09d0 E3A01402 	.LC15:
 1596 09d4 EBFFFFFE 		.ascii	"testing started \012\015\000"
 1597              		.align	2
 1598 09d8 E2505000 	.LC16:
 1599              		.ascii	"testing done \012\015\000"
 1600 09dc 1AFFFFD1 		.text
 1601              		.align	2
 1602              		.global	main
 1604 09e0 E59F0048 	main:
 1605 09e4 EBFFFFFE 	.LFB34:
 1606              		.loc 4 75 0
 1607 09e8 E3A00301 		@ args = 0, pretend = 0, frame = 12
 1608 09ec E3A01402 		@ frame_needed = 0, uses_anonymous_args = 0
 1609 09f0 EBFFFFFE 		stmfd	sp!, {r4, lr}
 1610              	.LCFI10:
 1611 09f4 E2505000 		.loc 4 77 0
 1612              		ldr	r3, .L276
 1613 09f8 1AFFFFDA 		ldrh	r3, [r3, #0]
 1614              		.loc 4 75 0
 1615              		sub	sp, sp, #12
 1616 09fc E59F0030 	.LCFI11:
 1617 0a00 EBFFFFFE 		.loc 4 77 0
 1618 0a04 EAFFFFE2 		strh	r3, [sp, #2]	@ movhi
 1619              		.loc 4 83 0
 1620              		ldr	r0, .L276+4
 1621              		.loc 4 77 0
 1622 0a08 00000000 		mov	r3, #0	@ movhi
 1623 0a0c 00000000 		strh	r3, [sp, #4]	@ movhi
 1624 0a10 00000030 		strh	r3, [sp, #6]	@ movhi
 1625 0a14 0000004C 		strh	r3, [sp, #8]	@ movhi
 1626 0a18 00000058 		strh	r3, [sp, #10]	@ movhi
 1627 0a1c 00000078 		.loc 4 85 0
 1628 0a20 000000A8 		add	r4, sp, #2
 1629 0a24 000000D8 		.loc 4 83 0
 1630 0a28 00000018 		bl	uart0_printf
 1631 0a2c 0000005C 		.loc 4 84 0
 1632 0a30 00000090 		ldr	r0, .L276+8
 1633 0a34 000000C0 		bl	uart0_printf
 1634              		.loc 4 85 0
 1635              		mov	r1, r4
 1636              		mov	r2, #8
 1637 00ed 000000   		mov	r0, #67108864
 1638              		bl	long_to_hex_string
 1639 00f0 53746172 		.loc 4 86 0
 1639      74696E67 
 1639      204D454D 
 1639      54455354 
 1639      20746573 
 1640 0109 000000   		mov	r0, r4
 1641              		bl	uart0_printf
 1642 010c 42415345 		ldr	r0, .L276+12
 1642      20414444 
 1642      52455353 
 1642      3A202000 
 1643              		bl	uart0_printf
 1644              		.loc 4 87 0
 1645 011c 4E756D62 		ldr	r0, .L276+16
 1645      6572206F 
 1645      66204279 
 1645      74657320 
 1645      746F2074 
 1646 0137 00       		bl	uart0_printf
 1647              		.loc 4 88 0
 1648 0138 74657374 		mov	r1, r4
 1648      696E6720 
 1648      73746172 
 1648      74656420 
 1648      0A0D00
 1649 014b 00       		mov	r2, #8
 1650              		mov	r0, #33554432
 1651 014c 74657374 		bl	long_to_hex_string
 1651      696E6720 
 1651      646F6E65 
 1651      200A0D00 
 1652              		.loc 4 89 0
 1653              		mov	r0, r4
 1654              		bl	uart0_printf
 1655              		ldr	r0, .L276+12
 1656              		bl	uart0_printf
 1657              		.loc 4 121 0
  72:main.c        **** 
  73:main.c        **** int
  74:main.c        **** main(void)
  75:main.c        **** {
 1658              	r4, #1
 1659              		.loc 4 124 0
 1660              		bl	memtest_run
 1661 0a38 E92D4010 		.loc 4 123 0
 1662              		cmp	r4, #10
  76:main.c        ****     int i, result = 0;
  77:main.c        **** 	unsigned char str[10]="\0";
 1663              	.L271
 1664 0a3c E59F30A8 		.loc 4 128 0
 1665 0a40 E1D330B0 		ldr	r0, .L276+24
 1666              		bl	uart0_printf
 1667 0a44 E24DD00C 		.loc 4 130 0
 1668              		mov	r0, #0
 1669              		add	sp, sp, #12
 1670 0a48 E1CD30B2 		ldmfd	sp!, {r4, pc}
  78:main.c        **** 	volatile datum * address;
  79:main.c        **** 	datum pattern;
  80:main.c        **** 	datum *result_ptr=NULL;
  81:main.c        **** 	
  82:main.c        **** 
  83:main.c        ****      uart0_printf("Starting MEMTEST tests\r\n");
 1671              	.align	2
 1672 0a4c E59F009C 	.L276:
 1673              		.word	.LC0
 1674 0a50 E3A03000 		.word	.LC12
 1675 0a54 E1CD30B4 		.word	.LC13
 1676 0a58 E1CD30B6 		.word	.LC5
 1677 0a5c E1CD30B8 		.word	.LC14
 1678 0a60 E1CD30BA 		.word	.LC15
  84:main.c        ****      uart0_printf("BASE ADDRESS:  ");
  85:main.c        ****      long_to_hex_string((unsigned long ) BASE_ADDRESS, str, 8);
 1679              	LC16
 1680 0a64 E28D4002 	.LFE34:
 1682 0a68 EBFFFFFE 		.align	2
 1683              		.global	io_enable_xint
 1685 0a70 EBFFFFFE 	io_enable_xint:
 1686              	.LFB23:
 1687 0a74 E1A01004 		.loc 1 444 0
 1688 0a78 E3A02008 		@ args = 0, pretend = 0, frame = 0
 1689 0a7c E3A00301 		@ frame_needed = 0, uses_anonymous_args = 0
 1690 0a80 EBFFFFFE 		@ link register save eliminated.
  86:main.c        ****      uart0_printf(str);uart0_printf("\r\n");
 1691              	 for prologue
 1692 0a84 E1A00004 	.LBB6:
 1693 0a88 EBFFFFFE 	.LBB7:
 1694 0a8c E59F0064 		.loc 1 428 0
 1695 0a90 EBFFFFFE 		 mrs r3, cpsr
  87:main.c        ****      uart0_printf("Number of Bytes to test:  ");
 1696              	70:
 1697 0a94 E59F0060 	.LBE7:
 1698 0a98 EBFFFFFE 	.LBE6:
  88:main.c        ****      long_to_hex_string((unsigned long ) NUM_BYTES, str, 8);
 1699              	B8:
 1700 0a9c E1A01004 	.LBB9:
 1701 0aa0 E3A02008 		.loc 1 437 0
 1702 0aa4 E3A00402 		bic	r3, r3, #192
 1703 0aa8 EBFFFFFE 	.LVL171:
  89:main.c        ****      uart0_printf(str);uart0_printf("\r\n");
 1704              	 cpsr, r3
 1705 0aac E1A00004 	.LBE9:
 1706 0ab0 EBFFFFFE 	.LBE8:
 1707 0ab4 E59F003C 		.loc 1 448 0
 1708 0ab8 EBFFFFFE 		bx	lr
  90:main.c        **** 
  91:main.c        **** #ifdef CLEARMEM	 
  92:main.c        **** 	 //write known pattern to memory
  93:main.c        **** 	 uart0_printf ("Start clearing memory \n\r");
  94:main.c        **** 	 address = 0x04000000;
  95:main.c        **** 	for (pattern = 0x04000000 ; pattern < (0x04000000+NUM_BYTES); pattern = pattern+4 )
  96:main.c        ****     {
  97:main.c        ****         /*
  98:main.c        ****          * Write the "address" pattern.
  99:main.c        ****          */
 100:main.c        ****         * address = pattern;
 101:main.c        **** 		address = address + 1;
 102:main.c        ****     }
 103:main.c        **** 	 uart0_printf ("Done clearing memory \n\r");
 104:main.c        **** #endif	
 105:main.c        **** 
 106:main.c        **** #ifdef MEMLOCWR
 107:main.c        **** 	address = MEMELOC;
 108:main.c        **** 	set_syscpreg(SYS_CTRL_0, DC_WTHRU);
 109:main.c        **** 	for (i=0; i<50; i++) {	
 110:main.c        **** 		* address = 0xaaaaaaaa;
 111:main.c        **** 		
 112:main.c        **** 		long_to_hex_string((unsigned long ) *address, str, 8);
 113:main.c        **** 		uart0_printf(str);uart0_printf("\r\n ");
 114:main.c        **** 		* address = 0x55555555;
 115:main.c        **** 		long_to_hex_string((unsigned long ) *address, str, 8);
 116:main.c        **** 		uart0_printf(str);uart0_printf("\r\n ");
 117:main.c        **** 		set_syscpreg(SYS_CTRL_0, DC_FLUSH);
 118:main.c        **** 	} //for
 119:main.c        **** #endif
 120:main.c        **** 
 121:main.c        **** 	uart0_printf ("testing started \n\r");
 1709              	3:
 1711 0ac0 EBFFFFFE 		.align	2
 1712 0ac4 E3A04000 		.global	io_disable_xint
 1714              	io_disable_xint:
 122:main.c        **** #ifdef MEMTESTRUN
 123:main.c        **** 	for (i=0; i<CYCLES; i++) {	
 1715              	:
 1716 0ac8 E2844001 		.loc 1 454 0
 124:main.c        **** 		memtest_run();
 1717              	 args = 0, pretend = 0, frame = 0
 1718 0acc EBFFFFFE 		@ frame_needed = 0, uses_anonymous_args = 0
 1719              		@ link register save eliminated.
 1720 0ad0 E354000A 		@ lr needed for prologue
 1721 0ad4 1AFFFFFB 	.LBB14:
 125:main.c        **** 	} //for
 126:main.c        **** #endif
 127:main.c        ****    
 128:main.c        ****    uart0_printf ("testing done \n\r");
 1722              	5:
 1723 0ad8 E59F0024 		.loc 1 428 0
 1724 0adc EBFFFFFE 		 mrs r3, cpsr
 129:main.c        **** //	asm volatile ("mov pc, #00010000");
 130:main.c        **** }   /* memTest() */
 1725              	L172:
 1726 0ae0 E3A00000 	.LBE15:
 1727 0ae4 E28DD00C 	.LBE14:
 1728 0ae8 E8BD8010 	.LBB16:
 1729              	.LBB17:
 1730              		.loc 1 437 0
 1731              		orr	r3, r3, #192
 1732 0aec 00000000 	.LVL173:
 1733 0af0 000000F0 		 msr cpsr, r3
 1734 0af4 0000010C 	.LBE17:
 1735 0af8 00000058 	.LBE16:
 1736 0afc 0000011C 		.loc 1 458 0
 1737 0b00 00000138 		bx	lr
 1738 0b04 0000014C 	.LFE24:
 1740              		.section	.debug_frame,"",%progbits
 1741              	.Lframe0:
 1742              		.4byte	.LECIE0-.LSCIE0
 1743              	.LSCIE0:
 1744              		.4byte	0xffffffff
 1745              		.byte	0x1
 417:../lib/io_driver.c **** //		case 14:         asm volatile ("mcr p15,0,%0,c14,c14,0" : /* no outputs */ : "r" (_cp_val)); br
 418:../lib/io_driver.c **** //		case 15:         asm volatile ("mcr p15,0,%0,c15,c15,0" : /* no outputs */ : "r" (_cp_val)); br
 419:../lib/io_driver.c **** 		default:         break;
 420:../lib/io_driver.c **** 	}
 421:../lib/io_driver.c **** }
 422:../lib/io_driver.c **** // ******************************************************************************
 423:../lib/io_driver.c **** // read CMSR value
 424:../lib/io_driver.c ****    static inline unsigned long get_cmsr(void)
 425:../lib/io_driver.c **** // ******************************************************************************
 426:../lib/io_driver.c **** {
 427:../lib/io_driver.c **** 	unsigned long _cmsr;
 428:../lib/io_driver.c **** 	asm volatile (" mrs %0, cpsr" : "=r" (_cmsr) : /* no inputs */  );
 429:../lib/io_driver.c **** 	return _cmsr;
 430:../lib/io_driver.c **** }
 431:../lib/io_driver.c **** 
 432:../lib/io_driver.c **** // ******************************************************************************
 433:../lib/io_driver.c **** // write CMSR value
 434:../lib/io_driver.c ****    static inline void set_cmsr(unsigned long _cmsr)
 435:../lib/io_driver.c **** // ******************************************************************************
 436:../lib/io_driver.c **** {
 437:../lib/io_driver.c **** 	asm volatile (" msr cpsr, %0" : /* no outputs */ : "r" (_cmsr)  );
 438:../lib/io_driver.c **** }
 439:../lib/io_driver.c **** 
 440:../lib/io_driver.c **** // ******************************************************************************
 441:../lib/io_driver.c **** // Enable all external INTs
 442:../lib/io_driver.c ****    void io_enable_xint(void)
 443:../lib/io_driver.c **** // ******************************************************************************
 444:../lib/io_driver.c **** {
 1746              	128 0x1
 1747              		.sleb128 -4
 1748              		.byte	0xe
 1749              		.byte	0xc
 1750              		.uleb128 0xd
 1751              		.uleb128 0x0
 1752              		.align	2
 1753              	.LECIE0:
 1754 0b08 E10F3000 	.LSFDE0:
 1755              		.4byte	.LEFDE0-.LASFDE0
 1756              	.LASFDE0:
 1757              		.4byte	.Lframe0
 1758              		.4byte	.LFB2
 1759              		.4byte	.LFE2-.LFB2
 1760              		.align	2
 1761 0b0c E3C330C0 	.LEFDE0:
 1762              	.LSFDE2:
 1763 0b10 E129F003 		.4byte	.LEFDE2-.LASFDE2
 1764              	.LASFDE2:
 1765              		.4byte	.Lframe0
 445:../lib/io_driver.c **** 	unsigned long _cmsr = get_cmsr();
 446:../lib/io_driver.c **** 	_cmsr = _cmsr & ~(1<<CMSR_FIQ) &~(1<<CMSR_IRQ);
 447:../lib/io_driver.c **** 	set_cmsr(_cmsr);
 448:../lib/io_driver.c **** }
 1766              	e	.LFE3-.LFB3
 1767 0b14 E12FFF1E 		.align	2
 1768              	.LEFDE2:
 1769              	.LSFDE4:
 1770              		.4byte	.LEFDE4-.LASFDE4
 1771              	.LASFDE4:
 1772              		.4byte	.Lframe0
 1773              		.4byte	.LFB4
 1774              		.4byte	.LFE4-.LFB4
 449:../lib/io_driver.c **** 
 450:../lib/io_driver.c **** // ******************************************************************************
 451:../lib/io_driver.c **** // Disable all global IBTs
 452:../lib/io_driver.c ****    void io_disable_xint(void)
 453:../lib/io_driver.c **** // ******************************************************************************
 454:../lib/io_driver.c **** {
 1775              	
 1776              	.LEFDE4:
 1777              	.LSFDE6:
 1778              		.4byte	.LEFDE6-.LASFDE6
 1779              	.LASFDE6:
 1780              		.4byte	.Lframe0
 1781              		.4byte	.LFB5
 1782              		.4byte	.LFE5-.LFB5
 1783 0b18 E10F3000 		.align	2
 1784              	.LEFDE6:
 1785              	.LSFDE8:
 1786              		.4byte	.LEFDE8-.LASFDE8
 1787              	.LASFDE8:
 1788              		.4byte	.Lframe0
 1789              		.4byte	.LFB6
 1790 0b1c E38330C0 		.4byte	.LFE6-.LFB6
 1791              		.align	2
 1792 0b20 E129F003 	.LEFDE8:
 1793              	.LSFDE10:
 1794              		.4byte	.LEFDE10-.LASFDE10
 455:../lib/io_driver.c **** 	unsigned long _cmsr = get_cmsr();
 456:../lib/io_driver.c **** 	_cmsr = _cmsr | (1<<CMSR_FIQ) | (1<<CMSR_IRQ);
 457:../lib/io_driver.c **** 	set_cmsr(_cmsr);
 458:../lib/io_driver.c **** }
 1795              	.Lframe0
 1796 0b24 E12FFF1E 		.4byte	.LFB7
 1797              		.4byte	.LFE7-.LFB7
 1798              		.align	2
 2164              		.4byte	0x0
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:13     .text:00000000 io_read_gpio0_pin
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:22     .text:00000000 $a
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:39     .text:00000018 io_read_gpio0_port
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:59     .text:00000024 io_set_gpio0_pin
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:85     .text:00000040 io_clr_gpio0_pin
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:111    .text:00000064 io_toggle_gpio0_pin
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:137    .text:00000080 io_set_gpio0_port
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:157    .text:0000008c io_set_pwm
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:229    .text:00000108 io_get_pwm
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:282    .text:00000158 io_uart0_read_byte
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:306    .text:00000170 io_uart0_send_byte
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:331    .text:0000018c io_spi0_config
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:361    .text:000001b0 io_spi0_speed
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:381    .text:000001bc io_spi0_trans
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:418    .text:000001f4 io_spi0_enable
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:444    .text:00000210 io_spi0_disable
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:470    .text:00000234 io_i2c0_speed
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:503    .text:00000260 io_i2c0_byte_transfer
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:647    .text:00000390 get_syscpreg
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:662    .text:000003a0 $d
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:679    .text:000003e0 $a
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:785    .text:00000468 set_syscpreg
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:804    .text:0000047c $d
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:814    .text:0000049c $a
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:834    .text:000004bc uart0_printf
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:879    .text:000004f4 uart0_scanf
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:946    .text:0000054c $d
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:952    .text:00000550 uart0_print_buffer
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:958    .text:00000550 $a
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:982    .text:00000574 memTestDataBus
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:1013   .text:00000598 memTestAddressBus
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:1217   .text:0000072c memTestDevice1
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:1278   .text:00000790 memTestDevice2
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:1347   .text:00000800 long_to_hex_string
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:1452   .text:00000870 memtest_run
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:1622   .text:00000a08 $d
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:1656   .text:00000a38 main
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:1661   .text:00000a38 $a
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:1732   .text:00000aec $d
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:1744   .text:00000b08 io_enable_xint
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:1754   .text:00000b08 $a
C:\Users\jh\AppData\Local\Temp/ccYvcaaa.s:1773   .text:00000b18 io_disable_xint

NO UNDEFINED SYMBOLS
