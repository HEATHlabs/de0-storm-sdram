
main.elf:     file format elf32-bigarm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000f14  00000000  00000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .stack        00004000  00001000  00001000  00008f14  2**0
                  ALLOC
  2 .comment      0000001b  00000000  00000000  00008f14  2**0
                  CONTENTS, READONLY
  3 .debug_aranges 00000040  00000000  00000000  00008f30  2**3
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 0000026d  00000000  00000000  00008f70  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000092b  00000000  00000000  000091dd  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000027d  00000000  00000000  00009b08  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000003b1  00000000  00000000  00009d85  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000268  00000000  00000000  0000a138  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000033e  00000000  00000000  0000a3a0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000885  00000000  00000000  0000a6de  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <_boot>:

// Runtime Interrupt Vectors
// -------------------------
Vectors:
        b     _start                    // reset - _start
   0:	ea000012 	b	50 <_mainCRTStartup>
        b     und_handler               // undefined - _undf
   4:	ea000062 	b	194 <und_handler>
        b     swi_handler               // SWI - _swi
   8:	ea000055 	b	164 <swi_handler>
        b     iab_handler               // program abort - _pabt
   c:	ea000048 	b	134 <iab_handler>
        b     iab_handler               // data abort - _dabt
  10:	ea000047 	b	134 <iab_handler>
        nop                             // reserved
  14:	e1a00000 	nop			(mov r0,r0)
        ldr   pc,[pc,#-0xFF0]           // IRQ - read the VIC
  18:	e51ffff0 	ldr	pc, [pc, #-4080]	; fffff030 <_end+0xffffa030>
        ldr   pc,[pc,#-0xFF0]           // FIQ - read the VIC
  1c:	e51ffff0 	ldr	pc, [pc, #-4080]	; fffff034 <_end+0xffffa034>

00000020 <_undf>:
  20:	00000038 	andeq	r0, r0, r8, lsr r0

00000024 <_swi>:
  24:	0000003c 	andeq	r0, r0, ip, lsr r0

00000028 <_pabt>:
  28:	00000040 	andeq	r0, r0, r0, asr #32

0000002c <_dabt>:
  2c:	00000044 	andeq	r0, r0, r4, asr #32

00000030 <_irq>:
  30:	00000048 	andeq	r0, r0, r8, asr #32

00000034 <_fiq>:
  34:	0000004c 	andeq	r0, r0, ip, asr #32

00000038 <__undf>:

#if 0
// Use this group for production
_undf:  .word _reset                    // undefined - _reset
_swi:   .word _reset                    // SWI - _reset
_pabt:  .word _reset                    // program abort - _reset
_dabt:  .word _reset                    // data abort - _reset
_irq:   .word _reset                    // IRQ - _reset
_fiq:   .word _reset                    // FIQ - _reset

#else
// Use this group for development
_undf:  .word __undf                    // undefined
_swi:   .word __swi                     // SWI
_pabt:  .word __pabt                    // program abort
_dabt:  .word __dabt                    // data abort
_irq:   .word __irq                     // IRQ
_fiq:   .word __fiq                     // FIQ

__undf: b     .                         // undefined
  38:	eafffffe 	b	38 <__undf>

0000003c <__swi>:
__swi:  b     .                         // SWI
  3c:	eafffffe 	b	3c <__swi>

00000040 <__pabt>:
__pabt: b     .                         // program abort
  40:	eafffffe 	b	40 <FIQ_BIT>

00000044 <__dabt>:
__dabt: b     .                         // data abort
  44:	eafffffe 	b	44 <__dabt>

00000048 <__irq>:
__irq:  b     .                         // IRQ
  48:	eafffffe 	b	48 <__irq>

0000004c <__fiq>:
__fiq:  b     .                         // FIQ
  4c:	eafffffe 	b	4c <__fiq>

00000050 <_mainCRTStartup>:
#endif
        .size _boot, . - _boot
        .endfunc


// Setup the operating mode & stack.
// ---------------------------------
        .global _start, start, _mainCRTStartup
        .func   _start

_start:
start:
_mainCRTStartup:

// Initialize Interrupt System
// - Set stack location for each mode
// - Leave in System Mode with Interrupts Disabled
// -----------------------------------------------
        ldr   r0,=_stack                    // Calc stack base
  50:	e59f0228 	ldr	r0, [pc, #552]	; 280 <.text+0x280>
		mrs   r1,CPSR
  54:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
  58:	e3c1107f 	bic	r1, r1, #127	; 0x7f
		orr   r1,r1,#MODE_UND|IRQ_BIT|FIQ_BIT  // Change to Undefined Instruction mode
  5c:	e38110db 	orr	r1, r1, #219	; 0xdb
        msr   CPSR,r1
  60:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
  64:	e1a0d000 	mov	sp, r0

        sub   r0,r0,#UND_STACK_SIZE         // Calc stack base
  68:	e2400004 	sub	r0, r0, #4	; 0x4
		mrs   r1,CPSR
  6c:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
  70:	e3c1107f 	bic	r1, r1, #127	; 0x7f
        orr   r1,r1,#MODE_ABT|IRQ_BIT|FIQ_BIT  // Change to Abort Mode
  74:	e38110d7 	orr	r1, r1, #215	; 0xd7
        msr   CPSR,r1
  78:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
  7c:	e1a0d000 	mov	sp, r0

        sub   r0,r0,#ABT_STACK_SIZE         // Calc stack base
  80:	e2400004 	sub	r0, r0, #4	; 0x4
		mrs   r1,CPSR
  84:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
  88:	e3c1107f 	bic	r1, r1, #127	; 0x7f
        orr   r1,r1,#MODE_FIQ|IRQ_BIT|FIQ_BIT  // Change to FIQ Mode
  8c:	e38110d1 	orr	r1, r1, #209	; 0xd1
        msr   CPSR,r1
  90:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
  94:	e1a0d000 	mov	sp, r0

        sub   r0,r0,#FIQ_STACK_SIZE         // Calc stack base
  98:	e2400004 	sub	r0, r0, #4	; 0x4
		mrs   r1,CPSR
  9c:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
  a0:	e3c1107f 	bic	r1, r1, #127	; 0x7f
        orr   r1,r1,#MODE_IRQ|IRQ_BIT|FIQ_BIT  // Change to IRQ Mode
  a4:	e38110d2 	orr	r1, r1, #210	; 0xd2
        msr   CPSR,r1
  a8:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
  ac:	e1a0d000 	mov	sp, r0

        sub   r0,r0,#IRQ_STACK_SIZE         // Calc stack base
  b0:	e2400080 	sub	r0, r0, #128	; 0x80
		mrs   r1,CPSR
  b4:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
  b8:	e3c1107f 	bic	r1, r1, #127	; 0x7f
        orr   r1,r1,#MODE_SVC|IRQ_BIT|FIQ_BIT  // Change to Supervisor Mode
  bc:	e38110d3 	orr	r1, r1, #211	; 0xd3
        msr   CPSR,r1
  c0:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
  c4:	e1a0d000 	mov	sp, r0

        sub   r0,r0,#SVC_STACK_SIZE         // Calc stack base
  c8:	e2400004 	sub	r0, r0, #4	; 0x4
		mrs   r1,CPSR
  cc:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
  d0:	e3c1107f 	bic	r1, r1, #127	; 0x7f
        orr   r1,r1,#MODE_SYS|IRQ_BIT|FIQ_BIT  // Change to System Mode
  d4:	e38110df 	orr	r1, r1, #223	; 0xdf
        msr   CPSR,r1
  d8:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
  dc:	e1a0d000 	mov	sp, r0

// Copy initialized data to its execution address in RAM
// -> not necessary, bootloader can be directly ecxecuted from ROM
// -----------------------------------------------------
//#ifdef ROM_RUN
//        ldr   r1,=_etext                // -> ROM data start
//        ldr   r2,=_data                 // -> data start
//        ldr   r3,=_edata                // -> end of data
//1:      cmp   r2,r3                     // check if data to move
//        ldrlo r0,[r1],#4                // copy it
//        strlo r0,[r2],#4
//        blo   1b                        // loop until done
//#endif

// Clear .bss
// Hell no!
// ----------
//        mov   r0,#0                     // get a zero
//        ldr   r1,=__bss_start           // -> bss start
//        ldr   r2,=__bss_end__           // -> bss end
//2:      cmp   r1,r2                     // check if data to clear
//        strlo r0,[r1],#4                // clear 4 bytes
//        blo   2b                        // loop until done

// Call main program: main(0)
// --------------------------
        mov   r0,#0                     // no arguments (argc = 0)
  e0:	e3a00000 	mov	r0, #0	; 0x0
        mov   r1,r0
  e4:	e1a01000 	mov	r1, r0
        mov   r2,r0
  e8:	e1a02000 	mov	r2, r0
        mov   fp,r0                     // null frame pointer
  ec:	e1a0b000 	mov	fp, r0
        mov   r7,r0                     // null frame pointer for thumb
  f0:	e1a07000 	mov	r7, r0
        ldr   r10,=main
  f4:	e59fa188 	ldr	sl, [pc, #392]	; 284 <.text+0x284>
        mov   lr,pc
  f8:	e1a0e00f 	mov	lr, pc
        bx    r10                       // enter main()
  fc:	e12fff1a 	bx	sl

00000100 <_reset>:

        .size   _start, . - _start
        .endfunc

        .global _reset, reset, exit, abort
        .func   _reset
_reset:
reset:
exit:
abort:

        b     .                         // loop until reset
 100:	eafffffe 	b	100 <_reset>

00000104 <dab_handler>:

// Data Fetch Abort Interrupt Handler
// -------------------------------------------------------------------
dab_handler:
		mov   r13, lr
 104:	e1a0d00e 	mov	sp, lr
		mov   r4, #16
 108:	e3a04010 	mov	r4, #16	; 0x10
		mcr   p15, 0, r4, c13, c13, 0
 10c:	ee0d4f1d 	mcr	15, 0, r4, cr13, cr13, {0}
		mov   r4, #'<'
 110:	e3a0403c 	mov	r4, #60	; 0x3c
		bl    uart0_send_byte
 114:	eb000051 	bl	260 <uart0_send_byte>
		mov   r4, #'D'
 118:	e3a04044 	mov	r4, #68	; 0x44
		bl    uart0_send_byte
 11c:	eb00004f 	bl	260 <uart0_send_byte>
		mov   r4, #'A'
 120:	e3a04041 	mov	r4, #65	; 0x41
		bl    uart0_send_byte
 124:	eb00004d 	bl	260 <uart0_send_byte>
		mov   r4, #'B'
 128:	e3a04042 	mov	r4, #66	; 0x42
		bl    uart0_send_byte
 12c:	eb00004b 	bl	260 <uart0_send_byte>
		b     isr_handler
 130:	ea000022 	b	1c0 <isr_handler>

00000134 <iab_handler>:

// Instruction Fetch Abort Interrupt Handler
// -------------------------------------------------------------------
iab_handler:
		mov   r13, lr
 134:	e1a0d00e 	mov	sp, lr
		mov   r4, #32
 138:	e3a04020 	mov	r4, #32	; 0x20
		mcr   p15, 0, r4, c13, c13, 0
 13c:	ee0d4f1d 	mcr	15, 0, r4, cr13, cr13, {0}
		mov   r4, #'<'
 140:	e3a0403c 	mov	r4, #60	; 0x3c
		bl    uart0_send_byte
 144:	eb000045 	bl	260 <uart0_send_byte>
		mov   r4, #'I'
 148:	e3a04049 	mov	r4, #73	; 0x49
		bl    uart0_send_byte
 14c:	eb000043 	bl	260 <uart0_send_byte>
		mov   r4, #'A'
 150:	e3a04041 	mov	r4, #65	; 0x41
		bl    uart0_send_byte
 154:	eb000041 	bl	260 <uart0_send_byte>
		mov   r4, #'B'
 158:	e3a04042 	mov	r4, #66	; 0x42
		bl    uart0_send_byte
 15c:	eb00003f 	bl	260 <uart0_send_byte>
		b     isr_handler
 160:	ea000016 	b	1c0 <isr_handler>

00000164 <swi_handler>:

// Software Interrupt Handler
// -------------------------------------------------------------------
swi_handler:
		mov   r13, lr
 164:	e1a0d00e 	mov	sp, lr
		mov   r4, #64
 168:	e3a04040 	mov	r4, #64	; 0x40
		mcr   p15, 0, r4, c13, c13, 0
 16c:	ee0d4f1d 	mcr	15, 0, r4, cr13, cr13, {0}
		mov   r4, #'<'
 170:	e3a0403c 	mov	r4, #60	; 0x3c
		bl    uart0_send_byte
 174:	eb000039 	bl	260 <uart0_send_byte>
		mov   r4, #'S'
 178:	e3a04053 	mov	r4, #83	; 0x53
		bl    uart0_send_byte
 17c:	eb000037 	bl	260 <uart0_send_byte>
		mov   r4, #'W'
 180:	e3a04057 	mov	r4, #87	; 0x57
		bl    uart0_send_byte
 184:	eb000035 	bl	260 <uart0_send_byte>
		mov   r4, #'I'
 188:	e3a04049 	mov	r4, #73	; 0x49
		bl    uart0_send_byte
 18c:	eb000033 	bl	260 <uart0_send_byte>
		b     isr_handler
 190:	ea00000a 	b	1c0 <isr_handler>

00000194 <und_handler>:

// Undefined Instruction Interrupt Handler
// -------------------------------------------------------------------
und_handler:
		mov   r13, lr
 194:	e1a0d00e 	mov	sp, lr
		mov   r4, #128
 198:	e3a04080 	mov	r4, #128	; 0x80
		mcr   p15, 0, r4, c13, c13, 0
 19c:	ee0d4f1d 	mcr	15, 0, r4, cr13, cr13, {0}
		mov   r4, #'<'
 1a0:	e3a0403c 	mov	r4, #60	; 0x3c
		bl    uart0_send_byte
 1a4:	eb00002d 	bl	260 <uart0_send_byte>
		mov   r4, #'U'
 1a8:	e3a04055 	mov	r4, #85	; 0x55
		bl    uart0_send_byte
 1ac:	eb00002b 	bl	260 <uart0_send_byte>
		mov   r4, #'N'
 1b0:	e3a0404e 	mov	r4, #78	; 0x4e
		bl    uart0_send_byte
 1b4:	eb000029 	bl	260 <uart0_send_byte>
		mov   r4, #'D'
 1b8:	e3a04044 	mov	r4, #68	; 0x44
		bl    uart0_send_byte
 1bc:	eb000027 	bl	260 <uart0_send_byte>

000001c0 <isr_handler>:

// Interrupt Handler
// -------------------------------------------------------------------
isr_handler:
		mov   r4, #'-'
 1c0:	e3a0402d 	mov	r4, #45	; 0x2d
		bl    uart0_send_byte
 1c4:	eb000025 	bl	260 <uart0_send_byte>
		mov   r4, #'I'
 1c8:	e3a04049 	mov	r4, #73	; 0x49
		bl    uart0_send_byte
 1cc:	eb000023 	bl	260 <uart0_send_byte>
		mov   r4, #'N'
 1d0:	e3a0404e 	mov	r4, #78	; 0x4e
		bl    uart0_send_byte
 1d4:	eb000021 	bl	260 <uart0_send_byte>
		mov   r4, #'T'
 1d8:	e3a04054 	mov	r4, #84	; 0x54
		bl    uart0_send_byte
 1dc:	eb00001f 	bl	260 <uart0_send_byte>
		mov   r4, #' '
 1e0:	e3a04020 	mov	r4, #32	; 0x20
		bl    uart0_send_byte
 1e4:	eb00001d 	bl	260 <uart0_send_byte>
		mov   r4, #'@'
 1e8:	e3a04040 	mov	r4, #64	; 0x40
		bl    uart0_send_byte
 1ec:	eb00001b 	bl	260 <uart0_send_byte>

		sub   r7, r13, #4
 1f0:	e24d7004 	sub	r7, sp, #4	; 0x4
		bl    uart0_print_hex
 1f4:	eb00000a 	bl	224 <uart0_print_hex>

		mov   r4, #' '
 1f8:	e3a04020 	mov	r4, #32	; 0x20
		bl    uart0_send_byte
 1fc:	eb000017 	bl	260 <uart0_send_byte>
		mov   r4, #'['		
 200:	e3a0405b 	mov	r4, #91	; 0x5b
		bl    uart0_send_byte
 204:	eb000015 	bl	260 <uart0_send_byte>

		mrc   p15,0,r7, c9, c9
 208:	ee197f19 	mrc	15, 0, r7, cr9, cr9, {0}
		bl    uart0_print_hex
 20c:	eb000004 	bl	224 <uart0_print_hex>

		mov   r4, #']'
 210:	e3a0405d 	mov	r4, #93	; 0x5d
		bl    uart0_send_byte
 214:	eb000011 	bl	260 <uart0_send_byte>
		mov   r4, #'>'
 218:	e3a0403e 	mov	r4, #62	; 0x3e
		bl    uart0_send_byte
 21c:	eb00000f 	bl	260 <uart0_send_byte>
		b .
 220:	eafffffe 	b	220 <isr_handler+0x60>

00000224 <uart0_print_hex>:


// Send 32-bit HEX value via UART0
// -------------------------------------------------------------------
uart0_print_hex:
		mov   r9, lr // save link register
 224:	e1a0900e 	mov	r9, lr
		mov   r8, #32
 228:	e3a08020 	mov	r8, #32	; 0x20

0000022c <uart0_print_hex_loop>:

uart0_print_hex_loop:
		cmp   r8, #0
 22c:	e3580000 	cmp	r8, #0	; 0x0
		moveq pc, r9
 230:	01a0f009 	moveq	pc, r9

		sub   r8, r8, #4
 234:	e2488004 	sub	r8, r8, #4	; 0x4
		mov   r6, r7, lsr r8 // isolate 4-bit value
 238:	e1a06837 	mov	r6, r7, lsr r8
		and   r6, r6, #0x0F
 23c:	e206600f 	and	r6, r6, #15	; 0xf

		cmp   r6, #9
 240:	e3560009 	cmp	r6, #9	; 0x9
		bgt   adapt_char
 244:	ca000001 	bgt	250 <adapt_char>
		add   r4, r6, #'0'
 248:	e2864030 	add	r4, r6, #48	; 0x30

		b     uart0_print_hex_char
 24c:	ea000001 	b	258 <uart0_print_hex_char>

00000250 <adapt_char>:
adapt_char:
		sub   r6, r6, #10
 250:	e246600a 	sub	r6, r6, #10	; 0xa
		add   r4, r6, #'A'
 254:	e2864041 	add	r4, r6, #65	; 0x41

00000258 <uart0_print_hex_char>:

uart0_print_hex_char:
		bl    uart0_send_byte
 258:	eb000000 	bl	260 <uart0_send_byte>
		b     uart0_print_hex_loop
 25c:	eafffff2 	b	22c <uart0_print_hex_loop>

00000260 <uart0_send_byte>:


// Send one char via UART0
// -------------------------------------------------------------------
uart0_send_byte:
		ldr   r0, =(0xFFFF001C)
 260:	e59f0020 	ldr	r0, [pc, #32]	; 288 <.text+0x288>
		ldr   r0, [r0]
 264:	e5900000 	ldr	r0, [r0]
		and   r0, r0, #0x01
 268:	e2000001 	and	r0, r0, #1	; 0x1
		cmp   r0, #0
 26c:	e3500000 	cmp	r0, #0	; 0x0
		beq   uart0_send_byte
 270:	0afffffa 	beq	260 <uart0_send_byte>
		ldr   r0, =(0xFFFF0018)
 274:	e59f0010 	ldr	r0, [pc, #16]	; 28c <.text+0x28c>
		str   r4, [r0]
 278:	e5804000 	str	r4, [r0]
		mov   pc, lr
 27c:	e1a0f00e 	mov	pc, lr
 280:	00005000 	andeq	r5, r0, r0
 284:	00000cc8 	andeq	r0, r0, r8, asr #25
 288:	ffff001c 	undefined instruction 0xffff001c
 28c:	ffff0018 	undefined instruction 0xffff0018

00000290 <io_read_gpio0_pin>:
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		unsigned long temp = GPIO0_IN & (1<<pin);
 290:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 294:	e5131ffb 	ldr	r1, [r3, #-4091]
 298:	e20020ff 	and	r2, r0, #255	; 0xff
	
//	set_cmsr(_cmsr);
	return temp;
}
 29c:	e3a00001 	mov	r0, #1	; 0x1
 2a0:	e0010210 	and	r0, r1, r0, lsl r2
 2a4:	e12fff1e 	bx	lr

000002a8 <io_read_gpio0_port>:

// ******************************************************************************
// Read general purpose IO port
   unsigned long io_read_gpio0_port(void)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		unsigned long temp = GPIO0_IN;
 2a8:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 2ac:	e5130ffb 	ldr	r0, [r3, #-4091]

//	set_cmsr(_cmsr);
	return temp;
}
 2b0:	e12fff1e 	bx	lr

000002b4 <io_set_gpio0_pin>:

// ******************************************************************************
// Set general purpose IO port
   void io_set_gpio0_pin(unsigned char pin)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		GPIO0_OUT = GPIO0_OUT | (1<<pin);
 2b4:	e3e01a0f 	mvn	r1, #61440	; 0xf000
 2b8:	e5113fff 	ldr	r3, [r1, #-4095]
 2bc:	e20000ff 	and	r0, r0, #255	; 0xff
 2c0:	e3a02001 	mov	r2, #1	; 0x1
 2c4:	e1833012 	orr	r3, r3, r2, lsl r0
 2c8:	e5013fff 	str	r3, [r1, #-4095]

//	set_cmsr(_cmsr);
}
 2cc:	e12fff1e 	bx	lr

000002d0 <io_clr_gpio0_pin>:

// ******************************************************************************
// Clear general purpose IO port
   void io_clr_gpio0_pin(unsigned char pin)
// ******************************************************************************
{
 2d0:	e20000ff 	and	r0, r0, #255	; 0xff
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		GPIO0_OUT = GPIO0_OUT & ~(1<<pin);
 2d4:	e3a02001 	mov	r2, #1	; 0x1
 2d8:	e1a02012 	mov	r2, r2, lsl r0
 2dc:	e3e01a0f 	mvn	r1, #61440	; 0xf000
 2e0:	e5113fff 	ldr	r3, [r1, #-4095]
 2e4:	e1e02002 	mvn	r2, r2
 2e8:	e0033002 	and	r3, r3, r2
 2ec:	e5013fff 	str	r3, [r1, #-4095]

//	set_cmsr(_cmsr);
}
 2f0:	e12fff1e 	bx	lr

000002f4 <io_toggle_gpio0_pin>:
// ******************************************************************************
// Set general purpose IO port
   void io_toggle_gpio0_pin(unsigned char pin)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		GPIO0_OUT = GPIO0_OUT ^ (1<<pin);
 2f4:	e3e01a0f 	mvn	r1, #61440	; 0xf000
 2f8:	e5113fff 	ldr	r3, [r1, #-4095]
 2fc:	e20000ff 	and	r0, r0, #255	; 0xff
 300:	e3a02001 	mov	r2, #1	; 0x1
 304:	e0233012 	eor	r3, r3, r2, lsl r0
 308:	e5013fff 	str	r3, [r1, #-4095]

//	set_cmsr(_cmsr);
}
 30c:	e12fff1e 	bx	lr

00000310 <io_set_gpio0_port>:

// ******************************************************************************
// Clear general purpose IO port
   void io_set_gpio0_port(unsigned long value)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		GPIO0_OUT = value;
 310:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 314:	e5030fff 	str	r0, [r3, #-4095]

//	set_cmsr(_cmsr);
}
 318:	e12fff1e 	bx	lr

0000031c <io_set_pwm>:



// ###########################################################################################################################
// Pulse-Width-Modulation Controller
// ###########################################################################################################################

// ******************************************************************************
// Set pwm value
   void io_set_pwm(unsigned char port, unsigned char data)
// ******************************************************************************
{
 31c:	e20000ff 	and	r0, r0, #255	; 0xff
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	unsigned long temp = 0;

	// value adjustment
	if(port > 7)
 320:	e3500007 	cmp	r0, #7	; 0x7
 324:	e92d4010 	stmdb	sp!, {r4, lr}
 328:	e3a0c000 	mov	ip, #0	; 0x0
 32c:	e3e0e0ff 	mvn	lr, #255	; 0xff
 330:	e20110ff 	and	r1, r1, #255	; 0xff
 334:	8a000011 	bhi	380 <io_set_pwm+0x64>
		port = 0;

	if(port < 4){
		temp = PWM0_CONF0; // get working copy
		temp = temp & ~(0xFF << (port*8)); // clear old value
		temp = temp | (unsigned long)(data << (port*8)); // insert new value
		PWM0_CONF0 = temp;
	}
	else{
		port = port-4;
		temp = PWM0_CONF1; // get working copy
		temp = temp & ~(0xFF << (port*8)); // clear old value
 338:	e2403004 	sub	r3, r0, #4	; 0x4
 33c:	e20330ff 	and	r3, r3, #255	; 0xff
 340:	e3500003 	cmp	r0, #3	; 0x3
 344:	e1a0e183 	mov	lr, r3, lsl #3
 348:	e3e04a0f 	mvn	r4, #61440	; 0xf000
 34c:	e1a0c180 	mov	ip, r0, lsl #3
 350:	9a000007 	bls	374 <io_set_pwm+0x58>
 354:	e3a030ff 	mov	r3, #255	; 0xff
 358:	e1a03e13 	mov	r3, r3, lsl lr
 35c:	e5142f8b 	ldr	r2, [r4, #-3979]
 360:	e1e03003 	mvn	r3, r3
 364:	e0022003 	and	r2, r2, r3
		temp = temp | (unsigned long)(data << (port*8)); // insert new value
 368:	e1822e11 	orr	r2, r2, r1, lsl lr
		PWM0_CONF1 = temp;
 36c:	e5042f8b 	str	r2, [r4, #-3979]
 370:	e8bd8010 	ldmia	sp!, {r4, pc}
 374:	e3a030ff 	mov	r3, #255	; 0xff
 378:	e1a03c13 	mov	r3, r3, lsl ip
 37c:	e1e0e003 	mvn	lr, r3
 380:	e3e02a0f 	mvn	r2, #61440	; 0xf000
 384:	e5123f8f 	ldr	r3, [r2, #-3983]
 388:	e003300e 	and	r3, r3, lr
 38c:	e1833c11 	orr	r3, r3, r1, lsl ip
 390:	e5023f8f 	str	r3, [r2, #-3983]
 394:	e8bd8010 	ldmia	sp!, {r4, pc}

00000398 <io_get_pwm>:
	}
//	set_cmsr(_cmsr);
}

// ******************************************************************************
// Set pwm value
   unsigned char io_get_pwm(unsigned char port)
// ******************************************************************************
{
 398:	e20000ff 	and	r0, r0, #255	; 0xff
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	unsigned long temp = 0;

	// value adjustment
	if(port > 7)
 39c:	e3500007 	cmp	r0, #7	; 0x7
 3a0:	e3a02000 	mov	r2, #0	; 0x0
 3a4:	8a00000a 	bhi	3d4 <io_get_pwm+0x3c>
		port = 0;

	if(port < 4)
		temp = PWM0_CONF0; // get config register
	else{
		port = port-4;
		temp = PWM0_CONF1; // get config register
 3a8:	e2403004 	sub	r3, r0, #4	; 0x4
 3ac:	e3500003 	cmp	r0, #3	; 0x3
 3b0:	e20320ff 	and	r2, r3, #255	; 0xff
 3b4:	9a000005 	bls	3d0 <io_get_pwm+0x38>
 3b8:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 3bc:	e5130f8b 	ldr	r0, [r3, #-3979]
 3c0:	e1a02182 	mov	r2, r2, lsl #3
 3c4:	e1a00230 	mov	r0, r0, lsr r2
 3c8:	e20000ff 	and	r0, r0, #255	; 0xff
	}

	temp = temp >> (port*8); // only keep designated byte

//	set_cmsr(_cmsr);
	return (unsigned char)temp;
}
 3cc:	e12fff1e 	bx	lr
 3d0:	e1a02180 	mov	r2, r0, lsl #3
 3d4:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 3d8:	e5130f8f 	ldr	r0, [r3, #-3983]
 3dc:	e1a00230 	mov	r0, r0, lsr r2
 3e0:	e20000ff 	and	r0, r0, #255	; 0xff
 3e4:	e12fff1e 	bx	lr

000003e8 <io_uart0_read_byte>:



// ###########################################################################################################################
// General Purpose UART "miniUART" (UART_0)
// ###########################################################################################################################

// ******************************************************************************
// Read one byte via UART 0
   int io_uart0_read_byte(void)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	int temp;
	if ((UART0_SREG & (1<<CUART_RXD)) != 0) // byte available?
 3e8:	e3e02a0f 	mvn	r2, #61440	; 0xf000
 3ec:	e5123efb 	ldr	r3, [r2, #-3835]
 3f0:	e3130002 	tst	r3, #2	; 0x2
 3f4:	e3e00000 	mvn	r0, #0	; 0x0
		temp = UART0_DATA;
 3f8:	15120eff 	ldrne	r0, [r2, #-3839]
	else
		temp = -1;

//	set_cmsr(_cmsr);
	return temp;
}
 3fc:	e12fff1e 	bx	lr

00000400 <io_uart0_send_byte>:

// ******************************************************************************
// Write one byte via UART 0
   int io_uart0_send_byte(int ch)
// ******************************************************************************
{
 400:	e3e02a0f 	mvn	r2, #61440	; 0xf000
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 404:	e5123efb 	ldr	r3, [r2, #-3835]
 408:	e3130001 	tst	r3, #1	; 0x1
 40c:	0afffffc 	beq	404 <io_uart0_send_byte+0x4>
	UART0_DATA = (ch & 0x000000FF);
 410:	e20030ff 	and	r3, r0, #255	; 0xff
 414:	e5023eff 	str	r3, [r2, #-3839]

//	set_cmsr(_cmsr);
	return ch;
}
 418:	e12fff1e 	bx	lr

0000041c <io_spi0_config>:



// ###########################################################################################################################
// Serial Peripherial Interface (SPI_CONTROLLER_0)
// ###########################################################################################################################

// ******************************************************************************
// Configure SPI 0
   void io_spi0_config(unsigned char auto_cs, unsigned long data_size)
// ******************************************************************************
{
 41c:	e20000ff 	and	r0, r0, #255	; 0xff
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
	// devices update their serial input on a rising edge of sclk,
	// so we need to update the mosi output of the core before
	// -> at the falling edge of sclk = set SPI_TX_NEG
	if(auto_cs == 1)
 420:	e3500001 	cmp	r0, #1	; 0x1
		SPI0_CONF = (1<<SPI_ACS) | (1<<SPI_TX_NEG) | data_size; // auto assert cs
	else
		SPI0_CONF = (0<<SPI_ACS) | (1<<SPI_TX_NEG) | data_size; // manual assert cs
 424:	e3812b01 	orr	r2, r1, #1024	; 0x400
 428:	03e03a0f 	mvneq	r3, #61440	; 0xf000
 42c:	e3811b09 	orr	r1, r1, #9216	; 0x2400
 430:	13e03a0f 	mvnne	r3, #61440	; 0xf000
 434:	05031cff 	streq	r1, [r3, #-3327]
 438:	15032cff 	strne	r2, [r3, #-3327]
 43c:	e12fff1e 	bx	lr

00000440 <io_spi0_speed>:
//	set_cmsr(_cmsr);
}

// ******************************************************************************
// Configure SPI 0 CLK frequency -> (sys_clk/(spi_clk*2))-1
   void io_spi0_speed(unsigned long clk_divider)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		SPI0_PRSC = clk_divider; // (sys_clk/(spi_clk*2))-1;
 440:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 444:	e5030cfb 	str	r0, [r3, #-3323]

//	set_cmsr(_cmsr);
}
 448:	e12fff1e 	bx	lr

0000044c <io_spi0_trans>:

// ******************************************************************************
// Sends/receives max 32 bits via SPI, CS and config must be done outside
   unsigned long io_spi0_trans(unsigned long data)
// ******************************************************************************
{
 44c:	e3e02a0f 	mvn	r2, #61440	; 0xf000
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	// spi transmission
	while((SPI0_CONF & (1<<SPI_BUSY)) != 0); // wait for prev tx to finish
 450:	e5123cff 	ldr	r3, [r2, #-3327]
 454:	e3130c01 	tst	r3, #256	; 0x100
 458:	1afffffc 	bne	450 <io_spi0_trans+0x4>
	SPI0_DAT0 = data;
 45c:	e5020cef 	str	r0, [r2, #-3311]
	SPI0_CONF = SPI0_CONF | (1<<SPI_BUSY); // start transmitter
 460:	e5123cff 	ldr	r3, [r2, #-3327]
 464:	e3833c01 	orr	r3, r3, #256	; 0x100
 468:	e5023cff 	str	r3, [r2, #-3327]
 46c:	e3e02a0f 	mvn	r2, #61440	; 0xf000
	while((SPI0_CONF & (1<<SPI_BUSY)) != 0); // wait for rx to finish
 470:	e5123cff 	ldr	r3, [r2, #-3327]
 474:	e3130c01 	tst	r3, #256	; 0x100
 478:	1afffffc 	bne	470 <io_spi0_trans+0x24>
	unsigned long temp = SPI0_DAT0;
 47c:	e5120cef 	ldr	r0, [r2, #-3311]

//	set_cmsr(_cmsr);
	return temp;
}
 480:	e12fff1e 	bx	lr

00000484 <io_spi0_enable>:

// ******************************************************************************
// Controls the CS of SPI0, enables a connected CS (turns it LOW)
   void io_spi0_enable(unsigned char device)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		SPI0_SCSR = SPI0_SCSR | (1<<device);
 484:	e3e01a0f 	mvn	r1, #61440	; 0xf000
 488:	e5113cf7 	ldr	r3, [r1, #-3319]
 48c:	e20000ff 	and	r0, r0, #255	; 0xff
 490:	e3a02001 	mov	r2, #1	; 0x1
 494:	e1833012 	orr	r3, r3, r2, lsl r0
 498:	e5013cf7 	str	r3, [r1, #-3319]

//	set_cmsr(_cmsr);
}
 49c:	e12fff1e 	bx	lr

000004a0 <io_spi0_disable>:

// ******************************************************************************
// Controls the CS of SPI0, disables a connected CS (turns it HIGH)
   void io_spi0_disable(unsigned char device)
// ******************************************************************************
{
 4a0:	e20000ff 	and	r0, r0, #255	; 0xff
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		SPI0_SCSR = SPI0_SCSR & ~(1<<device);
 4a4:	e3a02001 	mov	r2, #1	; 0x1
 4a8:	e1a02012 	mov	r2, r2, lsl r0
 4ac:	e3e01a0f 	mvn	r1, #61440	; 0xf000
 4b0:	e5113cf7 	ldr	r3, [r1, #-3319]
 4b4:	e1e02002 	mvn	r2, r2
 4b8:	e0033002 	and	r3, r3, r2
 4bc:	e5013cf7 	str	r3, [r1, #-3319]

//	set_cmsr(_cmsr);
}
 4c0:	e12fff1e 	bx	lr

000004c4 <io_i2c0_speed>:




// ###########################################################################################################################
// Inter Intergrated Circuit Interface (I²C_CONTROLLER_0)
// ###########################################################################################################################

// ******************************************************************************
// Configure SPI 0 CLK frequency -> (sys_clk/(5*i2c_clock)-1
   void io_i2c0_speed(unsigned long clk_divider)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
		I2C0_CTRL = I2C0_CTRL & ~(1<<I2C_EN); // disable i2c core
 4c4:	e3e02a0f 	mvn	r2, #61440	; 0xf000
 4c8:	e5123be7 	ldr	r3, [r2, #-3047]
		I2C0_PRLO = clk_divider;
		I2C0_PRHI = clk_divider >> 8;
 4cc:	e1a01420 	mov	r1, r0, lsr #8
 4d0:	e3c33080 	bic	r3, r3, #128	; 0x80
 4d4:	e5023be7 	str	r3, [r2, #-3047]
 4d8:	e5020bef 	str	r0, [r2, #-3055]
 4dc:	e5021beb 	str	r1, [r2, #-3051]
		I2C0_CTRL = I2C0_CTRL | (1<<I2C_EN); // enable i2c core
 4e0:	e5123be7 	ldr	r3, [r2, #-3047]
 4e4:	e3833080 	orr	r3, r3, #128	; 0x80
 4e8:	e5023be7 	str	r3, [r2, #-3047]
//	set_cmsr(_cmsr);
}
 4ec:	e12fff1e 	bx	lr

000004f0 <io_i2c0_byte_transfer>:

// ******************************************************************************
// Read/write byte from/to I²C slave, max 2 address bytes
   int io_i2c0_byte_transfer(unsigned char rw,        // 'r' read / 'w' write cycle
                             unsigned char id,        // device ID
							 unsigned long data_adr,  // data address
							 unsigned char adr_bytes, // number of adr bytes
							 unsigned char data)      // data byte
// ******************************************************************************
{
 4f0:	e92d4030 	stmdb	sp!, {r4, r5, lr}
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	// transfer slave identification address
	I2C0_DATA = id & 0xFE;                  // device id and write
	I2C0_CMD = (1<<I2C_STA) | (1<<I2C_WR);  // start condition and write cycle
 4f4:	e3a0c090 	mov	ip, #144	; 0x90
 4f8:	e20140fe 	and	r4, r1, #254	; 0xfe
 4fc:	e3e0ea0f 	mvn	lr, #61440	; 0xf000
 500:	e5dd500f 	ldrb	r5, [sp, #15]
 504:	e20000ff 	and	r0, r0, #255	; 0xff
 508:	e50e4be3 	str	r4, [lr, #-3043]
 50c:	e20110ff 	and	r1, r1, #255	; 0xff
 510:	e50ecbff 	str	ip, [lr, #-3071]
 514:	e1a04002 	mov	r4, r2
 518:	e203c0ff 	and	ip, r3, #255	; 0xff
	while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
 51c:	e51e3bff 	ldr	r3, [lr, #-3071]
 520:	e3130002 	tst	r3, #2	; 0x2
 524:	1afffffc 	bne	51c <io_i2c0_byte_transfer+0x2c>
	if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
 528:	e51e3bff 	ldr	r3, [lr, #-3071]
 52c:	e3130080 	tst	r3, #128	; 0x80
 530:	13e00000 	mvnne	r0, #0	; 0x0
 534:	18bd8030 	ldmneia	sp!, {r4, r5, pc}
//		set_cmsr(_cmsr);
		return -1;
	}

	// transfer data address
	while(adr_bytes != 0){
 538:	e35c0000 	cmp	ip, #0	; 0x0
 53c:	0a000012 	beq	58c <io_i2c0_byte_transfer+0x9c>
		adr_bytes--;
 540:	e24c3001 	sub	r3, ip, #1	; 0x1
 544:	e203c0ff 	and	ip, r3, #255	; 0xff
		if(adr_bytes == 1)
 548:	e35c0001 	cmp	ip, #1	; 0x1
			I2C0_DATA = data_adr >> 8;          // high byte
 54c:	01a02424 	moveq	r2, r4, lsr #8
 550:	03e03a0f 	mvneq	r3, #61440	; 0xf000
		else
			I2C0_DATA = data_adr;               // low byte
 554:	13e03a0f 	mvnne	r3, #61440	; 0xf000
 558:	05032be3 	streq	r2, [r3, #-3043]
 55c:	15034be3 	strne	r4, [r3, #-3043]
		I2C0_CMD = (1<<I2C_WR);                 // write cycle
 560:	e3e02a0f 	mvn	r2, #61440	; 0xf000
 564:	e3a03010 	mov	r3, #16	; 0x10
 568:	e5023bff 	str	r3, [r2, #-3071]
		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
 56c:	e5123bff 	ldr	r3, [r2, #-3071]
 570:	e3130002 	tst	r3, #2	; 0x2
 574:	1afffffc 	bne	56c <io_i2c0_byte_transfer+0x7c>
		if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
 578:	e5123bff 	ldr	r3, [r2, #-3071]
 57c:	e3130080 	tst	r3, #128	; 0x80
 580:	0affffec 	beq	538 <io_i2c0_byte_transfer+0x48>
 584:	e3e00001 	mvn	r0, #1	; 0x1
 588:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
//			set_cmsr(_cmsr);
			return -2;
		}
	}

	if(rw == 'w'){
 58c:	e3500077 	cmp	r0, #119	; 0x77
 590:	1a00000c 	bne	5c8 <io_i2c0_byte_transfer+0xd8>
		// write adressed byte
		I2C0_DATA = data;                       // send data
 594:	e3e03a0f 	mvn	r3, #61440	; 0xf000
		I2C0_CMD = (1<<I2C_STO) | (1<<I2C_WR);  // stop condition and write cycle
 598:	e3a02050 	mov	r2, #80	; 0x50
 59c:	e5035be3 	str	r5, [r3, #-3043]
 5a0:	e5032bff 	str	r2, [r3, #-3071]
 5a4:	e1a02003 	mov	r2, r3
		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
 5a8:	e5123bff 	ldr	r3, [r2, #-3071]
 5ac:	e3130002 	tst	r3, #2	; 0x2
 5b0:	1afffffc 	bne	5a8 <io_i2c0_byte_transfer+0xb8>
		if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
 5b4:	e5123bff 	ldr	r3, [r2, #-3071]
 5b8:	e2130080 	ands	r0, r3, #128	; 0x80
 5bc:	08bd8030 	ldmeqia	sp!, {r4, r5, pc}
//			set_cmsr(_cmsr);
			return -3;
		}
		else{
//			set_cmsr(_cmsr);
			return 0;
		}
	}

	if(rw == 'r'){
		// re-send control byte - this time with read-bit
		I2C0_DATA = id | 0x01;                  // device id and READ
		I2C0_CMD = (1<<I2C_STA) | (1<<I2C_WR);  // start condition and write cycle
		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
		if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
//			set_cmsr(_cmsr);
			return -3;
		}
		// read adressed byte
		I2C0_CMD = (1<<I2C_STO) | (1<<I2C_RD) | (1<<I2C_ACK);
		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
		return I2C0_DATA;
 5c0:	e3e00002 	mvn	r0, #2	; 0x2
	}

//	set_cmsr(_cmsr);
	return -4;
}
 5c4:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
 5c8:	e3500072 	cmp	r0, #114	; 0x72
 5cc:	13e00003 	mvnne	r0, #3	; 0x3
 5d0:	18bd8030 	ldmneia	sp!, {r4, r5, pc}
 5d4:	e3813001 	orr	r3, r1, #1	; 0x1
 5d8:	e3e02a0f 	mvn	r2, #61440	; 0xf000
 5dc:	e3a01090 	mov	r1, #144	; 0x90
 5e0:	e5023be3 	str	r3, [r2, #-3043]
 5e4:	e5021bff 	str	r1, [r2, #-3071]
 5e8:	e5123bff 	ldr	r3, [r2, #-3071]
 5ec:	e3130002 	tst	r3, #2	; 0x2
 5f0:	1afffffc 	bne	5e8 <io_i2c0_byte_transfer+0xf8>
 5f4:	e5123bff 	ldr	r3, [r2, #-3071]
 5f8:	e3130080 	tst	r3, #128	; 0x80
 5fc:	1affffef 	bne	5c0 <io_i2c0_byte_transfer+0xd0>
 600:	e3a03068 	mov	r3, #104	; 0x68
 604:	e5023bff 	str	r3, [r2, #-3071]
 608:	e3e00a0f 	mvn	r0, #61440	; 0xf000
 60c:	e5103bff 	ldr	r3, [r0, #-3071]
 610:	e3130002 	tst	r3, #2	; 0x2
 614:	1afffffc 	bne	60c <io_i2c0_byte_transfer+0x11c>
 618:	e5100be3 	ldr	r0, [r0, #-3043]
 61c:	e8bd8030 	ldmia	sp!, {r4, r5, pc}

00000620 <get_syscpreg>:




// ###########################################################################################################################
// System
// ###########################################################################################################################

// ******************************************************************************
// read system coprocessor register x
   unsigned long get_syscpreg(unsigned char index)
// ******************************************************************************
{
 620:	e20000ff 	and	r0, r0, #255	; 0xff
	unsigned long _cp_val;
	switch(index){
 624:	e350000f 	cmp	r0, #15	; 0xf
 628:	979ff100 	ldrls	pc, [pc, r0, lsl #2]
 62c:	ea00000f 	b	670 <.text+0x670>
 630:	000006f0 	streqd	r0, [r0], -r0
 634:	000006e8 	andeq	r0, r0, r8, ror #13
 638:	000006e0 	andeq	r0, r0, r0, ror #13
 63c:	000006d8 	ldreqd	r0, [r0], -r8
 640:	000006d0 	ldreqd	r0, [r0], -r0
 644:	000006c8 	andeq	r0, r0, r8, asr #13
 648:	000006c0 	andeq	r0, r0, r0, asr #13
 64c:	000006b8 	streqh	r0, [r0], -r8
 650:	000006b0 	streqh	r0, [r0], -r0
 654:	000006a8 	andeq	r0, r0, r8, lsr #13
 658:	000006a0 	andeq	r0, r0, r0, lsr #13
 65c:	00000698 	muleq	r0, r8, r6
 660:	00000690 	muleq	r0, r0, r6
 664:	00000688 	andeq	r0, r0, r8, lsl #13
 668:	00000680 	andeq	r0, r0, r0, lsl #13
 66c:	00000678 	andeq	r0, r0, r8, ror r6
 670:	e3a00000 	mov	r0, #0	; 0x0
 674:	e12fff1e 	bx	lr
		case ID_REG_0:   asm volatile ("mrc p15,0,%0, c0, c0" : "=r" (_cp_val) : /* no inputs */  ); break;
		case ID_REG_1:   asm volatile ("mrc p15,0,%0, c1, c1" : "=r" (_cp_val) : /* no inputs */  ); break;
		case ID_REG_2:   asm volatile ("mrc p15,0,%0, c2, c2" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 3:          asm volatile ("mrc p15,0,%0, c3, c3" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 4:          asm volatile ("mrc p15,0,%0, c4, c4" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 5:          asm volatile ("mrc p15,0,%0, c5, c5" : "=r" (_cp_val) : /* no inputs */  ); break;
		case SYS_CTRL_0: asm volatile ("mrc p15,0,%0, c6, c6" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 7:          asm volatile ("mrc p15,0,%0, c7, c7" : "=r" (_cp_val) : /* no inputs */  ); break;
		case CSTAT:      asm volatile ("mrc p15,0,%0, c8, c8" : "=r" (_cp_val) : /* no inputs */  ); break;
		case ADR_FB:     asm volatile ("mrc p15,0,%0, c9, c9" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 10:         asm volatile ("mrc p15,0,%0,c10,c10" : "=r" (_cp_val) : /* no inputs */  ); break;
		case LFSR_POLY:  asm volatile ("mrc p15,0,%0,c11,c11" : "=r" (_cp_val) : /* no inputs */  ); break;
		case LFSR_DATA:  asm volatile ("mrc p15,0,%0,c12,c12" : "=r" (_cp_val) : /* no inputs */  ); break;
		case SYS_IO:     asm volatile ("mrc p15,0,%0,c13,c13" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 14:         asm volatile ("mrc p15,0,%0,c14,c14" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 15:         asm volatile ("mrc p15,0,%0,c15,c15" : "=r" (_cp_val) : /* no inputs */  ); break;
 678:	ee1f0f1f 	mrc	15, 0, r0, cr15, cr15, {0}
		default:         _cp_val = 0; break;
	}
	return _cp_val;
}
 67c:	e12fff1e 	bx	lr
 680:	ee1e0f1e 	mrc	15, 0, r0, cr14, cr14, {0}
 684:	e12fff1e 	bx	lr
 688:	ee1d0f1d 	mrc	15, 0, r0, cr13, cr13, {0}
 68c:	e12fff1e 	bx	lr
 690:	ee1c0f1c 	mrc	15, 0, r0, cr12, cr12, {0}
 694:	e12fff1e 	bx	lr
 698:	ee1b0f1b 	mrc	15, 0, r0, cr11, cr11, {0}
 69c:	e12fff1e 	bx	lr
 6a0:	ee1a0f1a 	mrc	15, 0, r0, cr10, cr10, {0}
 6a4:	e12fff1e 	bx	lr
 6a8:	ee190f19 	mrc	15, 0, r0, cr9, cr9, {0}
 6ac:	e12fff1e 	bx	lr
 6b0:	ee180f18 	mrc	15, 0, r0, cr8, cr8, {0}
 6b4:	e12fff1e 	bx	lr
 6b8:	ee170f17 	mrc	15, 0, r0, cr7, cr7, {0}
 6bc:	e12fff1e 	bx	lr
 6c0:	ee160f16 	mrc	15, 0, r0, cr6, cr6, {0}
 6c4:	e12fff1e 	bx	lr
 6c8:	ee150f15 	mrc	15, 0, r0, cr5, cr5, {0}
 6cc:	e12fff1e 	bx	lr
 6d0:	ee140f14 	mrc	15, 0, r0, cr4, cr4, {0}
 6d4:	e12fff1e 	bx	lr
 6d8:	ee130f13 	mrc	15, 0, r0, cr3, cr3, {0}
 6dc:	e12fff1e 	bx	lr
 6e0:	ee120f12 	mrc	15, 0, r0, cr2, cr2, {0}
 6e4:	e12fff1e 	bx	lr
 6e8:	ee110f11 	mrc	15, 0, r0, cr1, cr1, {0}
 6ec:	e12fff1e 	bx	lr
 6f0:	ee100f10 	mrc	15, 0, r0, cr0, cr0, {0}
 6f4:	e12fff1e 	bx	lr

000006f8 <set_syscpreg>:

// ******************************************************************************
// write system coprocessor register x
   void set_syscpreg(unsigned long _cp_val, unsigned char index)
// ******************************************************************************
{
 6f8:	e20110ff 	and	r1, r1, #255	; 0xff
	switch(index){
 6fc:	e2411006 	sub	r1, r1, #6	; 0x6
 700:	e3510007 	cmp	r1, #7	; 0x7
 704:	979ff101 	ldrls	pc, [pc, r1, lsl #2]
 708:	ea000008 	b	730 <.text+0x730>
 70c:	00000734 	andeq	r0, r0, r4, lsr r7
 710:	00000730 	andeq	r0, r0, r0, lsr r7
 714:	00000730 	andeq	r0, r0, r0, lsr r7
 718:	00000730 	andeq	r0, r0, r0, lsr r7
 71c:	00000730 	andeq	r0, r0, r0, lsr r7
 720:	0000073c 	andeq	r0, r0, ip, lsr r7
 724:	00000744 	andeq	r0, r0, r4, asr #14
 728:	0000072c 	andeq	r0, r0, ip, lsr #14
//		case ID_REG_0:   asm volatile ("mcr p15,0,%0, c0, c0,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case ID_REG_1:   asm volatile ("mcr p15,0,%0, c1, c1,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case ID_REG_2:   asm volatile ("mcr p15,0,%0, c2, c2,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 3:          asm volatile ("mcr p15,0,%0, c3, c3,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 4:          asm volatile ("mcr p15,0,%0, c4, c4,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 5:          asm volatile ("mcr p15,0,%0, c5, c5,0" : /* no outputs */ : "r" (_cp_val)); break;
		case SYS_CTRL_0: asm volatile ("mcr p15,0,%0, c6, c6,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 7:          asm volatile ("mcr p15,0,%0, c7, c7,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case CSTAT:      asm volatile ("mcr p15,0,%0, c8, c8,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case ADR_FB:     asm volatile ("mcr p15,0,%0, c9, c9,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 10:         asm volatile ("mcr p15,0,%0,c10,c10,0" : /* no outputs */ : "r" (_cp_val)); break;
		case LFSR_POLY:  asm volatile ("mcr p15,0,%0,c11,c11,0" : /* no outputs */ : "r" (_cp_val)); break;
		case LFSR_DATA:  asm volatile ("mcr p15,0,%0,c12,c12,0" : /* no outputs */ : "r" (_cp_val)); break;
		case SYS_IO:     asm volatile ("mcr p15,0,%0,c13,c13,0" : /* no outputs */ : "r" (_cp_val)); break;
 72c:	ee0d0f1d 	mcr	15, 0, r0, cr13, cr13, {0}
 730:	e12fff1e 	bx	lr
 734:	ee060f16 	mcr	15, 0, r0, cr6, cr6, {0}
 738:	e12fff1e 	bx	lr
 73c:	ee0b0f1b 	mcr	15, 0, r0, cr11, cr11, {0}
 740:	e12fff1e 	bx	lr
 744:	ee0c0f1c 	mcr	15, 0, r0, cr12, cr12, {0}
 748:	e12fff1e 	bx	lr

0000074c <uart0_printf>:
// ############################################################################################
// Print text string via UART 0
   const char *uart0_printf(const char *string)
// ############################################################################################
{
 74c:	e92d4010 	stmdb	sp!, {r4, lr}
 750:	e1a04000 	mov	r4, r0
	char ch;

	while ((ch = *string)){
 754:	e5d00000 	ldrb	r0, [r0]
 758:	e3500000 	cmp	r0, #0	; 0x0
 75c:	1a000003 	bne	770 <uart0_printf+0x24>
 760:	ea000005 	b	77c <uart0_printf+0x30>
 764:	e5f40001 	ldrb	r0, [r4, #1]!
 768:	e3500000 	cmp	r0, #0	; 0x0
 76c:	0a000002 	beq	77c <uart0_printf+0x30>
		if (io_uart0_send_byte(ch)<=0)
 770:	ebffff22 	bl	400 <io_uart0_send_byte>
 774:	e3500000 	cmp	r0, #0	; 0x0
 778:	cafffff9 	bgt	764 <uart0_printf+0x18>
			break;
		string++;
	}
	return string;
}
 77c:	e1a00004 	mov	r0, r4
 780:	e8bd8010 	ldmia	sp!, {r4, pc}

00000784 <uart0_scanf>:

// ############################################################################################
// Read text string via UART 0
   void uart0_scanf(unsigned char *buffer, int length, unsigned char en_echo)
// ############################################################################################
{
 784:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
	int temp = 0;

	while(length > 0){
 788:	e2514000 	subs	r4, r1, #0	; 0x0
 78c:	e1a05000 	mov	r5, r0
 790:	e20260ff 	and	r6, r2, #255	; 0xff
 794:	da00000b 	ble	7c8 <uart0_scanf+0x44>
		temp = io_uart0_read_byte();
 798:	ebffff12 	bl	3e8 <io_uart0_read_byte>
		if(temp != -1){
 79c:	e3700001 	cmn	r0, #1	; 0x1
			temp = (unsigned char)(temp & 0x000000FF);
 7a0:	e20030ff 	and	r3, r0, #255	; 0xff
 7a4:	0a000005 	beq	7c0 <uart0_scanf+0x3c>
			*buffer++ = temp;
			if(en_echo == 1)
 7a8:	e3560001 	cmp	r6, #1	; 0x1
 7ac:	e5c53000 	strb	r3, [r5]
				io_uart0_send_byte(temp); // echo
 7b0:	e1a00003 	mov	r0, r3
 7b4:	e2855001 	add	r5, r5, #1	; 0x1
 7b8:	0a000005 	beq	7d4 <uart0_scanf+0x50>
			length--;
 7bc:	e2444001 	sub	r4, r4, #1	; 0x1
 7c0:	e3540000 	cmp	r4, #0	; 0x0
 7c4:	cafffff3 	bgt	798 <uart0_scanf+0x14>
		}
	}
	*buffer="\0";
 7c8:	e59f300c 	ldr	r3, [pc, #12]	; 7dc <.text+0x7dc>
 7cc:	e5c53000 	strb	r3, [r5]
}
 7d0:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
 7d4:	ebffff09 	bl	400 <io_uart0_send_byte>
 7d8:	eafffff7 	b	7bc <uart0_scanf+0x38>
 7dc:	00000db8 	streqh	r0, [r0], -r8

000007e0 <uart0_print_buffer>:

// ############################################################################################
// Print character buffer via UART 0
   void uart0_print_buffer(unsigned char *buffer, int size)
// ############################################################################################
{
 7e0:	e92d4030 	stmdb	sp!, {r4, r5, lr}
	unsigned char char_buffer = 0;
	while(size > 0){
 7e4:	e2514000 	subs	r4, r1, #0	; 0x0
 7e8:	e1a05000 	mov	r5, r0
 7ec:	d8bd8030 	ldmleia	sp!, {r4, r5, pc}
		char_buffer = *buffer++;
		io_uart0_send_byte((int)char_buffer);
 7f0:	e4d50001 	ldrb	r0, [r5], #1
 7f4:	ebffff01 	bl	400 <io_uart0_send_byte>
 7f8:	e2544001 	subs	r4, r4, #1	; 0x1
 7fc:	1afffffb 	bne	7f0 <uart0_print_buffer+0x10>
 800:	e8bd8030 	ldmia	sp!, {r4, r5, pc}

00000804 <memTestDataBus>:
 *
 **********************************************************************/
datum
memTestDataBus(volatile datum * address)
{
 804:	e1a02000 	mov	r2, r0
 808:	e3a00001 	mov	r0, #1	; 0x1
    datum pattern;


    /*
     * Perform a walking 1's test at the given address.
     */
    for (pattern = 1; pattern != 0; pattern <<= 1)
    {
        /*
         * Write the test pattern.
         */
        *address = pattern;
 80c:	e5820000 	str	r0, [r2]

        /*
         * Read it back (immediately is okay for this test).
         */
        if (*address != pattern) 
 810:	e5923000 	ldr	r3, [r2]
 814:	e1530000 	cmp	r3, r0
 818:	112fff1e 	bxne	lr
 81c:	e1b00080 	movs	r0, r0, lsl #1
 820:	1afffff9 	bne	80c <memTestDataBus+0x8>
        {
            return (pattern);
        }
    }

    return (0);

}   /* memTestDataBus() */
 824:	e12fff1e 	bx	lr

00000828 <memTestAddressBus>:


/**********************************************************************
 *
 * Function:    memTestAddressBus()
 *
 * Description: Test the address bus wiring in a memory region by
 *              performing a walking 1's test on the relevant bits
 *              of the address and checking for aliasing. This test
 *              will find single-bit address failures such as stuck
 *              -high, stuck-low, and shorted pins.  The base address
 *              and size of the region are selected by the caller.
 *
 * Notes:       For best results, the selected base address should
 *              have enough LSB 0's to guarantee single address bit
 *              changes.  For example, to test a 64-Kbyte region, 
 *              select a base address on a 64-Kbyte boundary.  Also, 
 *              select the region size as a power-of-two--if at all 
 *              possible.
 *
 * Returns:     NULL if the test succeeds.  
 *              A non-zero result is the first address at which an
 *              aliasing problem was uncovered.  By examining the
 *              contents of memory, it may be possible to gather
 *              additional information about the problem.
 *
 **********************************************************************/
datum * 
memTestAddressBus(volatile datum * baseAddress, unsigned long nBytes, int *Step)
{
    unsigned long addressMask = (nBytes/sizeof(datum) - 1);
 828:	e1a01121 	mov	r1, r1, lsr #2
 82c:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
 830:	e241e001 	sub	lr, r1, #1	; 0x1
    unsigned long offset;
    unsigned long testOffset;

    datum pattern     = (datum) 0xAAAAAAAA;
    datum antipattern = (datum) 0x55555555;


    /*
     * Write the default pattern at each of the power-of-two offsets.
     */
    for (offset = 1; (offset & addressMask) != 0; offset <<= 1)
 834:	e21e1001 	ands	r1, lr, #1	; 0x1
 838:	e1a06002 	mov	r6, r2
 83c:	0a000052 	beq	98c <memTestAddressBus+0x164>
 840:	e3a01caa 	mov	r1, #43520	; 0xaa00
 844:	e28110aa 	add	r1, r1, #170	; 0xaa
 848:	e1811801 	orr	r1, r1, r1, lsl #16
 84c:	e3a02001 	mov	r2, #1	; 0x1
    {
        baseAddress[offset] = pattern;
 850:	e1a03102 	mov	r3, r2, lsl #2
 854:	e1a02082 	mov	r2, r2, lsl #1
 858:	e11e0002 	tst	lr, r2
 85c:	e7801003 	str	r1, [r0, r3]
 860:	1afffffa 	bne	850 <memTestAddressBus+0x28>
    }

    /* 
     * Check for address bits stuck high.
     */
    testOffset = 0;
    baseAddress[testOffset] = antipattern;
 864:	e3a03c55 	mov	r3, #21760	; 0x5500
 868:	e2833055 	add	r3, r3, #85	; 0x55
 86c:	e1a05000 	mov	r5, r0
 870:	e1833803 	orr	r3, r3, r3, lsl #16
 874:	e4853004 	str	r3, [r5], #4

    for (offset = 1; (offset & addressMask) != 0; offset <<= 1)
    {
        if (baseAddress[offset] != pattern)
 878:	e5902004 	ldr	r2, [r0, #4]
 87c:	e1520001 	cmp	r2, r1
 880:	11a0c005 	movne	ip, r5
 884:	1a000036 	bne	964 <memTestAddressBus+0x13c>
        {
            *Step = 1;
			return ((datum *) &baseAddress[offset]);
 888:	e3a01001 	mov	r1, #1	; 0x1
 88c:	ea000002 	b	89c <memTestAddressBus+0x74>
 890:	e7903003 	ldr	r3, [r0, r3]
 894:	e1530002 	cmp	r3, r2
 898:	1a000031 	bne	964 <memTestAddressBus+0x13c>
 89c:	e1a01081 	mov	r1, r1, lsl #1
 8a0:	e3a02caa 	mov	r2, #43520	; 0xaa00
 8a4:	e28220aa 	add	r2, r2, #170	; 0xaa
 8a8:	e1a03101 	mov	r3, r1, lsl #2
 8ac:	e11e0001 	tst	lr, r1
 8b0:	e1822802 	orr	r2, r2, r2, lsl #16
 8b4:	e080c003 	add	ip, r0, r3
 8b8:	1afffff4 	bne	890 <memTestAddressBus+0x68>
			
        }
    }

    baseAddress[testOffset] = pattern;
 8bc:	e3a03caa 	mov	r3, #43520	; 0xaa00

    /*
     * Check for address bits stuck low or shorted.
     */
    for (testOffset = 1; (testOffset & addressMask) != 0; testOffset <<= 1)
    {
        baseAddress[testOffset] = antipattern;
 8c0:	e3a02c55 	mov	r2, #21760	; 0x5500
 8c4:	e28330aa 	add	r3, r3, #170	; 0xaa
 8c8:	e2822055 	add	r2, r2, #85	; 0x55
 8cc:	e1833803 	orr	r3, r3, r3, lsl #16
 8d0:	e1822802 	orr	r2, r2, r2, lsl #16
 8d4:	e5803000 	str	r3, [r0]
 8d8:	e5852000 	str	r2, [r5]

		if (baseAddress[0] != pattern)
 8dc:	e5901000 	ldr	r1, [r0]
 8e0:	e1510003 	cmp	r1, r3
 8e4:	03a04001 	moveq	r4, #1	; 0x1
 8e8:	1a000019 	bne	954 <memTestAddressBus+0x12c>
 8ec:	e3a01001 	mov	r1, #1	; 0x1
		{
            *Step = 2;
			return ((datum *) &baseAddress[testOffset]);
		}

        for (offset = 1; (offset & addressMask) != 0; offset <<= 1)
        {
            if ((baseAddress[offset] != pattern) && (offset != testOffset))
 8f0:	e1a03101 	mov	r3, r1, lsl #2
 8f4:	e3a0ccaa 	mov	ip, #43520	; 0xaa00
 8f8:	e7902003 	ldr	r2, [r0, r3]
 8fc:	e28cc0aa 	add	ip, ip, #170	; 0xaa
 900:	e18cc80c 	orr	ip, ip, ip, lsl #16
 904:	e152000c 	cmp	r2, ip
 908:	0a000001 	beq	914 <memTestAddressBus+0xec>
 90c:	e1510004 	cmp	r1, r4
 910:	1a000018 	bne	978 <memTestAddressBus+0x150>
 914:	e1a01081 	mov	r1, r1, lsl #1
 918:	e11e0001 	tst	lr, r1
 91c:	1afffff3 	bne	8f0 <memTestAddressBus+0xc8>
 920:	e1a04084 	mov	r4, r4, lsl #1
 924:	e01e2004 	ands	r2, lr, r4
            {
				*Step = 3;
               return ((datum *) &baseAddress[testOffset]);
            }
        }

        baseAddress[testOffset] = pattern;
 928:	e585c000 	str	ip, [r5]
 92c:	0a000020 	beq	9b4 <memTestAddressBus+0x18c>
 930:	e3a03c55 	mov	r3, #21760	; 0x5500
 934:	e2833055 	add	r3, r3, #85	; 0x55
 938:	e1a01104 	mov	r1, r4, lsl #2
 93c:	e1833803 	orr	r3, r3, r3, lsl #16
 940:	e7803001 	str	r3, [r0, r1]
 944:	e5902000 	ldr	r2, [r0]
 948:	e152000c 	cmp	r2, ip
 94c:	e0805001 	add	r5, r0, r1
 950:	0affffe5 	beq	8ec <memTestAddressBus+0xc4>
 954:	e3a03002 	mov	r3, #2	; 0x2
 958:	e1a01005 	mov	r1, r5
 95c:	e5863000 	str	r3, [r6]
 960:	ea000002 	b	970 <memTestAddressBus+0x148>
 964:	e3a03001 	mov	r3, #1	; 0x1
 968:	e5863000 	str	r3, [r6]
 96c:	e1a0100c 	mov	r1, ip
    }

    return (NULL);

}   /* memTestAddressBus() */
 970:	e1a00001 	mov	r0, r1
 974:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
 978:	e1a01005 	mov	r1, r5
 97c:	e3a03003 	mov	r3, #3	; 0x3
 980:	e1a00001 	mov	r0, r1
 984:	e5863000 	str	r3, [r6]
 988:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
 98c:	e3a03c55 	mov	r3, #21760	; 0x5500
 990:	e3a02caa 	mov	r2, #43520	; 0xaa00
 994:	e2833055 	add	r3, r3, #85	; 0x55
 998:	e28220aa 	add	r2, r2, #170	; 0xaa
 99c:	e1833803 	orr	r3, r3, r3, lsl #16
 9a0:	e1822802 	orr	r2, r2, r2, lsl #16
 9a4:	e5803000 	str	r3, [r0]
 9a8:	e5802000 	str	r2, [r0]
 9ac:	e1a00001 	mov	r0, r1
 9b0:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
 9b4:	e1a01002 	mov	r1, r2
 9b8:	eaffffec 	b	970 <memTestAddressBus+0x148>

000009bc <memTestDevice1>:


/**********************************************************************
 *
 * Function:    memTestDevice()
 *
 * Description: Test the integrity of a physical memory device by
 *              performing an increment/decrement test over the
 *              entire region.  In the process every storage bit 
 *              in the device is tested as a zero and a one.  The
 *              base address and the size of the region are
 *              selected by the caller.
 *
 * Notes:       
 *
 * Returns:     NULL if the test succeeds.
 *
 *              A non-zero result is the first address at which an
 *              incorrect value was read back.  By examining the
 *              contents of memory, it may be possible to gather
 *              additional information about the problem.
 *
 **********************************************************************/
datum * 
memTestDevice1(volatile datum * baseAddress, unsigned long nBytes)	
{
    unsigned long offset;
    unsigned long nWords = nBytes / sizeof(datum);

    datum pattern;
    datum antipattern;


    /*
     * Fill memory with a known pattern.
     */
    for (pattern = 1, offset = 0; offset < nWords; pattern++, offset++)
 9bc:	e1b01121 	movs	r1, r1, lsr #2
 9c0:	0a000013 	beq	a14 <memTestDevice1+0x58>
 9c4:	e3a03001 	mov	r3, #1	; 0x1
 9c8:	e1a02000 	mov	r2, r0
 9cc:	e081c003 	add	ip, r1, r3
    {
        baseAddress[offset] = pattern;
 9d0:	e4823004 	str	r3, [r2], #4
 9d4:	e2833001 	add	r3, r3, #1	; 0x1
 9d8:	e15c0003 	cmp	ip, r3
 9dc:	1afffffb 	bne	9d0 <memTestDevice1+0x14>
    }

    /*
     * Check each location and invert it for the second pass.
     */
    for (pattern = 1, offset = 0; offset < nWords; pattern++, offset++)
    {
        if (baseAddress[offset] != pattern)
 9e0:	e5903000 	ldr	r3, [r0]
 9e4:	e3530001 	cmp	r3, #1	; 0x1
 9e8:	112fff1e 	bxne	lr
        {
            return ((datum *) &baseAddress[offset]);
 9ec:	e2802004 	add	r2, r0, #4	; 0x4
 9f0:	e1a0c003 	mov	ip, r3
 9f4:	ea000002 	b	a04 <memTestDevice1+0x48>
 9f8:	e4923004 	ldr	r3, [r2], #4
 9fc:	e153000c 	cmp	r3, ip
 a00:	1a000005 	bne	a1c <memTestDevice1+0x60>
 a04:	e151000c 	cmp	r1, ip
 a08:	e1a00002 	mov	r0, r2
 a0c:	e28cc001 	add	ip, ip, #1	; 0x1
 a10:	1afffff8 	bne	9f8 <memTestDevice1+0x3c>
 a14:	e3a00000 	mov	r0, #0	; 0x0
        }
 
    }
    return (NULL);

}   /* memTestDevice1() */
 a18:	e12fff1e 	bx	lr
 a1c:	e12fff1e 	bx	lr

00000a20 <memTestDevice2>:
datum * 
memTestDevice2(volatile datum * baseAddress, unsigned long nBytes)	
{
    unsigned long offset;
    unsigned long nWords = nBytes / sizeof(datum);

    datum pattern;
    datum antipattern;

    /*
     * Check each location and invert it for the second pass.
     */
    for (pattern = 1, offset = 0; offset < nWords; pattern++, offset++)
 a20:	e1b01121 	movs	r1, r1, lsr #2
 a24:	e52de004 	str	lr, [sp, #-4]!
 a28:	0a000015 	beq	a84 <memTestDevice2+0x64>
 a2c:	e3a02001 	mov	r2, #1	; 0x1
 a30:	e1a0c000 	mov	ip, r0
 a34:	e081e002 	add	lr, r1, r2
    {
        antipattern = ~pattern;
 a38:	e1e03002 	mvn	r3, r2
 a3c:	e2822001 	add	r2, r2, #1	; 0x1
 a40:	e15e0002 	cmp	lr, r2
        baseAddress[offset] = antipattern;
 a44:	e48c3004 	str	r3, [ip], #4
 a48:	1afffffa 	bne	a38 <memTestDevice2+0x18>
    }

    /*
     * Check each location for the inverted pattern and zero it.
     */
    for (pattern = 1, offset = 0; offset < nWords; pattern++, offset++)
    {
        antipattern = ~pattern;
        if (baseAddress[offset] != antipattern)
 a4c:	e5903000 	ldr	r3, [r0]
 a50:	e3730002 	cmn	r3, #2	; 0x2
 a54:	149df004 	ldrne	pc, [sp], #4
        {
            return ((datum *) &baseAddress[offset]);
 a58:	e2802004 	add	r2, r0, #4	; 0x4
 a5c:	e3a0e001 	mov	lr, #1	; 0x1
 a60:	ea000002 	b	a70 <memTestDevice2+0x50>
 a64:	e4923004 	ldr	r3, [r2], #4
 a68:	e15c0003 	cmp	ip, r3
 a6c:	1a000006 	bne	a8c <memTestDevice2+0x6c>
 a70:	e151000e 	cmp	r1, lr
 a74:	e28ee001 	add	lr, lr, #1	; 0x1
 a78:	e1a00002 	mov	r0, r2
 a7c:	e1e0c00e 	mvn	ip, lr
 a80:	1afffff7 	bne	a64 <memTestDevice2+0x44>
 a84:	e3a00000 	mov	r0, #0	; 0x0
        }
    }

    return (NULL);

}   /* memTestDevice2() */
 a88:	e49df004 	ldr	pc, [sp], #4
 a8c:	e49df004 	ldr	pc, [sp], #4

00000a90 <long_to_hex_string>:
   void long_to_hex_string(unsigned long data,    // max 32 bit data word
                           unsigned char *buffer, // buffer to store the string
						   unsigned char numbers) // number of places, max 8
// ############################################################################################
{
 a90:	e92d4010 	stmdb	sp!, {r4, lr}
 a94:	e20240ff 	and	r4, r2, #255	; 0xff
	unsigned char temp_char = 0;
	unsigned long temp_data = 0;

	// fit into range
	if(numbers > 8)
 a98:	e3540008 	cmp	r4, #8	; 0x8
 a9c:	83a04008 	movhi	r4, #8	; 0x8
 aa0:	8a000001 	bhi	aac <long_to_hex_string+0x1c>
		numbers = 8;
	if(numbers < 1)
 aa4:	e3540000 	cmp	r4, #0	; 0x0
		numbers = 1;

	while(numbers > 0){
		// isolate one 4-bit value
		if(numbers > 1)
			temp_data = data >> ((numbers-1)*4);
		else
			temp_data = data;
		temp_data = temp_data & 0x0000000F;
		numbers--;

		// convert 4-bit value temp_data to char temp_char
		if(temp_data < 10)
			temp_char = '0' + temp_data;
		else
			temp_char = 'A' + temp_data - 10;

		// save character
		*buffer++ = temp_char;
	}

	*buffer++ = 0; // terminate string
}
 aa8:	03a04001 	moveq	r4, #1	; 0x1
 aac:	e1a02001 	mov	r2, r1
 ab0:	e1a0e004 	mov	lr, r4
 ab4:	e1a0310e 	mov	r3, lr, lsl #2
 ab8:	e35e0001 	cmp	lr, #1	; 0x1
 abc:	e2433004 	sub	r3, r3, #4	; 0x4
 ac0:	e1a0c000 	mov	ip, r0
 ac4:	81a0c330 	movhi	ip, r0, lsr r3
 ac8:	e24e3001 	sub	r3, lr, #1	; 0x1
 acc:	e20cc00f 	and	ip, ip, #15	; 0xf
 ad0:	e203e0ff 	and	lr, r3, #255	; 0xff
 ad4:	e35c0009 	cmp	ip, #9	; 0x9
 ad8:	e28c3030 	add	r3, ip, #48	; 0x30
 adc:	828c3037 	addhi	r3, ip, #55	; 0x37
 ae0:	e35e0000 	cmp	lr, #0	; 0x0
 ae4:	e4c23001 	strb	r3, [r2], #1
 ae8:	1afffff1 	bne	ab4 <long_to_hex_string+0x24>
 aec:	e2443001 	sub	r3, r4, #1	; 0x1
 af0:	e20330ff 	and	r3, r3, #255	; 0xff
 af4:	e0813003 	add	r3, r1, r3
 af8:	e5c3e001 	strb	lr, [r3, #1]
 afc:	e8bd8010 	ldmia	sp!, {r4, pc}

00000b00 <memtest_run>:
#define ADDRBTEST
#define DEVICETEST1
#define DEVICETEST2

void memtest_run () {
 b00:	e92d4030 	stmdb	sp!, {r4, r5, lr}
	int Step, result = 0;
	unsigned char str[10]="\0";
 b04:	e59f318c 	ldr	r3, [pc, #396]	; c98 <.text+0xc98>
 b08:	e1d330b0 	ldrh	r3, [r3]
 b0c:	e24dd010 	sub	sp, sp, #16	; 0x10
 b10:	e1cd30b2 	strh	r3, [sp, #2]
	
	datum *result_ptr=NULL;
#ifdef DATABTEST
	result = memTestDataBus(BASE_ADDRESS);
 b14:	e3a00301 	mov	r0, #67108864	; 0x4000000
 b18:	e3a03000 	mov	r3, #0	; 0x0
 b1c:	e1cd30b4 	strh	r3, [sp, #4]
 b20:	e1cd30b6 	strh	r3, [sp, #6]
 b24:	e1cd30b8 	strh	r3, [sp, #8]
 b28:	e1cd30ba 	strh	r3, [sp, #10]
 b2c:	ebffff34 	bl	804 <memTestDataBus>
    if ( result != 0)
 b30:	e3500000 	cmp	r0, #0	; 0x0
 b34:	0a00003e 	beq	c34 <memtest_run+0x134>
    {
        uart0_printf("memTestDataBus FAILED\r\n");
 b38:	e59f015c 	ldr	r0, [pc, #348]	; c9c <.text+0xc9c>
 b3c:	ebffff02 	bl	74c <uart0_printf>
		//return (-1);
    }
    else
    {
        uart0_printf("memTestDataBus Passed\r\n");

    }
#endif

#ifdef ADDRBTEST
	result_ptr = memTestAddressBus(BASE_ADDRESS, NUM_BYTES, &Step);
 b40:	e3a00301 	mov	r0, #67108864	; 0x4000000
 b44:	e3a01402 	mov	r1, #33554432	; 0x2000000
 b48:	e28d200c 	add	r2, sp, #12	; 0xc
 b4c:	ebffff35 	bl	828 <memTestAddressBus>
    if ( result_ptr != NULL)
 b50:	e2505000 	subs	r5, r0, #0	; 0x0
 b54:	0a00003e 	beq	c54 <memtest_run+0x154>
    {
       uart0_printf("memTestAddressBus FAILED ");
	   long_to_hex_string((unsigned long ) result_ptr, str, 8);
 b58:	e28d4002 	add	r4, sp, #2	; 0x2
 b5c:	e59f013c 	ldr	r0, [pc, #316]	; ca0 <.text+0xca0>
 b60:	ebfffef9 	bl	74c <uart0_printf>
 b64:	e1a01004 	mov	r1, r4
 b68:	e3a02008 	mov	r2, #8	; 0x8
 b6c:	e1a00005 	mov	r0, r5
 b70:	ebffffc6 	bl	a90 <long_to_hex_string>
		uart0_printf(str);uart0_printf("\r\nStep: ");
 b74:	e1a00004 	mov	r0, r4
 b78:	ebfffef3 	bl	74c <uart0_printf>
 b7c:	e59f0120 	ldr	r0, [pc, #288]	; ca4 <.text+0xca4>
 b80:	ebfffef1 	bl	74c <uart0_printf>
	   long_to_hex_string((unsigned long ) Step, str, 8);
 b84:	e1a01004 	mov	r1, r4
 b88:	e3a02008 	mov	r2, #8	; 0x8
 b8c:	e59d000c 	ldr	r0, [sp, #12]
 b90:	ebffffbe 	bl	a90 <long_to_hex_string>
		uart0_printf(str);uart0_printf("\r\n");
 b94:	e1a00004 	mov	r0, r4
 b98:	ebfffeeb 	bl	74c <uart0_printf>
 b9c:	e59f0104 	ldr	r0, [pc, #260]	; ca8 <.text+0xca8>
 ba0:	ebfffee9 	bl	74c <uart0_printf>
		//return (-1);
    }
    else
    {
        uart0_printf("memTestAddressBus Passed\r\n");
    }
#endif

#ifdef DEVICETEST1
    result_ptr = memTestDevice1(BASE_ADDRESS, NUM_BYTES);
 ba4:	e3a00301 	mov	r0, #67108864	; 0x4000000
 ba8:	e3a01402 	mov	r1, #33554432	; 0x2000000
 bac:	ebffff82 	bl	9bc <memTestDevice1>
    if ( result_ptr != NULL)
 bb0:	e2505000 	subs	r5, r0, #0	; 0x0
 bb4:	0a00002d 	beq	c70 <memtest_run+0x170>
    {
        uart0_printf("memTestDevice1 FAILED ");
		long_to_hex_string((unsigned long ) result_ptr, str, 8);
 bb8:	e28d4002 	add	r4, sp, #2	; 0x2
 bbc:	e59f00e8 	ldr	r0, [pc, #232]	; cac <.text+0xcac>
 bc0:	ebfffee1 	bl	74c <uart0_printf>
 bc4:	e1a01004 	mov	r1, r4
 bc8:	e3a02008 	mov	r2, #8	; 0x8
 bcc:	e1a00005 	mov	r0, r5
 bd0:	ebffffae 	bl	a90 <long_to_hex_string>
		uart0_printf(str);uart0_printf("\r\n");
 bd4:	e1a00004 	mov	r0, r4
 bd8:	ebfffedb 	bl	74c <uart0_printf>
 bdc:	e59f00c4 	ldr	r0, [pc, #196]	; ca8 <.text+0xca8>
 be0:	ebfffed9 	bl	74c <uart0_printf>
		//return (-1);
    }
    else
    {
        uart0_printf("memTestDevice1 Passed\r\n");
		//return (0);
     }
#endif

#ifdef DEVICETEST2
    result_ptr = memTestDevice2(BASE_ADDRESS, NUM_BYTES);
 be4:	e3a00301 	mov	r0, #67108864	; 0x4000000
 be8:	e3a01402 	mov	r1, #33554432	; 0x2000000
 bec:	ebffff8b 	bl	a20 <memTestDevice2>
    if ( result_ptr != NULL)
 bf0:	e2505000 	subs	r5, r0, #0	; 0x0
 bf4:	0a000024 	beq	c8c <memtest_run+0x18c>
    {
        uart0_printf("memTestDevice2 FAILED ");
		long_to_hex_string((unsigned long ) result_ptr, str, 8);
 bf8:	e28d4002 	add	r4, sp, #2	; 0x2
 bfc:	e59f00ac 	ldr	r0, [pc, #172]	; cb0 <.text+0xcb0>
 c00:	ebfffed1 	bl	74c <uart0_printf>
 c04:	e1a01004 	mov	r1, r4
 c08:	e3a02008 	mov	r2, #8	; 0x8
 c0c:	e1a00005 	mov	r0, r5
 c10:	ebffff9e 	bl	a90 <long_to_hex_string>
		uart0_printf(str);uart0_printf("\r\n");
 c14:	e1a00004 	mov	r0, r4
 c18:	ebfffecb 	bl	74c <uart0_printf>
 c1c:	e59f0084 	ldr	r0, [pc, #132]	; ca8 <.text+0xca8>
 c20:	ebfffec9 	bl	74c <uart0_printf>
		//return (-1);
    }
    else
    {
        uart0_printf("memTestDevice2 Passed\r\n");
		//return (0);
     }
#endif
	  uart0_printf("Mem test complete \r\n");
 c24:	e59f0088 	ldr	r0, [pc, #136]	; cb4 <.text+0xcb4>
 c28:	ebfffec7 	bl	74c <uart0_printf>
	//return; 
} //memtest_run()
 c2c:	e28dd010 	add	sp, sp, #16	; 0x10
 c30:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
 c34:	e59f007c 	ldr	r0, [pc, #124]	; cb8 <.text+0xcb8>
 c38:	ebfffec3 	bl	74c <uart0_printf>
 c3c:	e3a00301 	mov	r0, #67108864	; 0x4000000
 c40:	e3a01402 	mov	r1, #33554432	; 0x2000000
 c44:	e28d200c 	add	r2, sp, #12	; 0xc
 c48:	ebfffef6 	bl	828 <memTestAddressBus>
 c4c:	e2505000 	subs	r5, r0, #0	; 0x0
 c50:	1affffc0 	bne	b58 <memtest_run+0x58>
 c54:	e59f0060 	ldr	r0, [pc, #96]	; cbc <.text+0xcbc>
 c58:	ebfffebb 	bl	74c <uart0_printf>
 c5c:	e3a00301 	mov	r0, #67108864	; 0x4000000
 c60:	e3a01402 	mov	r1, #33554432	; 0x2000000
 c64:	ebffff54 	bl	9bc <memTestDevice1>
 c68:	e2505000 	subs	r5, r0, #0	; 0x0
 c6c:	1affffd1 	bne	bb8 <memtest_run+0xb8>
 c70:	e59f0048 	ldr	r0, [pc, #72]	; cc0 <.text+0xcc0>
 c74:	ebfffeb4 	bl	74c <uart0_printf>
 c78:	e3a00301 	mov	r0, #67108864	; 0x4000000
 c7c:	e3a01402 	mov	r1, #33554432	; 0x2000000
 c80:	ebffff66 	bl	a20 <memTestDevice2>
 c84:	e2505000 	subs	r5, r0, #0	; 0x0
 c88:	1affffda 	bne	bf8 <memtest_run+0xf8>
 c8c:	e59f0030 	ldr	r0, [pc, #48]	; cc4 <.text+0xcc4>
 c90:	ebfffead 	bl	74c <uart0_printf>
 c94:	eaffffe2 	b	c24 <memtest_run+0x124>
 c98:	00000db8 	streqh	r0, [r0], -r8
 c9c:	00000dbc 	streqh	r0, [r0], -ip
 ca0:	00000dec 	andeq	r0, r0, ip, ror #27
 ca4:	00000e08 	andeq	r0, r0, r8, lsl #28
 ca8:	00000e2c 	andeq	r0, r0, ip, lsr #28
 cac:	00000e30 	andeq	r0, r0, r0, lsr lr
 cb0:	00000e60 	andeq	r0, r0, r0, ror #28
 cb4:	00000e90 	muleq	r0, r0, lr
 cb8:	00000dd4 	ldreqd	r0, [r0], -r4
 cbc:	00000e14 	andeq	r0, r0, r4, lsl lr
 cc0:	00000e48 	andeq	r0, r0, r8, asr #28
 cc4:	00000e78 	andeq	r0, r0, r8, ror lr

00000cc8 <main>:

int
main(void)
{
 cc8:	e92d4010 	stmdb	sp!, {r4, lr}
    int i, result = 0;
	unsigned char str[10]="\0";
 ccc:	e59f30a8 	ldr	r3, [pc, #168]	; d7c <.text+0xd7c>
 cd0:	e1d330b0 	ldrh	r3, [r3]
 cd4:	e24dd00c 	sub	sp, sp, #12	; 0xc
 cd8:	e1cd30b2 	strh	r3, [sp, #2]
	volatile datum * address;
	datum pattern;
	datum *result_ptr=NULL;
	

     uart0_printf("Starting MEMTEST tests\r\n");
 cdc:	e59f009c 	ldr	r0, [pc, #156]	; d80 <.text+0xd80>
 ce0:	e3a03000 	mov	r3, #0	; 0x0
 ce4:	e1cd30b4 	strh	r3, [sp, #4]
 ce8:	e1cd30b6 	strh	r3, [sp, #6]
 cec:	e1cd30b8 	strh	r3, [sp, #8]
 cf0:	e1cd30ba 	strh	r3, [sp, #10]
     uart0_printf("BASE ADDRESS:  ");
     long_to_hex_string((unsigned long ) BASE_ADDRESS, str, 8);
 cf4:	e28d4002 	add	r4, sp, #2	; 0x2
 cf8:	ebfffe93 	bl	74c <uart0_printf>
 cfc:	e59f0080 	ldr	r0, [pc, #128]	; d84 <.text+0xd84>
 d00:	ebfffe91 	bl	74c <uart0_printf>
 d04:	e1a01004 	mov	r1, r4
 d08:	e3a02008 	mov	r2, #8	; 0x8
 d0c:	e3a00301 	mov	r0, #67108864	; 0x4000000
 d10:	ebffff5e 	bl	a90 <long_to_hex_string>
     uart0_printf(str);uart0_printf("\r\n");
 d14:	e1a00004 	mov	r0, r4
 d18:	ebfffe8b 	bl	74c <uart0_printf>
 d1c:	e59f0064 	ldr	r0, [pc, #100]	; d88 <.text+0xd88>
 d20:	ebfffe89 	bl	74c <uart0_printf>
     uart0_printf("Number of Bytes to test:  ");
 d24:	e59f0060 	ldr	r0, [pc, #96]	; d8c <.text+0xd8c>
 d28:	ebfffe87 	bl	74c <uart0_printf>
     long_to_hex_string((unsigned long ) NUM_BYTES, str, 8);
 d2c:	e1a01004 	mov	r1, r4
 d30:	e3a02008 	mov	r2, #8	; 0x8
 d34:	e3a00402 	mov	r0, #33554432	; 0x2000000
 d38:	ebffff54 	bl	a90 <long_to_hex_string>
     uart0_printf(str);uart0_printf("\r\n");
 d3c:	e1a00004 	mov	r0, r4
 d40:	ebfffe81 	bl	74c <uart0_printf>
 d44:	e59f003c 	ldr	r0, [pc, #60]	; d88 <.text+0xd88>
 d48:	ebfffe7f 	bl	74c <uart0_printf>

#ifdef CLEARMEM	 
	 //write known pattern to memory
	 uart0_printf ("Start clearing memory \n\r");
	 address = 0x04000000;
	for (pattern = 0x04000000 ; pattern < (0x04000000+NUM_BYTES); pattern = pattern+4 )
    {
        /*
         * Write the "address" pattern.
         */
        * address = pattern;
		address = address + 1;
    }
	 uart0_printf ("Done clearing memory \n\r");
#endif	

#ifdef MEMLOCWR
	address = MEMELOC;
	set_syscpreg(SYS_CTRL_0, DC_WTHRU);
	for (i=0; i<50; i++) {	
		* address = 0xaaaaaaaa;
		
		long_to_hex_string((unsigned long ) *address, str, 8);
		uart0_printf(str);uart0_printf("\r\n ");
		* address = 0x55555555;
		long_to_hex_string((unsigned long ) *address, str, 8);
		uart0_printf(str);uart0_printf("\r\n ");
		set_syscpreg(SYS_CTRL_0, DC_FLUSH);
	} //for
#endif

	uart0_printf ("testing started \n\r");
 d4c:	e59f003c 	ldr	r0, [pc, #60]	; d90 <.text+0xd90>
 d50:	ebfffe7d 	bl	74c <uart0_printf>
 d54:	e3a04000 	mov	r4, #0	; 0x0
#ifdef MEMTESTRUN
	for (i=0; i<CYCLES; i++) {	
 d58:	e2844001 	add	r4, r4, #1	; 0x1
		memtest_run();
 d5c:	ebffff67 	bl	b00 <memtest_run>
 d60:	e354000a 	cmp	r4, #10	; 0xa
 d64:	1afffffb 	bne	d58 <main+0x90>
	} //for
#endif
   
   uart0_printf ("testing done \n\r");
 d68:	e59f0024 	ldr	r0, [pc, #36]	; d94 <.text+0xd94>
 d6c:	ebfffe76 	bl	74c <uart0_printf>
//	asm volatile ("mov pc, #00010000");
}   /* memTest() */
 d70:	e3a00000 	mov	r0, #0	; 0x0
 d74:	e28dd00c 	add	sp, sp, #12	; 0xc
 d78:	e8bd8010 	ldmia	sp!, {r4, pc}
 d7c:	00000db8 	streqh	r0, [r0], -r8
 d80:	00000ea8 	andeq	r0, r0, r8, lsr #29
 d84:	00000ec4 	andeq	r0, r0, r4, asr #29
 d88:	00000e2c 	andeq	r0, r0, ip, lsr #28
 d8c:	00000ed4 	ldreqd	r0, [r0], -r4
 d90:	00000ef0 	streqd	r0, [r0], -r0
 d94:	00000f04 	andeq	r0, r0, r4, lsl #30

00000d98 <io_enable_xint>:
//		case 14:         asm volatile ("mcr p15,0,%0,c14,c14,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 15:         asm volatile ("mcr p15,0,%0,c15,c15,0" : /* no outputs */ : "r" (_cp_val)); break;
		default:         break;
	}
}
// ******************************************************************************
// read CMSR value
   static inline unsigned long get_cmsr(void)
// ******************************************************************************
{
	unsigned long _cmsr;
	asm volatile (" mrs %0, cpsr" : "=r" (_cmsr) : /* no inputs */  );
 d98:	e10f3000 	mrs	r3, CPSR
	return _cmsr;
}

// ******************************************************************************
// write CMSR value
   static inline void set_cmsr(unsigned long _cmsr)
// ******************************************************************************
{
	asm volatile (" msr cpsr, %0" : /* no outputs */ : "r" (_cmsr)  );
 d9c:	e3c330c0 	bic	r3, r3, #192	; 0xc0
 da0:	e129f003 	msr	CPSR_fc, r3
}

// ******************************************************************************
// Enable all external INTs
   void io_enable_xint(void)
// ******************************************************************************
{
	unsigned long _cmsr = get_cmsr();
	_cmsr = _cmsr & ~(1<<CMSR_FIQ) &~(1<<CMSR_IRQ);
	set_cmsr(_cmsr);
}
 da4:	e12fff1e 	bx	lr

00000da8 <io_disable_xint>:
 da8:	e10f3000 	mrs	r3, CPSR
 dac:	e38330c0 	orr	r3, r3, #192	; 0xc0
 db0:	e129f003 	msr	CPSR_fc, r3

// ******************************************************************************
// Disable all global IBTs
   void io_disable_xint(void)
// ******************************************************************************
{
	unsigned long _cmsr = get_cmsr();
	_cmsr = _cmsr | (1<<CMSR_FIQ) | (1<<CMSR_IRQ);
	set_cmsr(_cmsr);
}
 db4:	e12fff1e 	bx	lr
 db8:	00000000 	andeq	r0, r0, r0
 dbc:	6d656d54 	stcvsl	13, cr6, [r5, #-336]!
 dc0:	65737444 	ldrvsb	r7, [r3, #-1092]!
 dc4:	61746142 	cmnvs	r4, r2, asr #2
 dc8:	75732046 	ldrvcb	r2, [r3, #-70]!
 dcc:	41494c45 	cmpmi	r9, r5, asr #24
 dd0:	440d0a00 	strmi	r0, [sp], #-2560
 dd4:	6d656d54 	stcvsl	13, cr6, [r5, #-336]!
 dd8:	65737444 	ldrvsb	r7, [r3, #-1092]!
 ddc:	61746142 	cmnvs	r4, r2, asr #2
 de0:	75732050 	ldrvcb	r2, [r3, #-80]!
 de4:	61737365 	cmnvs	r3, r5, ror #6
 de8:	640d0a00 	strvs	r0, [sp], #-2560
 dec:	6d656d54 	stcvsl	13, cr6, [r5, #-336]!
 df0:	65737441 	ldrvsb	r7, [r3, #-1089]!
 df4:	64647265 	strvsbt	r7, [r4], #-613
 df8:	73734275 	cmnvc	r3, #1342177287	; 0x50000007
 dfc:	73204641 	teqvc	r0, #68157440	; 0x4100000
 e00:	494c4544 	stmmidb	ip, {r2, r6, r8, sl, lr}^
 e04:	20000000 	andcs	r0, r0, r0
 e08:	0d0a5374 	stceq	3, cr5, [sl, #-464]
 e0c:	65703a20 	ldrvsb	r3, [r0, #-2592]!
 e10:	00000000 	andeq	r0, r0, r0
 e14:	6d656d54 	stcvsl	13, cr6, [r5, #-336]!
 e18:	65737441 	ldrvsb	r7, [r3, #-1089]!
 e1c:	64647265 	strvsbt	r7, [r4], #-613
 e20:	73734275 	cmnvc	r3, #1342177287	; 0x50000007
 e24:	73205061 	teqvc	r0, #97	; 0x61
 e28:	73736564 	cmnvc	r3, #419430400	; 0x19000000
 e2c:	0d0a0000 	stceq	0, cr0, [sl]
 e30:	6d656d54 	stcvsl	13, cr6, [r5, #-336]!
 e34:	65737444 	ldrvsb	r7, [r3, #-1092]!
 e38:	65766963 	ldrvsb	r6, [r6, #-2403]!
 e3c:	65312046 	ldrvs	r2, [r1, #-70]!
 e40:	41494c45 	cmpmi	r9, r5, asr #24
 e44:	44200000 	strmit	r0, [r0]
 e48:	6d656d54 	stcvsl	13, cr6, [r5, #-336]!
 e4c:	65737444 	ldrvsb	r7, [r3, #-1092]!
 e50:	65766963 	ldrvsb	r6, [r6, #-2403]!
 e54:	65312050 	ldrvs	r2, [r1, #-80]!
 e58:	61737365 	cmnvs	r3, r5, ror #6
 e5c:	640d0a00 	strvs	r0, [sp], #-2560
 e60:	6d656d54 	stcvsl	13, cr6, [r5, #-336]!
 e64:	65737444 	ldrvsb	r7, [r3, #-1092]!
 e68:	65766963 	ldrvsb	r6, [r6, #-2403]!
 e6c:	65322046 	ldrvs	r2, [r2, #-70]!
 e70:	41494c45 	cmpmi	r9, r5, asr #24
 e74:	44200000 	strmit	r0, [r0]
 e78:	6d656d54 	stcvsl	13, cr6, [r5, #-336]!
 e7c:	65737444 	ldrvsb	r7, [r3, #-1092]!
 e80:	65766963 	ldrvsb	r6, [r6, #-2403]!
 e84:	65322050 	ldrvs	r2, [r2, #-80]!
 e88:	61737365 	cmnvs	r3, r5, ror #6
 e8c:	640d0a00 	strvs	r0, [sp], #-2560
 e90:	4d656d20 	stcmil	13, cr6, [r5, #-128]!
 e94:	74657374 	strvcbt	r7, [r5], #-884
 e98:	20636f6d 	rsbcs	r6, r3, sp, ror #30
 e9c:	706c6574 	rsbvc	r6, ip, r4, ror r5
 ea0:	65200d0a 	strvs	r0, [r0, #-3338]!
 ea4:	00000000 	andeq	r0, r0, r0
 ea8:	53746172 	cmnpl	r4, #-2147483620	; 0x8000001c
 eac:	74696e67 	strvcbt	r6, [r9], #-3687
 eb0:	204d454d 	subcs	r4, sp, sp, asr #10
 eb4:	54455354 	strplb	r5, [r5], #-852
 eb8:	20746573 	rsbcss	r6, r4, r3, ror r5
 ebc:	74730d0a 	ldrvcbt	r0, [r3], #-3338
 ec0:	00000000 	andeq	r0, r0, r0
 ec4:	42415345 	submi	r5, r1, #335544321	; 0x14000001
 ec8:	20414444 	subcs	r4, r1, r4, asr #8
 ecc:	52455353 	subpl	r5, r5, #1275068417	; 0x4c000001
 ed0:	3a202000 	bcc	808ed8 <_end+0x803ed8>
 ed4:	4e756d62 	cdpmi	13, 7, cr6, cr5, cr2, {3}
 ed8:	6572206f 	ldrvsb	r2, [r2, #-111]!
 edc:	66204279 	undefined
 ee0:	74657320 	strvcbt	r7, [r5], #-800
 ee4:	746f2074 	strvcbt	r2, [pc], #116	; eec <io_disable_xint+0x144>
 ee8:	6573743a 	ldrvsb	r7, [r3, #-1082]!
 eec:	20200000 	eorcs	r0, r0, r0
 ef0:	74657374 	strvcbt	r7, [r5], #-884
 ef4:	696e6720 	stmvsdb	lr!, {r5, r8, r9, sl, sp, lr}^
 ef8:	73746172 	cmnvc	r4, #-2147483620	; 0x8000001c
 efc:	74656420 	strvcbt	r6, [r5], #-1056
 f00:	0a0d0000 	beq	340f08 <_end+0x33bf08>
 f04:	74657374 	strvcbt	r7, [r5], #-884
 f08:	696e6720 	stmvsdb	lr!, {r5, r8, r9, sl, sp, lr}^
 f0c:	646f6e65 	strvsbt	r6, [pc], #3685	; f14 <__bss_end__>
 f10:	200a0d00 	andcs	r0, sl, r0, lsl #26
